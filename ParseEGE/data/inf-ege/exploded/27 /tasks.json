{
    "data": [
        {
            "answer": "Решение.Биссектрисами углов, образованных осями координат, служат две прямые:  и  Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (a, a) и (b, –b). Площадь такого треугольника равна |a| · |b|. Эта площадь будет максимальной при максимальных значениях |a| и |b|. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    amax, bmax: integer;    s: integer; {площадь}    i: integer;begin  readln(N);  amax:=0; bmax:=0;  for i:=1 to N do begin    readln(x,y);    if (x=y) and (abs(x)>amax) then amax:=abs(x);    if (x=-y) and (abs(x)>bmax) then bmax:=abs(x);  end;  s:=amax*bmax;  if s=0 then writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  maxs: integer; {максимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  maxs := 0;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = points[i, 2]) and (points[i, 1] <> 0) then a := abs(points[i, 1]);      if (points[j, 1] = -points[j, 2]) and (points[j, 1] <> 0) then b := abs(points[j, 1]);      if (a*b>maxs) and (a * b <> 0) then maxs := a*b;    end;  if maxs = 0 then writeln('Треугольник не существует')  else writeln(maxs);end.",
            "parsed": "2019-04-29 21:13:20.876761",
            "question": "На плоскости задано множество точек с целочисленными координатами. Необходимо найти максимально возможную площадь невырожденного (то есть имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на биссектрисах углов, образованных осями координат, и при этом принадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение.Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа — координаты очередной точки.Пример входных данных:36 6-8 89 7Выходные данныеЕсли искомый треугольник существует, программа должна напечатать одно число: максимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». Пример выходных данных для приведённого выше примера входных данных: 48.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body935619\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами. Необходимо найти максимально возможную площадь невырожденного (то есть имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на биссектрисах углов, образованных осями координат, и при этом принадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение.<p class=\"left_margin\">Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в <i>k</i> раз. <p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p><b>Входные данные</b><p class=\"left_margin\">В первой строке задаётся <i>N</i> — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа — координаты очередной точки.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">6 6<p class=\"left_margin\">-8 8<p class=\"left_margin\">9 7<p><b>Выходные данные</b><p class=\"left_margin\">Если искомый треугольник существует, программа должна напечатать одно число: максимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». <p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных: 48.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Биссектрисами углов, образованных осями координат, служат две прямые:  и  Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (a, a) и (b, –b). Площадь такого треугольника равна |a| · |b|. Эта площадь будет максимальной при максимальных значениях |a| и |b|. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    amax, bmax: integer;    s: integer; {площадь}    i: integer;begin  readln(N);  amax:=0; bmax:=0;  for i:=1 to N do begin    readln(x,y);    if (x=y) and (abs(x)>amax) then amax:=abs(x);    if (x=-y) and (abs(x)>bmax) then bmax:=abs(x);  end;  s:=amax*bmax;  if s=0 then writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  maxs: integer; {максимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  maxs := 0;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = points[i, 2]) and (points[i, 1] <> 0) then a := abs(points[i, 1]);      if (points[j, 1] = -points[j, 2]) and (points[j, 1] <> 0) then b := abs(points[j, 1]);      if (a*b>maxs) and (a * b <> 0) then maxs := a*b;    end;  if maxs = 0 then writeln('Треугольник не существует')  else writeln(maxs);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol10303\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Биссектрисами углов, образованных осями координат, служат две прямые: <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/07/0740ed673b4645e6673f5176495f3d96.svg\" style=\"vertical-align:-3pt\"/> и <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/cd/cd2ee1a4f445254ed6a2263e4ae7621d.svg\" style=\"vertical-align:-3pt\"/> Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (<i>a, a</i>) и (<i>b, –b</i>). Площадь такого треугольника равна |<i>a</i>| · |<i>b</i>|. Эта площадь будет максимальной при максимальных значениях |<i>a</i>| и |<i>b</i>|.<p> </p><p class=\"left_margin\">Пример правильной программы на Паскале<p> </p><p><tt><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    amax, bmax: integer;<p>    s: integer; {площадь}<p>    i: integer;<p>begin<p>  readln(N);<p>  amax:=0; bmax:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x=y) and (abs(x)&gt;amax) then amax:=abs(x);<p>    if (x=-y) and (abs(x)&gt;bmax) then bmax:=abs(x);<p>  end;<p>  s:=amax*bmax;<p>  if s=0 then writeln('Треугольник не существует')<p>  else writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<pre><div class=\"source_code lang_pascal\">var<p>  points: array[1..10000, 1..2] of integer; {исходные данные}<p>  N: integer; {количество точек}<p>  maxs: integer; {максимальная площадь}<p>  a, b: integer;<p>  i, j: integer;<p>begin<p>  readln(N);<p>  maxs := 0;<p>  a := 0; b := 0;<p>  for i := 1 to N do read(points[i, 1], points[i, 2]);<p>  for i := 1 to N do<p>    for j := 1 to N do begin<p>      if (points[i, 1] = points[i, 2]) and (points[i, 1] &lt;&gt; 0) then a := abs(points[i, 1]);<p>      if (points[j, 1] = -points[j, 2]) and (points[j, 1] &lt;&gt; 0) then b := abs(points[j, 1]);<p>      if (a*b&gt;maxs) and (a * b &lt;&gt; 0) then maxs := a*b;<p>    end;<p>  if maxs = 0 then writeln('Треугольник не существует')<p>  else writeln(maxs);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></div>",
            "source": "",
            "task_id": "10303"
        },
        {
            "answer": "Решение.Биссектрисами углов, образованных осями координат, служат две прямые:  и  Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (a, a) и (b, –b). Площадь такого треугольника равна |a| · |b|. Эта площадь будет минимальной при минимально возможных ненулевых значениях  |a| и |b|. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    amin, bmin: integer;    s: integer; {площадь}    i: integer;begin  readln(N);  amin:=0; bmin:=0;  for i:=1 to N do begin    readln(x,y);    if (x=y) and (x<>0) and      ((amin=0) or (abs(x)<amin)) then amin:=abs(x);    if (x=-y) and (x<>0) and      ((bmin=0) or (abs(x)<bmin)) then bmin:=abs(x);  end;  s:=amin*bmin;  if s=0 then writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  mins: integer; {минимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  mins := MaxInt;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = points[i, 2]) and (points[i, 1] <> 0) then a := abs(points[i, 1]);      if (points[j, 1] = -points[j, 2]) and (points[j, 1] <> 0) then b := abs(points[j, 1]);      if (a*b < mins) and (a * b <> 0) then mins := a*b;    end;  if mins = MaxInt then writeln('Треугольник не существует')  else writeln(mins);end.",
            "parsed": "2019-04-29 21:13:21.321515",
            "question": "На плоскости задано множество точек с целочисленными координатами. Необходимо найти минимально возможную площадь невырожденного (то есть имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на биссектрисах углов, образованных осями координат, и при этом  ринадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение.Напишите эффективную по времени и по используемой памяти программу для решения этой задачи. Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта. Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа — координаты очередной точки.Пример входных данных:36 6-8 89 7Выходные данныеЕсли искомый треугольник существует, программа должна напечатать одно число: минимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». Пример выходных данных для приведённого выше примера входных данных: 48",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body935590\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами. Необходимо найти минимально возможную площадь невырожденного (то есть имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на биссектрисах углов, образованных осями координат, и при этом  ринадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение.<p class=\"left_margin\">Напишите эффективную по времени и по используемой памяти программу для решения этой задачи. Программа считается эффективной по времени, если при увеличении количества точек в <i>k</i> раз время работы возрастает не более чем в <i>k</i> раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта. Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p><b>Входные данные</b><p class=\"left_margin\">В первой строке задаётся <i>N</i> — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа — координаты очередной точки.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">6 6<p class=\"left_margin\">-8 8<p class=\"left_margin\">9 7<p><b>Выходные данные</b><p class=\"left_margin\">Если искомый треугольник существует, программа должна напечатать одно число: минимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». <p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных: 48</p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Биссектрисами углов, образованных осями координат, служат две прямые:  и  Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (a, a) и (b, –b). Площадь такого треугольника равна |a| · |b|. Эта площадь будет минимальной при минимально возможных ненулевых значениях  |a| и |b|. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    amin, bmin: integer;    s: integer; {площадь}    i: integer;begin  readln(N);  amin:=0; bmin:=0;  for i:=1 to N do begin    readln(x,y);    if (x=y) and (x<>0) and      ((amin=0) or (abs(x)<amin)) then amin:=abs(x);    if (x=-y) and (x<>0) and      ((bmin=0) or (abs(x)<bmin)) then bmin:=abs(x);  end;  s:=amin*bmin;  if s=0 then writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  mins: integer; {минимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  mins := MaxInt;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = points[i, 2]) and (points[i, 1] <> 0) then a := abs(points[i, 1]);      if (points[j, 1] = -points[j, 2]) and (points[j, 1] <> 0) then b := abs(points[j, 1]);      if (a*b < mins) and (a * b <> 0) then mins := a*b;    end;  if mins = MaxInt then writeln('Треугольник не существует')  else writeln(mins);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol10330\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Биссектрисами углов, образованных осями координат, служат две прямые: <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/07/0740ed673b4645e6673f5176495f3d96.svg\" style=\"vertical-align:-3pt\"/> и <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/cd/cd2ee1a4f445254ed6a2263e4ae7621d.svg\" style=\"vertical-align:-3pt\"/> Очевидно, что вершины невырожденного треугольника должны лежать на разных биссектрисах, их координаты должны иметь вид (<i>a, a</i>) и (<i>b, –b</i>). Площадь такого треугольника равна |<i>a</i>| · |<i>b</i>|. Эта площадь будет минимальной при минимально возможных ненулевых значениях  |<i>a</i>| и |<i>b</i>|.<p> </p><p class=\"left_margin\">Пример правильной программы на Паскале<p> </p><p><tt><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    amin, bmin: integer;<p>    s: integer; {площадь}<p>    i: integer;<p>begin<p>  readln(N);<p>  amin:=0; bmin:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x=y) and (x&lt;&gt;0) and<p>      ((amin=0) or (abs(x)&lt;amin)) then amin:=abs(x);<p>    if (x=-y) and (x&lt;&gt;0) and<p>      ((bmin=0) or (abs(x)&lt;bmin)) then bmin:=abs(x);<p>  end;<p>  s:=amin*bmin;<p>  if s=0 then writeln('Треугольник не существует')<p>  else writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<pre><div class=\"source_code lang_pascal\">var<p>  points: array[1..10000, 1..2] of integer; {исходные данные}<p>  N: integer; {количество точек}<p>  mins: integer; {минимальная площадь}<p>  a, b: integer;<p>  i, j: integer;<p>begin<p>  readln(N);<p>  mins := MaxInt;<p>  a := 0; b := 0;<p>  for i := 1 to N do read(points[i, 1], points[i, 2]);<p>  for i := 1 to N do<p>    for j := 1 to N do begin<p>      if (points[i, 1] = points[i, 2]) and (points[i, 1] &lt;&gt; 0) then a := abs(points[i, 1]);<p>      if (points[j, 1] = -points[j, 2]) and (points[j, 1] &lt;&gt; 0) then b := abs(points[j, 1]);<p>      if (a*b &lt; mins) and (a * b &lt;&gt; 0) then mins := a*b;<p>    end;<p>  if mins = MaxInt then writeln('Треугольник не существует')<p>  else writeln(mins);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></div>",
            "source": "",
            "task_id": "10330"
        },
        {
            "answer": "Решение.Отрезок, концы которого не лежат на осях координат, пересекается с обеими осями координат в том и только в том случае, если его концы лежат в противоположных четвертях. Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то количество отрезков равно n1n3 + n2n4.Эффективная программа решения задачи подсчитывает количество точек по четвертям и вычисляет ответ по вышеприведённой формуле.Ниже приводится такая программа на языках Паскаль и Java. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество отрезков}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := n1*n3 + n2*n4;writeln(s)end. Пример правильной и эффективной программы на языке Java import java.util.Scanner;public class P27B {  public static void main(String args[]) {    Scanner in = new Scanner(System.in);    int N = in.nextInt();    int n1 = 0, n2 = 0, n3 = 0, n4 = 0;    for (int i=0; i<N; ++i) {      int x = in.nextInt();      int y = in.nextInt();      if (x > 0 && y > 0) { n1++ ; }      if (x < 0 && y > 0) { n2++ ; }      if (x < 0 && y < 0) { n3++ ; }      if (x > 0 && y < 0) { n4++ ; }    }    int s = n1*n3 + n2*n4;    System.out.println(s);  }} Пример правильной, но неэффективной программы на языке Паскаль.var  N: integer; {количество точек}  a: array[1..10000, 1..2] of integer; {исходные данные}  s: integer; {количество отрезков}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if ((a[i, 1]>0) and (a[i, 2] > 0) and (a[j, 1] < 0) and (a[j, 2] < 0)) then        s := s + 1;      if ((a[i, 1]<0) and (a[i, 2] > 0) and (a[j, 1] > 0) and (a[j, 2] < 0)) then        s := s + 1;      end;  writeln(s);end.",
            "parsed": "2019-04-29 21:13:21.719046",
            "question": "На плоскости задано множество точек с целочисленными координатами. Необходимо найти количество отрезков, обладающих следующими свойствами:1) оба конца отрезка принадлежат заданному множеству;2) ни один конец отрезка не лежит на осях координат;3) отрезок пересекается с обеими осями координат.Напишите эффективную по времени и по используемой памяти программу для решения этой задачи. Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз.Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа x и y — координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000; –1000 ≤ x, y ≤ 1000.Пример входных данных:46 6-8 8-9 -97 -5Выходные данныеНеобходимо вывести единственное число: количество удовлетворяющих требованиям отрезков.Пример выходных данных для приведённого выше примера входных данных: 2.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body935488\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами. Необходимо найти количество отрезков, обладающих следующими свойствами:<p class=\"left_margin\">1) оба конца отрезка принадлежат заданному множеству;<p class=\"left_margin\">2) ни один конец отрезка не лежит на осях координат;<p class=\"left_margin\">3) отрезок пересекается с обеими осями координат.<p class=\"left_margin\">Напишите эффективную по времени и по используемой памяти программу для решения этой задачи. Программа считается эффективной по времени, если при увеличении количества точек в <i>k</i> раз время работы возрастает не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p class=\"left_margin\"><b>Входные данные</b><p class=\"left_margin\">В первой строке задаётся <i>N</i> — количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа <i>x</i> и <i>y</i> — координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000; –1000 ≤ x, y ≤ 1000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">4<p class=\"left_margin\">6 6<p class=\"left_margin\">-8 8<p class=\"left_margin\">-9 -9<p class=\"left_margin\">7 -5<p><b>Выходные данные</b><p class=\"left_margin\">Необходимо вывести единственное число: количество удовлетворяющих требованиям отрезков.<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных: 2.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Отрезок, концы которого не лежат на осях координат, пересекается с обеими осями координат в том и только в том случае, если его концы лежат в противоположных четвертях. Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то количество отрезков равно n1n3 + n2n4.Эффективная программа решения задачи подсчитывает количество точек по четвертям и вычисляет ответ по вышеприведённой формуле.Ниже приводится такая программа на языках Паскаль и Java. Пример правильной программы на Паскале program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество отрезков}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := n1*n3 + n2*n4;writeln(s)end. Пример правильной и эффективной программы на языке Java import java.util.Scanner;public class P27B {  public static void main(String args[]) {    Scanner in = new Scanner(System.in);    int N = in.nextInt();    int n1 = 0, n2 = 0, n3 = 0, n4 = 0;    for (int i=0; i<N; ++i) {      int x = in.nextInt();      int y = in.nextInt();      if (x > 0 && y > 0) { n1++ ; }      if (x < 0 && y > 0) { n2++ ; }      if (x < 0 && y < 0) { n3++ ; }      if (x > 0 && y < 0) { n4++ ; }    }    int s = n1*n3 + n2*n4;    System.out.println(s);  }} Пример правильной, но неэффективной программы на языке Паскаль.var  N: integer; {количество точек}  a: array[1..10000, 1..2] of integer; {исходные данные}  s: integer; {количество отрезков}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if ((a[i, 1]>0) and (a[i, 2] > 0) and (a[j, 1] < 0) and (a[j, 2] < 0)) then        s := s + 1;      if ((a[i, 1]<0) and (a[i, 2] > 0) and (a[j, 1] > 0) and (a[j, 2] < 0)) then        s := s + 1;      end;  writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol10428\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Отрезок, концы которого не лежат на осях координат, пересекается с обеими осями координат в том и только в том случае, если его концы лежат в противоположных четвертях. Если известны величины <i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>, <i>n</i><sub>3</sub>, <i>n</i><sub>4</sub>, показывающие количество точек в каждой четверти, то количество отрезков равно <i>n</i><sub>1</sub><i>n</i><sub>3</sub> + <i>n</i><sub>2</sub><i>n</i><sub>4</sub>.<p class=\"left_margin\">Эффективная программа решения задачи подсчитывает количество точек по четвертям и вычисляет ответ по вышеприведённой формуле.<p class=\"left_margin\">Ниже приводится такая программа на языках Паскаль и Java.<p> </p><p class=\"left_margin\">Пример правильной программы на Паскале<p> </p><p><tt><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    n1, n2, n3, n4: integer;<p>      {количество точек по четвертям}<p>    s: integer; {количество отрезков}<p>    i: integer;<p>begin<p>  readln(N);<p>  n1:=0; n2:=0; n3:=0; n4:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x&gt;0) and (y&gt;0) then n1 := n1+1;<p>    if (x&lt;0) and (y&gt;0) then n2 := n2+1;<p>    if (x&lt;0) and (y&lt;0) then n3 := n3+1;<p>    if (x&gt;0) and (y&lt;0) then n4 := n4+1;<p>  end;<p>  s := n1*n3 + n2*n4;<p>writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Java<p> </p><p><tt><p>import java.util.Scanner;<p>public class P27B {<p>  public static void main(String args[]) {<p>    Scanner in = new Scanner(System.in);<p>    int N = in.nextInt();<p>    int n1 = 0, n2 = 0, n3 = 0, n4 = 0;<p>    for (int i=0; i&lt;N; ++i) {<p>      int x = in.nextInt();<p>      int y = in.nextInt();<p>      if (x &gt; 0 &amp;&amp; y &gt; 0) { n1++ ; }<p>      if (x &lt; 0 &amp;&amp; y &gt; 0) { n2++ ; }<p>      if (x &lt; 0 &amp;&amp; y &lt; 0) { n3++ ; }<p>      if (x &gt; 0 &amp;&amp; y &lt; 0) { n4++ ; }<p>    }<p>    int s = n1*n3 + n2*n4;<p>    System.out.println(s);<p>  }<p>}<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<pre><div class=\"source_code lang_pascal\">var<p>  N: integer; {количество точек}<p>  a: array[1..10000, 1..2] of integer; {исходные данные}<p>  s: integer; {количество отрезков}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  for i := 1 to N do read(a[i, 1], a[i, 2]);<p>  for i := 1 to N do<p>    for j := 1 to N do begin<p>      if ((a[i, 1]&gt;0) and (a[i, 2] &gt; 0) and (a[j, 1] &lt; 0) and (a[j, 2] &lt; 0)) then<p>        s := s + 1;<p>      if ((a[i, 1]&lt;0) and (a[i, 2] &gt; 0) and (a[j, 1] &gt; 0) and (a[j, 2] &lt; 0)) then<p>        s := s + 1;<p>      end;<p>  writeln(s);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "10428"
        },
        {
            "answer": "Решение.Задание А. Ниже приводится пример переборного решения на Паскале, не эффективного ни по памяти, ни по времени, но являющимся правильным ответом на задание А.Программа 1.  const s = 15; {требуемое расстояние между показаниями} var    N: integer;    a: array[1..10000] of integer; {все показания датчика}    mp: integer; {минимальное значение произведения}    i, j: integer; begin    readln(N);    {Ввод значений датчика}    for i:=1 to N do        readln(a[i]);    mp := 1000 * 1000 + 1;    for i := 1 to N − s do begin        for j := i + s to N do begin            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] < mp)                then mp := a[i]*a[j]        end;    end;    if mp = 1000 * 1000 + 1 then mp := −1;    writeln(mp) end.Задание Б. Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. Для каждого показания с номером k, начиная с k = 16, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 15. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 15 элементов ранее, и выбрать минимальное из всех таких произведений.Ниже приводится пример такой программы на Паскале, эффективной по памяти и по времени.Программа 2. const s = 15; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N: integer;    a: array[1..s] of integer; {хранение s показаний датчика}    a_: integer; {ввод очередного показания}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения}    p: integer;    i, j: integer; begin    readln(N);    {Ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {Ввод остальных значений, поиск минимального произведения}    ma := amax; me := amax;    mp :=amax*amax;    for i := s + 1 to N do begin        readln(a_);        if a[1] < ma then ma := a[1];        if (a[1] mod 2 = 0) and (a[1] < me) then me := a[1];        if a_ mod 2 = 0 then p := a_ * ma        else if me < amax then p := a_ * me        else p := amax* amax;        if (p < mp) then mp := p;        {сдвигаем элементы вспомогательного массива влево}        for j := 1 to s − 1 do            a[j] := a[j + 1];        a[s] := a_    end;    if mp = amax*amax then mp := −1;    writeln(mp) end. Приводим решение Х. Котова на Python 3.n = int(input())left = int(input())answer=100000001a = [int(input()) for i in range(14)]for с in range(n - 15):    right = int(input())    if left%2==0 or right%2==0 and left*right < answer:      answer=left*rightif a[0] < left:  left=a[0]a.pop(0)a.append(right)if answer==100000001:  answer=-1print(answer)",
            "parsed": "2019-04-29 21:13:22.039668",
            "question": "Датчик передаёт каждую секунду по каналу связи неотрицательное целое число, не превосходящее 1000 — текущий результат измерений. Временем, в течение которого происходит передача, можно пренебречь.Необходимо найти в заданной серии показаний датчика минимальное чётное произведение двух показаний, между моментами передачи которых прошло не менее 15 секунд. Если получить такое произведение не удаётся, ответ считается равным -1. Общее количество показаний датчика в серии не превышает 10 000. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество показаний датчика. Гарантируется, что N > 15. В каждой из следующих N строк задаётся одно неотрицательное целое число — очередное показание прибора. Пример входных данных:175\t 4 3 2 16\t7\t8\t9\t10\t 110 120 130 140 150 160 50 Программа должна вывести одно число — описанное в условии произведение, либо −1, если получить такое произведение не удаётся.Пример выходных данных для приведённого выше примера входных данных:200",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body935430\" width=\"100%\"><p class=\"left_margin\">Датчик передаёт каждую секунду по каналу связи неотрицательное целое число, не превосходящее 1000 — текущий результат измерений. Временем, в течение которого происходит передача, можно пренебречь.<p class=\"left_margin\">Необходимо найти в заданной серии показаний датчика минимальное чётное произведение двух показаний, между моментами передачи которых прошло не менее 15 секунд. Если получить такое произведение не удаётся, ответ считается равным -1. Общее количество показаний датчика в серии не превышает 10 000.<p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество показаний датчика. Гарантируется, что N &gt; 15. В каждой из следующих N строк задаётся одно неотрицательное целое число — очередное показание прибора.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">17<p class=\"left_margin\">5\t <p class=\"left_margin\">4 <p class=\"left_margin\">3 <p class=\"left_margin\">2 <p class=\"left_margin\">1<p class=\"left_margin\">6\t<p class=\"left_margin\">7\t<p class=\"left_margin\">8\t<p class=\"left_margin\">9\t<p class=\"left_margin\">10\t <p class=\"left_margin\">110 <p class=\"left_margin\">120 <p class=\"left_margin\">130 <p class=\"left_margin\">140 <p class=\"left_margin\">150 <p class=\"left_margin\">160 <p class=\"left_margin\">50<p> </p><p class=\"left_margin\">Программа должна вывести одно число — описанное в условии произведение, либо −1, если получить такое произведение не удаётся.<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">200<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание А. Ниже приводится пример переборного решения на Паскале, не эффективного ни по памяти, ни по времени, но являющимся правильным ответом на задание А.Программа 1.  const s = 15; {требуемое расстояние между показаниями} var    N: integer;    a: array[1..10000] of integer; {все показания датчика}    mp: integer; {минимальное значение произведения}    i, j: integer; begin    readln(N);    {Ввод значений датчика}    for i:=1 to N do        readln(a[i]);    mp := 1000 * 1000 + 1;    for i := 1 to N − s do begin        for j := i + s to N do begin            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] < mp)                then mp := a[i]*a[j]        end;    end;    if mp = 1000 * 1000 + 1 then mp := −1;    writeln(mp) end.Задание Б. Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. Для каждого показания с номером k, начиная с k = 16, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 15. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 15 элементов ранее, и выбрать минимальное из всех таких произведений.Ниже приводится пример такой программы на Паскале, эффективной по памяти и по времени.Программа 2. const s = 15; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N: integer;    a: array[1..s] of integer; {хранение s показаний датчика}    a_: integer; {ввод очередного показания}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения}    p: integer;    i, j: integer; begin    readln(N);    {Ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {Ввод остальных значений, поиск минимального произведения}    ma := amax; me := amax;    mp :=amax*amax;    for i := s + 1 to N do begin        readln(a_);        if a[1] < ma then ma := a[1];        if (a[1] mod 2 = 0) and (a[1] < me) then me := a[1];        if a_ mod 2 = 0 then p := a_ * ma        else if me < amax then p := a_ * me        else p := amax* amax;        if (p < mp) then mp := p;        {сдвигаем элементы вспомогательного массива влево}        for j := 1 to s − 1 do            a[j] := a[j + 1];        a[s] := a_    end;    if mp = amax*amax then mp := −1;    writeln(mp) end. Приводим решение Х. Котова на Python 3.n = int(input())left = int(input())answer=100000001a = [int(input()) for i in range(14)]for с in range(n - 15):    right = int(input())    if left%2==0 or right%2==0 and left*right < answer:      answer=left*rightif a[0] < left:  left=a[0]a.pop(0)a.append(right)if answer==100000001:  answer=-1print(answer)",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol10490\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание А. <p class=\"left_margin\">Ниже приводится пример переборного решения на Паскале, не эффективного ни по памяти, ни по времени, но являющимся правильным ответом на задание А.<p class=\"left_margin\">Программа 1. <p><div class=\"source_code lang_pascal\"><p> const s = 15; {требуемое расстояние между показаниями}<p> var<p>    N: integer;<p>    a: array[1..10000] of integer; {все показания датчика}<p>    mp: integer; {минимальное значение произведения}<p>    i, j: integer;<p> begin<p>    readln(N);<p>    {Ввод значений датчика}<p>    for i:=1 to N do<p>        readln(a[i]);<p>    mp := 1000 * 1000 + 1;<p>    for i := 1 to N − s do begin<p>        for j := i + s to N do begin<p>            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] &lt; mp)<p>                then mp := a[i]*a[j]<p>        end;<p>    end;<p>    if mp = 1000 * 1000 + 1 then mp := −1;<p>    writeln(mp)<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p class=\"left_margin\">Задание Б. Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. <p class=\"left_margin\">Для каждого показания с номером k, начиная с k = 16, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 15. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. <p class=\"left_margin\">Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 15 элементов ранее, и выбрать минимальное из всех таких произведений.<p class=\"left_margin\">Ниже приводится пример такой программы на Паскале, эффективной по памяти и по времени.<p class=\"left_margin\">Программа 2.<p><div class=\"source_code lang_pascal\"><p> const s = 15; {требуемое расстояние между показаниями}<p>        amax = 1001; {больше максимально возможного показания}<p> var<p>    N: integer;<p>    a: array[1..s] of integer; {хранение s показаний датчика}<p>    a_: integer; {ввод очередного показания}<p>    ma: integer; {минимальное число без s последних}<p>    me: integer; {минимальное чётное число без s последних}<p>    mp: integer; {минимальное значение произведения}<p>    p: integer;<p>    i, j: integer;<p> begin<p>    readln(N);<p>    {Ввод первых s чисел}<p>    for i:=1 to s do readln(a[i]);<p>    {Ввод остальных значений, поиск минимального произведения}<p>    ma := amax; me := amax;<p>    mp :=amax*amax;<p>    for i := s + 1 to N do begin<p>        readln(a_);<p>        if a[1] &lt; ma then ma := a[1];<p>        if (a[1] mod 2 = 0) and (a[1] &lt; me) then me := a[1];<p>        if a_ mod 2 = 0 then p := a_ * ma<p>        else if me &lt; amax then p := a_ * me<p>        else p := amax* amax;<p>        if (p &lt; mp) then mp := p;<p>        {сдвигаем элементы вспомогательного массива влево}<p>        for j := 1 to s − 1 do<p>            a[j] := a[j + 1];<p>        a[s] := a_<p>    end;<p>    if mp = amax*amax then mp := −1;<p>    writeln(mp)<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Приводим решение Х. Котова на Python 3.</b><p><div class=\"source_code lang_python\"><p>n = int(input())<p>left = int(input())<p>answer=100000001<p>a = [int(input()) for i in range(14)]<p>for с in range(n - 15):<p>    right = int(input())<p>    if left%2==0 or right%2==0 and left*right &lt; answer:<p>      answer=left*right<p>if a[0] &lt; left:<p>  left=a[0]<p>a.pop(0)<p>a.append(right)<p>if answer==100000001:<p>  answer=-1<p>print(answer)<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "10490"
        },
        {
            "answer": "Решение.Чтобы треугольник не пересекался с осью Ox и пересекался с осью Oy, его вершины должны лежать в одной полуплоскости относительно Ox и в разных относительно Oy. Получается, что вершины треугольника должны лежать в первой и второй либо в третьей и четвёртой четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит n1 точек, а во второй — n2 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна – во второй, равно (n1(n1–1)/2) * n2 = n1(n1–1)n2/2.Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (n1(n1–1)n2 + n2(n2–1)n1 + n3(n3–1)n4 + n4(n4–1)n3) / 2. Пример правильной и эффективной программы на языке Паскальprogram P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество треугольников}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := (n1*n2*(n1+n2-2) + n3*n4*(n3+n4-2)) div 2;  writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль. var  N: integer; {количество точек}  a: array[1..10000, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  s: integer; {количество треугольников}  i, j, k: integer;begin  readln(N);  s := 0;  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := i+1 to N do      for k := j+1 to N do begin        if (a[k, 2]<0) and (a[j, 2]<0) and (a[i, 2]<0) then begin          if ((a[k, 1]<0) and (a[j, 1]>0)) or ((a[k, 1]<0) and (a[i, 1]>0)) or ((a[k, 1]<0) and (a[j, 1]>0)) then            s := s + 1;          if ((a[k, 1]>0) and (a[j, 1]<0)) or ((a[k, 1]>0) and (a[i, 1]<0)) or ((a[k, 1]>0) and (a[j, 1]<0)) then            s := s + 1;        end;        if (a[k, 2]>0) and (a[j, 2]>0) and (a[i, 2]>0) then begin          if ((a[k, 1]<0) and (a[j, 1]>0)) or ((a[k, 1]<0) and (a[i, 1]>0)) or ((a[k, 1]<0) and (a[j, 1]>0)) then            s := s + 1;          if ((a[k, 1]>0) and (a[j, 1]<0)) or ((a[k, 1]>0) and (a[i, 1]<0)) or ((a[k, 1]>0) and (a[j, 1]<0)) then            s := s + 1;        end;     end;  writeln(s);end.",
            "parsed": "2019-04-29 21:13:22.556778",
            "question": "На плоскости задано множество точек с целочисленными координатами, никакие две из которых не совпадают и никакие три не лежат на одной прямой. Необходимо найти количество треугольников, обладающих следующими свойствами: 1) все вершины треугольника принадлежат заданному множеству;2) ни одна вершина не лежит на осях координат;3) треугольник не пересекается с осью Ox, но пересекается с осью Oy. Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа x и y – координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000, –1000 ≤ x, y ≤ 1000, никакие две точки не совпадают, никакие три не лежат на одной прямой. Пример входных данных:46 6−8 8−9 −97 5 Выходные данныеНеобходимо вывести единственное число: количество удовлетворяющих требованиям треугольников. Пример выходных данных для приведённого выше примера входных данных:1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body935172\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами, никакие две из которых не совпадают и никакие три не лежат на одной прямой. Необходимо найти количество треугольников, обладающих следующими свойствами:<p> </p><p class=\"left_margin\">1) все вершины треугольника принадлежат заданному множеству;<p class=\"left_margin\">2) ни одна вершина не лежит на осях координат;<p class=\"left_margin\">3) треугольник не пересекается с осью Ox, но пересекается с осью Oy.<p> </p><p class=\"left_margin\">Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p><b><p class=\"left_margin\">Входные данные</p></b><p class=\"left_margin\">В первой строке задаётся N – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа x и y – координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000, –1000 ≤ x, y ≤ 1000, никакие две точки не совпадают, никакие три не лежат на одной прямой.<p> </p><p><i><p class=\"left_margin\">Пример входных данных</p></i>:<p class=\"left_margin\">4<p class=\"left_margin\">6 6<p class=\"left_margin\">−8 8<p class=\"left_margin\">−9 −9<p class=\"left_margin\">7 5<p> </p><p><b><p class=\"left_margin\">Выходные данные</p></b><p class=\"left_margin\">Необходимо вывести единственное число: количество удовлетворяющих требованиям треугольников.<p> </p><p><i><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных</p></i>:<p class=\"left_margin\">1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы треугольник не пересекался с осью Ox и пересекался с осью Oy, его вершины должны лежать в одной полуплоскости относительно Ox и в разных относительно Oy. Получается, что вершины треугольника должны лежать в первой и второй либо в третьей и четвёртой четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит n1 точек, а во второй — n2 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна – во второй, равно (n1(n1–1)/2) * n2 = n1(n1–1)n2/2.Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (n1(n1–1)n2 + n2(n2–1)n1 + n3(n3–1)n4 + n4(n4–1)n3) / 2. Пример правильной и эффективной программы на языке Паскальprogram P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество треугольников}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := (n1*n2*(n1+n2-2) + n3*n4*(n3+n4-2)) div 2;  writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль. var  N: integer; {количество точек}  a: array[1..10000, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  s: integer; {количество треугольников}  i, j, k: integer;begin  readln(N);  s := 0;  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := i+1 to N do      for k := j+1 to N do begin        if (a[k, 2]<0) and (a[j, 2]<0) and (a[i, 2]<0) then begin          if ((a[k, 1]<0) and (a[j, 1]>0)) or ((a[k, 1]<0) and (a[i, 1]>0)) or ((a[k, 1]<0) and (a[j, 1]>0)) then            s := s + 1;          if ((a[k, 1]>0) and (a[j, 1]<0)) or ((a[k, 1]>0) and (a[i, 1]<0)) or ((a[k, 1]>0) and (a[j, 1]<0)) then            s := s + 1;        end;        if (a[k, 2]>0) and (a[j, 2]>0) and (a[i, 2]>0) then begin          if ((a[k, 1]<0) and (a[j, 1]>0)) or ((a[k, 1]<0) and (a[i, 1]>0)) or ((a[k, 1]<0) and (a[j, 1]>0)) then            s := s + 1;          if ((a[k, 1]>0) and (a[j, 1]<0)) or ((a[k, 1]>0) and (a[i, 1]<0)) or ((a[k, 1]>0) and (a[j, 1]<0)) then            s := s + 1;        end;     end;  writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11256\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы треугольник не пересекался с осью <i>Ox</i> и пересекался с осью <i>Oy</i>, его вершины должны лежать в одной полуплоскости относительно <i>Ox</i> и в разных относительно <i>Oy</i>. Получается, что вершины треугольника должны лежать в первой и второй либо в третьей и четвёртой четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.<p class=\"left_margin\">Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит <i>n</i>1 точек, а во второй — <i>n</i>2 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна – во второй, равно (<i>n</i>1(<i>n</i>1–1)/2) * <i>n</i>2 = <i>n</i>1(<i>n</i>1–1)<i>n</i>2/2.<p class=\"left_margin\">Если известны величины <i>n</i>1, <i>n</i>2, <i>n</i>3, <i>n</i>4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (<i>n</i>1(<i>n</i>1–1)<i>n</i>2 + <i>n</i>2(<i>n</i>2–1)<i>n</i>1 + <i>n</i>3(<i>n</i>3–1)<i>n</i>4 + <i>n</i>4(<i>n</i>4–1)<i>n</i>3) / 2.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p><div class=\"source_code lang_alg\"><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    n1, n2, n3, n4: integer;<p>      {количество точек по четвертям}<p>    s: integer; {количество треугольников}<p>    i: integer;<p>begin<p>  readln(N);<p>  n1:=0; n2:=0; n3:=0; n4:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x&gt;0) and (y&gt;0) then n1 := n1+1;<p>    if (x&lt;0) and (y&gt;0) then n2 := n2+1;<p>    if (x&lt;0) and (y&lt;0) then n3 := n3+1;<p>    if (x&gt;0) and (y&lt;0) then n4 := n4+1;<p>  end;<p>  s := (n1*n2*(n1+n2-2) + n3*n4*(n3+n4-2)) div 2;<p>  writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль.</b><p> </p><pre><div class=\"source_code lang_alg\">var<p>  N: integer; {количество точек}<p>  a: array[1..10000, 1..2] of integer; {исходные данные}<p>  x, y: integer; {координаты очередной точки}<p>  s: integer; {количество треугольников}<p>  i, j, k: integer;<p>begin<p>  readln(N);<p>  s := 0;<p>  for i := 1 to N do read(a[i, 1], a[i, 2]);<p>  for i := 1 to N do<p>    for j := i+1 to N do<p>      for k := j+1 to N do begin<p>        if (a[k, 2]&lt;0) and (a[j, 2]&lt;0) and (a[i, 2]&lt;0) then begin<p>          if ((a[k, 1]&lt;0) and (a[j, 1]&gt;0)) or ((a[k, 1]&lt;0) and (a[i, 1]&gt;0)) or ((a[k, 1]&lt;0) and (a[j, 1]&gt;0)) then<p>            s := s + 1;<p>          if ((a[k, 1]&gt;0) and (a[j, 1]&lt;0)) or ((a[k, 1]&gt;0) and (a[i, 1]&lt;0)) or ((a[k, 1]&gt;0) and (a[j, 1]&lt;0)) then<p>            s := s + 1;<p>        end;<p>        if (a[k, 2]&gt;0) and (a[j, 2]&gt;0) and (a[i, 2]&gt;0) then begin<p>          if ((a[k, 1]&lt;0) and (a[j, 1]&gt;0)) or ((a[k, 1]&lt;0) and (a[i, 1]&gt;0)) or ((a[k, 1]&lt;0) and (a[j, 1]&gt;0)) then<p>            s := s + 1;<p>          if ((a[k, 1]&gt;0) and (a[j, 1]&lt;0)) or ((a[k, 1]&gt;0) and (a[i, 1]&lt;0)) or ((a[k, 1]&gt;0) and (a[j, 1]&lt;0)) then<p>            s := s + 1;<p>        end;<p>     end;<p>  writeln(s);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "11256"
        },
        {
            "answer": "Решение.Чтобы треугольник не пересекался с осью Oy и пересекался с осью Ox, его вершины должны лежать в одной полуплоскости относительно Oy и в разных относительно Ox. Получается, что вершины треугольника должны лежатьв первой и четвёртой либо во второй и третьей четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит n1 точек, а в четвёртой – n4 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна — в четвёртой, равно (n1(n1–1)/2) * n4 = n1(n1–1)n4/2.Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (n1(n1-1)n4 + n4(n4-1)n1 + n2(n2-1)n3 + n3(n3-1)n2) / 2. Пример правильной и эффективной программы на языке Паскальprogram P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество треугольников}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := (n1*n4*(n1+n4-2) + n2*n3*(n2+n3-2)) div 2;  writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль. begin  readln(N);  s := 0;  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := i+1 to N do      for k := j+1 to N do        if (a[k, 1]<0) and (a[j, 1]<0) and (a[i, 1]<0) then begin          if ((a[k, 2]<0) and (a[j, 2]>0)) or ((a[k, 2]<0) and (a[i, 2]>0)) or ((a[k, 2]<0) and (a[j, 2]>0)) then            s := s + 1;          if ((a[k, 2]>0) and (a[j, 2]<0)) or ((a[k, 2]>0) and (a[i, 2]<0)) or ((a[k, 2]>0) and (a[j, 2]<0)) then            s := s + 1;        end;        if (a[k, 1]>0) and (a[j, 1]>0) and (a[i, 1]>0) then begin          if ((a[k, 2]<0) and (a[j, 2]>0)) or ((a[k, 2]<0) and (a[i, 2]>0)) or ((a[k, 2]<0) and (a[j, 2]>0)) then            s := s + 1;          if ((a[k, 2]>0) and (a[j, 2]<0)) or ((a[k, 2]>0) and (a[i, 2]<0)) or ((a[k, 2]>0) and (a[j, 2]<0)) then            s := s + 1;        end;  writeln(s);end.",
            "parsed": "2019-04-29 21:13:23.007636",
            "question": "На плоскости задано множество точек с целочисленными координатами, никакие две из которых не совпадают и никакие три не лежат на одной прямой. Необходимо найти количество треугольников, обладающих следующими свойствами: 1) все вершины треугольника принадлежат заданному множеству;2) ни одна вершина не лежит на осях координат;3) треугольник не пересекается с осью Oy, но пересекается с осью Ox. Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа x и y – координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000, –1000 ≤ x, y ≤ 1000, никакие две точки не совпадают, никакие три не лежат на одной прямой. Пример входных данных:46 6−8 8−9 −9−7 5 Выходные данныеНеобходимо вывести единственное число: количество удовлетворяющих требованиям треугольников. Пример выходных данных для приведённого выше примера входных данных:1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body934639\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами, никакие две из которых не совпадают и никакие три не лежат на одной прямой. Необходимо найти количество треугольников, обладающих следующими свойствами:<p> </p><p class=\"left_margin\">1) все вершины треугольника принадлежат заданному множеству;<p class=\"left_margin\">2) ни одна вершина не лежит на осях координат;<p class=\"left_margin\">3) треугольник не пересекается с осью Oy, но пересекается с осью Ox.<p> </p><p class=\"left_margin\">Напишите эффективную по времени и по используемой памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества точек в k раз время работы возрастает не более чем в k раз. Программа считается эффективной по памяти, если размер памяти для хранения всех необходимых данных не зависит от количества точек и не превышает 1 килобайта.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p><b><p class=\"left_margin\">Входные данные</p></b><p class=\"left_margin\">В первой строке задаётся N – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа x и y – координаты очередной точки. Гарантируется, что 1 ≤ N ≤ 10000, –1000 ≤ x, y ≤ 1000, никакие две точки не совпадают, никакие три не лежат на одной прямой.<p> </p><p><i><p class=\"left_margin\">Пример входных данных</p></i>:<p class=\"left_margin\">4<p class=\"left_margin\">6 6<p class=\"left_margin\">−8 8<p class=\"left_margin\">−9 −9<p class=\"left_margin\">−7 5<p> </p><p><b><p class=\"left_margin\">Выходные данные</p></b><p class=\"left_margin\">Необходимо вывести единственное число: количество удовлетворяющих требованиям треугольников.<p> </p><p><i><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных</p></i>:<p class=\"left_margin\">1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы треугольник не пересекался с осью Oy и пересекался с осью Ox, его вершины должны лежать в одной полуплоскости относительно Oy и в разных относительно Ox. Получается, что вершины треугольника должны лежатьв первой и четвёртой либо во второй и третьей четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит n1 точек, а в четвёртой – n4 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна — в четвёртой, равно (n1(n1–1)/2) * n4 = n1(n1–1)n4/2.Если известны величины n1, n2, n3, n4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (n1(n1-1)n4 + n4(n4-1)n1 + n2(n2-1)n3 + n3(n3-1)n2) / 2. Пример правильной и эффективной программы на языке Паскальprogram P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    n1, n2, n3, n4: integer;      {количество точек по четвертям}    s: integer; {количество треугольников}    i: integer;begin  readln(N);  n1:=0; n2:=0; n3:=0; n4:=0;  for i:=1 to N do begin    readln(x,y);    if (x>0) and (y>0) then n1 := n1+1;    if (x<0) and (y>0) then n2 := n2+1;    if (x<0) and (y<0) then n3 := n3+1;    if (x>0) and (y<0) then n4 := n4+1;  end;  s := (n1*n4*(n1+n4-2) + n2*n3*(n2+n3-2)) div 2;  writeln(s)end. Пример правильной, но неэффективной программы на языке Паскаль. begin  readln(N);  s := 0;  for i := 1 to N do read(a[i, 1], a[i, 2]);  for i := 1 to N do    for j := i+1 to N do      for k := j+1 to N do        if (a[k, 1]<0) and (a[j, 1]<0) and (a[i, 1]<0) then begin          if ((a[k, 2]<0) and (a[j, 2]>0)) or ((a[k, 2]<0) and (a[i, 2]>0)) or ((a[k, 2]<0) and (a[j, 2]>0)) then            s := s + 1;          if ((a[k, 2]>0) and (a[j, 2]<0)) or ((a[k, 2]>0) and (a[i, 2]<0)) or ((a[k, 2]>0) and (a[j, 2]<0)) then            s := s + 1;        end;        if (a[k, 1]>0) and (a[j, 1]>0) and (a[i, 1]>0) then begin          if ((a[k, 2]<0) and (a[j, 2]>0)) or ((a[k, 2]<0) and (a[i, 2]>0)) or ((a[k, 2]<0) and (a[j, 2]>0)) then            s := s + 1;          if ((a[k, 2]>0) and (a[j, 2]<0)) or ((a[k, 2]>0) and (a[i, 2]<0)) or ((a[k, 2]>0) and (a[j, 2]<0)) then            s := s + 1;        end;  writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11283\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы треугольник не пересекался с осью <i>Oy</i> и пересекался с осью <i>Ox</i>, его вершины должны лежать в одной полуплоскости относительно <i>Oy</i> и в разных относительно <i>Ox</i>. Получается, что вершины треугольника должны лежать<p>в первой и четвёртой либо во второй и третьей четвертях, причём в одной из этих четвертей должны лежать две вершины, в другой — одна.<p class=\"left_margin\">Зная количество точек в каждой четверти, можно подсчитать количество искомых треугольников. Например, если в первой четверти лежит <i>n</i>1 точек, а в четвёртой – <i>n</i>4 точек, то количество треугольников, у которых две вершины лежат в первой четверти, а одна — в четвёртой, равно (<i>n</i>1(<i>n</i>1–1)/2) * <i>n</i>4 = <i>n</i>1(<i>n</i>1–1)<i>n</i>4/2.<p class=\"left_margin\">Если известны величины <i>n</i>1, <i>n</i>2, <i>n</i>3, <i>n</i>4, показывающие количество точек в каждой четверти, то общее количество треугольников равно (<i>n</i>1(<i>n</i>1-1)<i>n</i>4 + <i>n</i>4(<i>n</i>4-1)<i>n</i>1 + <i>n</i>2(<i>n</i>2-1)<i>n</i>3 + <i>n</i>3(<i>n</i>3-1)<i>n</i>2) / 2.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p><div class=\"source_code lang_alg\"><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    n1, n2, n3, n4: integer;<p>      {количество точек по четвертям}<p>    s: integer; {количество треугольников}<p>    i: integer;<p>begin<p>  readln(N);<p>  n1:=0; n2:=0; n3:=0; n4:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x&gt;0) and (y&gt;0) then n1 := n1+1;<p>    if (x&lt;0) and (y&gt;0) then n2 := n2+1;<p>    if (x&lt;0) and (y&lt;0) then n3 := n3+1;<p>    if (x&gt;0) and (y&lt;0) then n4 := n4+1;<p>  end;<p>  s := (n1*n4*(n1+n4-2) + n2*n3*(n2+n3-2)) div 2;<p>  writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль.</b><p> </p><pre><div class=\"source_code lang_alg\">begin<p>  readln(N);<p>  s := 0;<p>  for i := 1 to N do read(a[i, 1], a[i, 2]);<p>  for i := 1 to N do<p>    for j := i+1 to N do<p>      for k := j+1 to N do<p>        if (a[k, 1]&lt;0) and (a[j, 1]&lt;0) and (a[i, 1]&lt;0) then begin<p>          if ((a[k, 2]&lt;0) and (a[j, 2]&gt;0)) or ((a[k, 2]&lt;0) and (a[i, 2]&gt;0)) or ((a[k, 2]&lt;0) and (a[j, 2]&gt;0)) then<p>            s := s + 1;<p>          if ((a[k, 2]&gt;0) and (a[j, 2]&lt;0)) or ((a[k, 2]&gt;0) and (a[i, 2]&lt;0)) or ((a[k, 2]&gt;0) and (a[j, 2]&lt;0)) then<p>            s := s + 1;<p>        end;<p>        if (a[k, 1]&gt;0) and (a[j, 1]&gt;0) and (a[i, 1]&gt;0) then begin<p>          if ((a[k, 2]&lt;0) and (a[j, 2]&gt;0)) or ((a[k, 2]&lt;0) and (a[i, 2]&gt;0)) or ((a[k, 2]&lt;0) and (a[j, 2]&gt;0)) then<p>            s := s + 1;<p>          if ((a[k, 2]&gt;0) and (a[j, 2]&lt;0)) or ((a[k, 2]&gt;0) and (a[i, 2]&lt;0)) or ((a[k, 2]&gt;0) and (a[j, 2]&lt;0)) then<p>            s := s + 1;<p>        end;<p>  writeln(s);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "11283"
        },
        {
            "answer": "Решение.Задание А.Пример программы написанной на Python 3.3.a=[]sum=600001for i in range(6):   a.append(list(map(int, input().split())))for i in range (2):   for j in range (2):      for k in range (2):         for l in range (2):            for m in range (2):               for n in range (2):                  if a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n] <                   sum and (a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n])%6!=0:                  sum=a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n]if sum==600001:   print(0)else:   print(sum)  Задание А.Пример программы написанной на Паскаль ABC.var  a: array[1..6, 1..2] of integer; {исходные данные}  sum: integer; {минимальная сумма}  i, j, k, l, m, n: integer;begin  sum := 600001;  for i := 1 to 6 do read(a[i,1], a[i, 2]);  for i := 1 to 2 do    for j := 1 to 2 do      for k := 1 to 2 do        for l := 1 to 2 do          for m := 1 to 2 do            for n := 1 to 2 do              if (a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n] < sum) and               ((a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n])<>0) then                sum := a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n];  if sum = 600001 then    writeln(0)  else writeln(sum);end. Задание Б.Выберем из каждой пары минимальное число и сложим эти числа: данная сумма будет минимальной возможной. Если она не будет кратна 6, то это и есть требуемая сумма и её надо вывести. Иначе из какой-то пары придётся взять не минимальное, а максимальное число. Найдём минимальную разность между числами одной пары, не кратную 6. Если такая существует, то, сложив её с минимальной суммой, получим минимально возможную сумму не кратную 6, а если её нет (то есть между числами пары пары разность всегда кратна 6), то любая сумма будет кратна 6, и мы выведем 0.Пример программы написанной на PascalABC.NETvar   i, n, x, y, sum, min_r: longint;begin   readln(n);   min_r:=30001;   sum:=0;   for i:=1 to n do   begin      read(x);      read(y);      if  x < y then sum:=sum+x else sum:= sum + y;      if (abs(x - y) mod 6 <> 0) and (abs(x - y) < min_r) then min_r:= abs(x - y);   end;   if sum mod 6 <> 0 then writeln(sum)   else if (sum mod 6 = 0) and (min_r < 30001) then writeln (sum + min_r)   else writeln(0);end.",
            "parsed": "2019-04-29 21:13:23.343142",
            "question": "На вход даны пары чисел. Нужно выбрать из каждой пары по одному числу так, чтобы сумма всех выбранных чисел не была кратна 6 и при этом была минимально возможной. Напишите программу, выводящую такую сумму на экран. Если же ее невозможно получить, выведите 0.  Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Задача А. Количество пар известно заранее и равно 6. Числа не превышают 30 000.Пример входных данных:5 43 21 118 311 122 5Пример выходных данных:23 Задача Б. Количество пар N не известно заранее и может принимать значения 2 <= N <= 200 000. На вход подается сначала количество пар, затем сами пары. Числа по модулю не превышают 30 000.Пример входных данных:65 43 21 118 311 122 5Пример выходных данных:23",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body934599\" width=\"100%\"><p class=\"left_margin\">На вход даны пары чисел. Нужно выбрать из каждой пары по одному числу так, чтобы сумма всех выбранных чисел не была кратна 6 и при этом была минимально возможной. Напишите программу, выводящую такую сумму на экран. Если же ее невозможно получить, выведите 0. <p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p class=\"left_margin\">Задача А. Количество пар известно заранее и равно 6. Числа не превышают 30 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5 4<p class=\"left_margin\">3 2<p class=\"left_margin\">1 1<p class=\"left_margin\">18 3<p class=\"left_margin\">11 12<p class=\"left_margin\">2 5<p class=\"left_margin\">Пример выходных данных:<p class=\"left_margin\">23<p> </p><p class=\"left_margin\">Задача Б. Количество пар N не известно заранее и может принимать значения 2 &lt;= N &lt;= 200 000. На вход подается сначала количество пар, затем сами пары. Числа по модулю не превышают 30 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">6<p class=\"left_margin\">5 4<p class=\"left_margin\">3 2<p class=\"left_margin\">1 1<p class=\"left_margin\">18 3<p class=\"left_margin\">11 12<p class=\"left_margin\">2 5<p class=\"left_margin\">Пример выходных данных:<p class=\"left_margin\">23</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание А.Пример программы написанной на Python 3.3.a=[]sum=600001for i in range(6):   a.append(list(map(int, input().split())))for i in range (2):   for j in range (2):      for k in range (2):         for l in range (2):            for m in range (2):               for n in range (2):                  if a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n] <                   sum and (a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n])%6!=0:                  sum=a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n]if sum==600001:   print(0)else:   print(sum)  Задание А.Пример программы написанной на Паскаль ABC.var  a: array[1..6, 1..2] of integer; {исходные данные}  sum: integer; {минимальная сумма}  i, j, k, l, m, n: integer;begin  sum := 600001;  for i := 1 to 6 do read(a[i,1], a[i, 2]);  for i := 1 to 2 do    for j := 1 to 2 do      for k := 1 to 2 do        for l := 1 to 2 do          for m := 1 to 2 do            for n := 1 to 2 do              if (a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n] < sum) and               ((a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n])<>0) then                sum := a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n];  if sum = 600001 then    writeln(0)  else writeln(sum);end. Задание Б.Выберем из каждой пары минимальное число и сложим эти числа: данная сумма будет минимальной возможной. Если она не будет кратна 6, то это и есть требуемая сумма и её надо вывести. Иначе из какой-то пары придётся взять не минимальное, а максимальное число. Найдём минимальную разность между числами одной пары, не кратную 6. Если такая существует, то, сложив её с минимальной суммой, получим минимально возможную сумму не кратную 6, а если её нет (то есть между числами пары пары разность всегда кратна 6), то любая сумма будет кратна 6, и мы выведем 0.Пример программы написанной на PascalABC.NETvar   i, n, x, y, sum, min_r: longint;begin   readln(n);   min_r:=30001;   sum:=0;   for i:=1 to n do   begin      read(x);      read(y);      if  x < y then sum:=sum+x else sum:= sum + y;      if (abs(x - y) mod 6 <> 0) and (abs(x - y) < min_r) then min_r:= abs(x - y);   end;   if sum mod 6 <> 0 then writeln(sum)   else if (sum mod 6 = 0) and (min_r < 30001) then writeln (sum + min_r)   else writeln(0);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11323\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание А.<p class=\"left_margin\">Пример программы написанной на Python 3.3.<p><tt><div class=\"source_code lang_python\"><p>a=[]<p>sum=600001<p>for i in range(6):<p>   a.append(list(map(int, input().split())))<p>for i in range (2):<p>   for j in range (2):<p>      for k in range (2):<p>         for l in range (2):<p>            for m in range (2):<p>               for n in range (2):<p>                  if a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n] &lt; <p>                  sum and (a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n])%6!=0:<p>                  sum=a[1][i]+a[2][j]+a[3][k]+a[4][l]+a[5][m]+a[0][n]<p>if sum==600001:<p>   print(0)<p>else:<p>   print(sum)<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></tt><p> </p><p> </p><p class=\"left_margin\">Задание А.<p class=\"left_margin\">Пример программы написанной на Паскаль ABC.<pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..6, 1..2] of integer; {исходные данные}<p>  sum: integer; {минимальная сумма}<p>  i, j, k, l, m, n: integer;<p>begin<p>  sum := 600001;<p>  for i := 1 to 6 do read(a[i,1], a[i, 2]);<p>  for i := 1 to 2 do<p>    for j := 1 to 2 do<p>      for k := 1 to 2 do<p>        for l := 1 to 2 do<p>          for m := 1 to 2 do<p>            for n := 1 to 2 do<p>              if (a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n] &lt; sum) and <p>              ((a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n])&lt;&gt;0) then<p>                sum := a[1, i] + a[2, j] + a[3, k] + a[4, l] + a[5, m] + a[6, n];<p>  if sum = 600001 then<p>    writeln(0)<p>  else writeln(sum);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre><p> </p><p class=\"left_margin\">Задание Б.<p class=\"left_margin\">Выберем из каждой пары минимальное число и сложим эти числа: данная сумма будет минимальной возможной. Если она не будет кратна 6, то это и есть требуемая сумма и её надо вывести. Иначе из какой-то пары придётся взять не минимальное, а максимальное число. Найдём минимальную разность между числами одной пары, не кратную 6. Если такая существует, то, сложив её с минимальной суммой, получим минимально возможную сумму не кратную 6, а если её нет (то есть между числами пары пары разность всегда кратна 6), то любая сумма будет кратна 6, и мы выведем 0.<p class=\"left_margin\">Пример программы написанной на PascalABC.NET<p><tt><div class=\"source_code lang_pascal\"><p>var<p>   i, n, x, y, sum, min_r: longint;<p>begin<p>   readln(n);<p>   min_r:=30001;<p>   sum:=0;<p>   for i:=1 to n do<p>   begin<p>      read(x);<p>      read(y);<p>      if  x &lt; y then sum:=sum+x else sum:= sum + y;<p>      if (abs(x - y) mod 6 &lt;&gt; 0) and (abs(x - y) &lt; min_r) then min_r:= abs(x - y);<p>   end;<p>   if sum mod 6 &lt;&gt; 0 then writeln(sum)<p>   else if (sum mod 6 = 0) and (min_r &lt; 30001) then writeln (sum + min_r)<p>   else writeln(0);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></tt></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ 16.06.2016 по информатике. Основная волна. Вариант 41 (Часть С)",
            "task_id": "11323"
        },
        {
            "answer": "Решение.Задание А. Перебираем все 64 возможных варианта и находим подходящее значение или выводим 0. Приведём пример решения на языке PascalABC.NET 1.8var a, b, s: integer;    x: Array [1...12] of integer;begin    for var i:= 1 to 12 do        read (x[i]);    for var i:= 1 to 2 do    begin        for var d:= 3 to 4 do            begin                for var c:= 5 to 6 do                begin                    for var e: = 7 to 8 do                    begin                        for var p:= 9 to 10 do                        begin                            for var q:= 11 to 12 do                            begin                                s:= x[q] + x[p] + x[c] + x[e] + x[d] + x[i];                                if (s > b) and (s mod 2 = 1) then                                    b:= s;                                s:= 0;                            end;                        end;                    end;                end;            end;        end;    writeln(b);end. Задание В.Программа сравнивает два числа в паре и добавляет к сумме наибольшее из чисел. Также сравнивает модуль разности этих двух чисел. Если модуль разности меньше min_r  и нечётный, тогда min_r заменяется на этот модуль разности. В конце если сумма будет чётной, тогда из неё вычтем min_r, если же min_r будет равно 10001, тогда выведем ноль. Задание Б.Приведём пример решения на языке Паскаль:vari, n, x, y, sum, min_r: longint;begin readln(n); min_r:=10001; sum:=0; for i:=1 to n do begin  readln(x,y);  if x > y then sum:=sum + x else sum:= sum + y;  if (abs(x - y) mod 2 = 1) and (abs(x - y) < min_r) then min_r:= abs(x - y); end;  if (sum mod 2 = 1) then writeln(sum) else  if (sum mod 2 = 0) and (min_r <> 10001) then writeln (sum - min_r) else writeln(0); end.",
            "parsed": "2019-04-29 21:13:23.762487",
            "question": "На вход даны пары чисел. Нужно выбрать из каждой пары по одному числу так, чтобы сумма всех выбранных чисел была нечётна и при этом была максимально возможной. Напишите программу, выводящую такую сумму на экран. Если же ее невозможно получить, выведите 0. Каждый элемент в паре целый, неотрицательный.   Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Задача А. Количество пар известно заранее и равно 6. Числа не превышают 100 000. Задача Б. Количество пар N не известно заранее и может принимать значения 2 <= N <= 100 000. На вход подается сначала количество пар, затем сами пары. Числа не превышают 10 000.Пример входных данных:65 43 21 118 311 122 5Пример выходных данных:43",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body934584\" width=\"100%\"><p class=\"left_margin\">На вход даны пары чисел. Нужно выбрать из каждой пары по одному числу так, чтобы сумма всех выбранных чисел была нечётна и при этом была максимально возможной. Напишите программу, выводящую такую сумму на экран. Если же ее невозможно получить, выведите 0. Каждый элемент в паре целый, неотрицательный.  <p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p class=\"left_margin\">Задача А. Количество пар известно заранее и равно 6. Числа не превышают 100 000.<p> </p><p class=\"left_margin\">Задача Б. Количество пар N не известно заранее и может принимать значения 2 &lt;= N &lt;= 100 000. На вход подается сначала количество пар, затем сами пары. Числа не превышают 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">6<p class=\"left_margin\">5 4<p class=\"left_margin\">3 2<p class=\"left_margin\">1 1<p class=\"left_margin\">18 3<p class=\"left_margin\">11 12<p class=\"left_margin\">2 5<p class=\"left_margin\">Пример выходных данных:<p class=\"left_margin\">43</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание А. Перебираем все 64 возможных варианта и находим подходящее значение или выводим 0. Приведём пример решения на языке PascalABC.NET 1.8var a, b, s: integer;    x: Array [1...12] of integer;begin    for var i:= 1 to 12 do        read (x[i]);    for var i:= 1 to 2 do    begin        for var d:= 3 to 4 do            begin                for var c:= 5 to 6 do                begin                    for var e: = 7 to 8 do                    begin                        for var p:= 9 to 10 do                        begin                            for var q:= 11 to 12 do                            begin                                s:= x[q] + x[p] + x[c] + x[e] + x[d] + x[i];                                if (s > b) and (s mod 2 = 1) then                                    b:= s;                                s:= 0;                            end;                        end;                    end;                end;            end;        end;    writeln(b);end. Задание В.Программа сравнивает два числа в паре и добавляет к сумме наибольшее из чисел. Также сравнивает модуль разности этих двух чисел. Если модуль разности меньше min_r  и нечётный, тогда min_r заменяется на этот модуль разности. В конце если сумма будет чётной, тогда из неё вычтем min_r, если же min_r будет равно 10001, тогда выведем ноль. Задание Б.Приведём пример решения на языке Паскаль:vari, n, x, y, sum, min_r: longint;begin readln(n); min_r:=10001; sum:=0; for i:=1 to n do begin  readln(x,y);  if x > y then sum:=sum + x else sum:= sum + y;  if (abs(x - y) mod 2 = 1) and (abs(x - y) < min_r) then min_r:= abs(x - y); end;  if (sum mod 2 = 1) then writeln(sum) else  if (sum mod 2 = 0) and (min_r <> 10001) then writeln (sum - min_r) else writeln(0); end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11332\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание А. <p class=\"left_margin\">Перебираем все 64 возможных варианта и находим подходящее значение или выводим 0.<p> </p><p class=\"left_margin\">Приведём пример решения на языке PascalABC.NET 1.8<p><tt><p>var a, b, s: integer;<p>    x: Array [1...12] of integer;<p>begin<p>    for var i:= 1 to 12 do<p>        read (x[i]);<p>    for var i:= 1 to 2 do<p>    begin<p>        for var d:= 3 to 4 do<p>            begin<p>                for var c:= 5 to 6 do<p>                begin<p>                    for var e: = 7 to 8 do<p>                    begin<p>                        for var p:= 9 to 10 do<p>                        begin<p>                            for var q:= 11 to 12 do<p>                            begin<p>                                s:= x[q] + x[p] + x[c] + x[e] + x[d] + x[i];<p>                                if (s &gt; b) and (s mod 2 = 1) then<p>                                    b:= s;<p>                                s:= 0;<p>                            end;<p>                        end;<p>                    end;<p>                end;<p>            end;<p>        end;<p>    writeln(b);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Задание В.<p class=\"left_margin\">Программа сравнивает два числа в паре и добавляет к сумме наибольшее из чисел. Также сравнивает модуль разности этих двух чисел. Если модуль разности меньше min_r  и нечётный, тогда min_r заменяется на этот модуль разности. В конце если сумма будет чётной, тогда из неё вычтем min_r, если же min_r будет равно 10001, тогда выведем ноль.<p> <p><tt><p class=\"left_margin\">Задание Б.<p class=\"left_margin\">Приведём пример решения на языке Паскаль:<p>var<p>i, n, x, y, sum, min_r: longint;<p>begin<p> readln(n);<p> min_r:=10001;<p> sum:=0;<p> for i:=1 to n do<p> begin<p>  readln(x,y);<p>  if x &gt; y then sum:=sum + x else sum:= sum + y;<p>  if (abs(x - y) mod 2 = 1) and (abs(x - y) &lt; min_r) then min_r:= abs(x - y);<p> end;<p> </p><p> if (sum mod 2 = 1) then writeln(sum) else<p>  if (sum mod 2 = 0) and (min_r &lt;&gt; 10001) then writeln (sum - min_r) else writeln(0);<p> </p><p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ 16.06.2016 по информатике. Основная волна. Вариант 77 (Часть С)",
            "task_id": "11332"
        },
        {
            "answer": "Решение.Задание А.Используемый язык: Dev — C++ #include <iostream>using namespace std;int main () {    int a[10000];    int minb, i, j, N;    cin >> N;    for (i = 0; i < N; i++) // ввод значений в массив        cin >> a[i];    min = 1000*1000 + 1;    for (i = 0; i < N - 6; i++) {    for (j = i + 6; j < N; j++) {  //просмотрим каждую возможность        if (a[i] * a[j] < minb)            minb = a[i] * a[j]; }        }    cout << minb;    return(0);}Задание А.Используемый язык: Паскаль ABC.var  a: array[1..10000] of integer; {исходные данные}  N: integer;  minb: integer; {искомое минимальное произведение пары чисел}  i, j: integer;begin  readln(N);  for i := 1 to N do readln(a[i]);  minb := 1000*1000+1;  for i := 1 to N-6 do    for j := i+6 to N do       if (a[i]*a[j]        minb := a[i]*a[j];  writeln(minb);end. Задание Б.Используемый язык: Паскаль АВС.var h:array[0..5] of integer;        min,n,a:word;        i:integer;        pro:longint;begin   readln(n);   min:=10001;   pro:=10000001;     for i:=0 to 5 do read(h[i]);      for i:=6 to n-1 do     begin        read(a);        if(h[i mod 6]<min) then min:=h[i mod 6];        if(min * a<pro) then pro:=min*a;        h[i mod 6]:=a;     end;    writeln(pro);end.",
            "parsed": "2019-04-29 21:13:24.238274",
            "question": "Для заданной последовательности целых неотрицательных чисел необходимо найти минимальное произведение двух её элементов, различающихся порядковыми номерами не менее чем на 6. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000 и не менее 7. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Первое число подаваемое на вход программы — количество элементов последовательности.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body934580\" width=\"100%\"><p class=\"left_margin\">Для заданной последовательности целых неотрицательных чисел необходимо найти минимальное произведение двух её элементов, различающихся порядковыми номерами не менее чем на 6. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000 и не менее 7.<p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p><i>Первое число подаваемое на вход программы — количество элементов последовательности.</i></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание А.Используемый язык: Dev — C++ #include <iostream>using namespace std;int main () {    int a[10000];    int minb, i, j, N;    cin >> N;    for (i = 0; i < N; i++) // ввод значений в массив        cin >> a[i];    min = 1000*1000 + 1;    for (i = 0; i < N - 6; i++) {    for (j = i + 6; j < N; j++) {  //просмотрим каждую возможность        if (a[i] * a[j] < minb)            minb = a[i] * a[j]; }        }    cout << minb;    return(0);}Задание А.Используемый язык: Паскаль ABC.var  a: array[1..10000] of integer; {исходные данные}  N: integer;  minb: integer; {искомое минимальное произведение пары чисел}  i, j: integer;begin  readln(N);  for i := 1 to N do readln(a[i]);  minb := 1000*1000+1;  for i := 1 to N-6 do    for j := i+6 to N do       if (a[i]*a[j]        minb := a[i]*a[j];  writeln(minb);end. Задание Б.Используемый язык: Паскаль АВС.var h:array[0..5] of integer;        min,n,a:word;        i:integer;        pro:longint;begin   readln(n);   min:=10001;   pro:=10000001;     for i:=0 to 5 do read(h[i]);      for i:=6 to n-1 do     begin        read(a);        if(h[i mod 6]<min) then min:=h[i mod 6];        if(min * a<pro) then pro:=min*a;        h[i mod 6]:=a;     end;    writeln(pro);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11336\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание А.<p class=\"left_margin\">Используемый язык: Dev — C++<p> </p><p><tt><p>#include &lt;iostream&gt;<p>using namespace std;<p>int main () {<p>    int a[10000];<p>    int minb, i, j, N;<p>    cin &gt;&gt; N;<p>    for (i = 0; i &lt; N; i++) // ввод значений в массив<p>        cin &gt;&gt; a[i];<p>    min = 1000*1000 + 1;<p>    for (i = 0; i &lt; N - 6; i++) {<p>    for (j = i + 6; j &lt; N; j++) {  //просмотрим каждую возможность<p>        if (a[i] * a[j] &lt; minb)<p>            minb = a[i] * a[j]; }<p>        }<p>    cout &lt;&lt; minb;<p>    return(0);<p>}<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p class=\"left_margin\">Задание А.<p class=\"left_margin\">Используемый язык: Паскаль ABC.<pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer;<p>  minb: integer; {искомое минимальное произведение пары чисел}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  for i := 1 to N do readln(a[i]);<p>  minb := 1000*1000+1;<p>  for i := 1 to N-6 do<p>    for j := i+6 to N do <p>      if (a[i]*a[j]<minb) then<p=\"\">        minb := a[i]*a[j];<p>  writeln(minb);<p>end.</p></p></minb)></p></p></p></p></p></p></p></p></p></p></p></div></pre><p> </p><p class=\"left_margin\">Задание Б.<p class=\"left_margin\">Используемый язык: Паскаль АВС.<p><tt><div class=\"source_code lang_pascal\"><p>var h:array[0..5] of integer;<p>        min,n,a:word;<p>        i:integer;<p>        pro:longint;<p>begin<p>   readln(n);<p>   min:=10001;<p>   pro:=10000001;<p>  <p>   for i:=0 to 5 do read(h[i]);<p>   <p>   for i:=6 to n-1 do<p>     begin<p>        read(a);<p>        if(h[i mod 6]&lt;min) then min:=h[i mod 6];<p>        if(min * a&lt;pro) then pro:=min*a;<p>        h[i mod 6]:=a;<p>     end;<p> </p><p>   writeln(pro);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ 16.06.2016 по информатике. Основная волна. Вариант 66 (Часть С)",
            "task_id": "11336"
        },
        {
            "answer": "Решение.Задание Б. Cначала рассмотрим решение для более общего задания (вариант Б).Решение 1.Чтобы получить максимально возможную сумму, будем брать из каждой пары самое большое число. Если полученная при этом сумма будет делиться на 3, её необходимо уменьшить. Для этого достаточно в одной из пар, где числа имеют разные остатки при делении на 3, заменить ранее выбранное число на другое число из той же пары. При этом разница между числами в паре должна быть минимально возможной. Если во всех парах оба числа имеют одинаковый остаток при делении на 3, получить нужную сумму невозможно.Замечание для эксперта. От ученика не требуется доказывать правильность предложенного алгоритма. Для удобства экспертов докажем, что при наличии решения достаточно заменить одно число. Пусть это не так, т.е. найдутся две такие пары, от которых в искомую сумму входят не бόльшие в своих парах числа x1 и y1, а меньшие числа из соответствующих пар: x2 и y2. При том x2 + y2 имеет остаток от деления на 3, отличный от остатка от деления на 3 числа x1 + y1 (иначе мы могли бы включить в сумму x1 + y1 вместо x2 + y2). Но это означает, что хотя бы одно из чисел x2, y2 тоже при делении на 3 имеет остаток, отличный от соответствующего максимального числа пары. Значит, оптимальной является замена только одного из таких чисел.Программа читает все данные один раз. В каждой паре определяется большее число Max и разность между бόльшим и меньшим числами пары D. После обработки очередной пары программа хранит два числа: s — сумму всех максимальных элементов прочитанных пар и D_min — наименьшую возможную разность D, не кратную 3. Окончательным ответом будет значение s, если оно не делится на 3, и s – D_min в противном случае. Если s делится на 3, а D_min не определено (разность между числами во всех парах кратна 3), ответ в соответствии с условиями задачи считается равным 0Программа 1. Пример правильной и эффективной программы для задания Б на языке Паскаль const    aMax = 10000; {наибольшее возможное число в исходных данных} var    N: longint; {количество пар}    a, b: longint; {пара чисел}    Max: longint; {максимум в паре}    Min: longint; {минимум в паре}    s: longint; {сумма выбранных чисел}    D_min: longint; {минимальная разница Max-Min не кратная 3}    i: longint; begin    s := 0;    D_min := aMax + 1;    readln(N);    for i := 1 to N do begin        readln(a, b);        if a>b then begin Max:=a; Min:=b end            else begin Max:=b; Min:=a end;        s := s + Max;        if ((Max - Min) mod 3 > 0) and (Max - Min < D_min)            then D_min := Max - Min    end;    if s mod 3 = 0 then begin        if D_min > aMax then s := 0        else s := s – D_min    end;    writeln(s)end. Решение 2.Возможно и решение, основанное на другой идее, а именно будем хранить для каждого прочитанного набора пар три суммы (s0, s1, s2) — максимальные суммы элементов пар, имеющие при делении на 3 соответственно остатки 0, 1 и 2. При обработке очередной пары (a1, a2) эти суммы обновляются. Для этого достаточно рассмотреть суммы s0 + a1, s1 + a1, s2 + a1, s0 + a2, s1 + a2, s2 + a2 и для каждого возможного остатка от деления на 3 выбрать в качестве нового значения s0, s1 или s2 значение наибольшей из указанных сумм, дающей данный остаток. Окончательным ответом будет бόльшая из сумм s1 и s2.Эта идея приводит к более громоздкой реализации, но все основные требования по эффективности в ней выполнены, поэтому подобное решение при отсутствии ошибок можно оценить максимальным количеством баллов. Ниже приводится пример основанной на этом принципе программы на языке. Паскаль.Замечание для эксперта. В приведённом ниже решении для хранения s0, s1, s2 используется массив s_new[0..2]. Это упрощает реализацию, однако решение, в котором используются простые переменные, также допустимо. Не следует снижать баллы только за то, что в программе использованы простые переменные, а не массив, как в привёденном ниже примере. Программа 2. Пример правильной и эффективной программы для задания Б на языке Паскаль var    N: longint; {количество пар}    a: array[1..2] of longint; {пара чисел}    s_old, s_new: array[0..2] of longint;        {суммы с соответствующими остатками от деления на 3}    i, j, k, r: longint;begin    readln(N);    for j := 0 to 2 do        s_old[j] := 0;    for i := 1 to N do begin        readln(a[1], a[2]);        for j := 0 to 2 do            s_new[j] := 0;        for k := 1 to 2 do begin            for j := 0 to 2 do begin                if (s_old[j] > 0) or (i = 1) then begin                    r := (s_old[j] + a[k]) mod 3;                    if s_new[r] < s_old[j] + a[k] then                        s_new[r] := s_old[j] + a[k]                end            end        end;        s_old := s_new    end;    if s_new[1] > s_new[2] then        writeln(s_new[1])    else        writeln(s_new[2]);    {если решения не существует, то s_new[1] и s_new[2]    окажутся равными нулю}end. Замечание для эксперта. Ученик может «перестраховаться» и явно проверить, что хотя бы одно из чисел s_new[1], s_new[2] отлично от 0.Эта проверка излишня (см. комментарий в конце программы), однако она не влияет на порядок роста времени программы. Снижать баллы за такую избыточную проверку не следует.Задание А. Это задание можно выполнить «в лоб»: сохранить в массиве все исходные данные, перебрать все возможные способы выбора одного элемента из каждой пары и найти максимальную сумму, соответствующую условиям задачи.Ниже приводится пример такого решения Пример решения задачи А на языке Паскальvar    a: array[1..6, 1..2] of longint;    i1, i2, i3, i4, i5, i6: longint;    s, sMax: longint;begin    for i1:= 1 to 6 do readln(a[i1,1], a[i1,2]);    sMax := 0;    for i1:=1 to 2 do    for i2:=1 to 2 do    for i3:=1 to 2 do    for i4:=1 to 2 do    for i5:=1 to 2 do    for i6:=1 to 2 do begin        s:=a[1,i1]+a[2,i2]+a[3,i3]+a[4,i4]+a[5,i5]+a[6,i6];        if (s mod 3 <> 0) and (s > sMax) then sMax := s    end;    writeln(sMax)end.",
            "parsed": "2019-04-29 21:13:32.866014",
            "question": "Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется набор данных, состоящий из 6 пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была максимально возможной. Если получить требуемую сумму невозможно, в качестве ответа нужно выдать 0.Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была максимально возможной. Если получить требуемую сумму невозможно, в качестве ответа нужно выдать 0.Напишите программу для решения этой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Как в варианте А, так и в варианте Б программа должна напечатать одно число — максимально возможную сумму, соответствующую условиям задачи (или 0, если такую сумму получить нельзя). НАПОМИНАЕМ! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Перед текстом программы кратко опишите Ваш алгоритм решения, укажите использованный язык программирования и его версию (например, Free Pascal 2.6.4). Входные данныеДля варианта А на вход программе подаётся шесть строк, каждая из которых содержит два натуральных числа, не превышающих 10 000.Пример входных данных для варианта А:1 35 126 95 43 31 1 Для варианта Б на вход программе в первой строке подаётся количество пар N (1 ≤ N ≤ 100 000). Каждая из следующих N строк содержит два натуральных числа, не превышающих 10 000.Пример входных данных для варианта Б:61 35 126 95 43 31 1Пример выходных данных для приведённых выше примеров входных данных: 32",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body934559\" width=\"100%\"><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется набор данных, состоящий из 6 пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была максимально возможной. Если получить требуемую сумму невозможно, в качестве ответа нужно выдать 0.<p class=\"left_margin\">Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была максимально возможной. Если получить требуемую сумму невозможно, в качестве ответа нужно выдать 0.<p class=\"left_margin\">Напишите программу для решения этой задачи.<p class=\"left_margin\">Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p class=\"left_margin\">Как в варианте А, так и в варианте Б программа должна напечатать одно число — максимально возможную сумму, соответствующую условиям задачи (или 0, если такую сумму получить нельзя).<p> </p><p class=\"left_margin\">НАПОМИНАЕМ! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите Ваш алгоритм решения, укажите использованный язык программирования и его версию (например, Free Pascal 2.6.4).<p> </p><p class=\"left_margin\">Входные данные<p class=\"left_margin\">Для варианта А на вход программе подаётся шесть строк, каждая из которых содержит два натуральных числа, не превышающих 10 000.<p class=\"left_margin\">Пример входных данных для варианта А:<p class=\"left_margin\">1 3<p class=\"left_margin\">5 12<p class=\"left_margin\">6 9<p class=\"left_margin\">5 4<p class=\"left_margin\">3 3<p class=\"left_margin\">1 1<p> </p><p class=\"left_margin\">Для варианта Б на вход программе в первой строке подаётся количество пар <i>N</i> (1 ≤ <i>N</i> ≤ 100 000). Каждая из следующих <i>N</i> строк содержит два натуральных числа, не превышающих 10 000.<p class=\"left_margin\">Пример входных данных для варианта Б:<p class=\"left_margin\">6<p class=\"left_margin\">1 3<p class=\"left_margin\">5 12<p class=\"left_margin\">6 9<p class=\"left_margin\">5 4<p class=\"left_margin\">3 3<p class=\"left_margin\">1 1<p class=\"left_margin\">Пример выходных данных для приведённых выше примеров входных данных: 32</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание Б. Cначала рассмотрим решение для более общего задания (вариант Б).Решение 1.Чтобы получить максимально возможную сумму, будем брать из каждой пары самое большое число. Если полученная при этом сумма будет делиться на 3, её необходимо уменьшить. Для этого достаточно в одной из пар, где числа имеют разные остатки при делении на 3, заменить ранее выбранное число на другое число из той же пары. При этом разница между числами в паре должна быть минимально возможной. Если во всех парах оба числа имеют одинаковый остаток при делении на 3, получить нужную сумму невозможно.Замечание для эксперта. От ученика не требуется доказывать правильность предложенного алгоритма. Для удобства экспертов докажем, что при наличии решения достаточно заменить одно число. Пусть это не так, т.е. найдутся две такие пары, от которых в искомую сумму входят не бόльшие в своих парах числа x1 и y1, а меньшие числа из соответствующих пар: x2 и y2. При том x2 + y2 имеет остаток от деления на 3, отличный от остатка от деления на 3 числа x1 + y1 (иначе мы могли бы включить в сумму x1 + y1 вместо x2 + y2). Но это означает, что хотя бы одно из чисел x2, y2 тоже при делении на 3 имеет остаток, отличный от соответствующего максимального числа пары. Значит, оптимальной является замена только одного из таких чисел.Программа читает все данные один раз. В каждой паре определяется большее число Max и разность между бόльшим и меньшим числами пары D. После обработки очередной пары программа хранит два числа: s — сумму всех максимальных элементов прочитанных пар и D_min — наименьшую возможную разность D, не кратную 3. Окончательным ответом будет значение s, если оно не делится на 3, и s – D_min в противном случае. Если s делится на 3, а D_min не определено (разность между числами во всех парах кратна 3), ответ в соответствии с условиями задачи считается равным 0Программа 1. Пример правильной и эффективной программы для задания Б на языке Паскаль const    aMax = 10000; {наибольшее возможное число в исходных данных} var    N: longint; {количество пар}    a, b: longint; {пара чисел}    Max: longint; {максимум в паре}    Min: longint; {минимум в паре}    s: longint; {сумма выбранных чисел}    D_min: longint; {минимальная разница Max-Min не кратная 3}    i: longint; begin    s := 0;    D_min := aMax + 1;    readln(N);    for i := 1 to N do begin        readln(a, b);        if a>b then begin Max:=a; Min:=b end            else begin Max:=b; Min:=a end;        s := s + Max;        if ((Max - Min) mod 3 > 0) and (Max - Min < D_min)            then D_min := Max - Min    end;    if s mod 3 = 0 then begin        if D_min > aMax then s := 0        else s := s – D_min    end;    writeln(s)end. Решение 2.Возможно и решение, основанное на другой идее, а именно будем хранить для каждого прочитанного набора пар три суммы (s0, s1, s2) — максимальные суммы элементов пар, имеющие при делении на 3 соответственно остатки 0, 1 и 2. При обработке очередной пары (a1, a2) эти суммы обновляются. Для этого достаточно рассмотреть суммы s0 + a1, s1 + a1, s2 + a1, s0 + a2, s1 + a2, s2 + a2 и для каждого возможного остатка от деления на 3 выбрать в качестве нового значения s0, s1 или s2 значение наибольшей из указанных сумм, дающей данный остаток. Окончательным ответом будет бόльшая из сумм s1 и s2.Эта идея приводит к более громоздкой реализации, но все основные требования по эффективности в ней выполнены, поэтому подобное решение при отсутствии ошибок можно оценить максимальным количеством баллов. Ниже приводится пример основанной на этом принципе программы на языке. Паскаль.Замечание для эксперта. В приведённом ниже решении для хранения s0, s1, s2 используется массив s_new[0..2]. Это упрощает реализацию, однако решение, в котором используются простые переменные, также допустимо. Не следует снижать баллы только за то, что в программе использованы простые переменные, а не массив, как в привёденном ниже примере. Программа 2. Пример правильной и эффективной программы для задания Б на языке Паскаль var    N: longint; {количество пар}    a: array[1..2] of longint; {пара чисел}    s_old, s_new: array[0..2] of longint;        {суммы с соответствующими остатками от деления на 3}    i, j, k, r: longint;begin    readln(N);    for j := 0 to 2 do        s_old[j] := 0;    for i := 1 to N do begin        readln(a[1], a[2]);        for j := 0 to 2 do            s_new[j] := 0;        for k := 1 to 2 do begin            for j := 0 to 2 do begin                if (s_old[j] > 0) or (i = 1) then begin                    r := (s_old[j] + a[k]) mod 3;                    if s_new[r] < s_old[j] + a[k] then                        s_new[r] := s_old[j] + a[k]                end            end        end;        s_old := s_new    end;    if s_new[1] > s_new[2] then        writeln(s_new[1])    else        writeln(s_new[2]);    {если решения не существует, то s_new[1] и s_new[2]    окажутся равными нулю}end. Замечание для эксперта. Ученик может «перестраховаться» и явно проверить, что хотя бы одно из чисел s_new[1], s_new[2] отлично от 0.Эта проверка излишня (см. комментарий в конце программы), однако она не влияет на порядок роста времени программы. Снижать баллы за такую избыточную проверку не следует.Задание А. Это задание можно выполнить «в лоб»: сохранить в массиве все исходные данные, перебрать все возможные способы выбора одного элемента из каждой пары и найти максимальную сумму, соответствующую условиям задачи.Ниже приводится пример такого решения Пример решения задачи А на языке Паскальvar    a: array[1..6, 1..2] of longint;    i1, i2, i3, i4, i5, i6: longint;    s, sMax: longint;begin    for i1:= 1 to 6 do readln(a[i1,1], a[i1,2]);    sMax := 0;    for i1:=1 to 2 do    for i2:=1 to 2 do    for i3:=1 to 2 do    for i4:=1 to 2 do    for i5:=1 to 2 do    for i6:=1 to 2 do begin        s:=a[1,i1]+a[2,i2]+a[3,i3]+a[4,i4]+a[5,i5]+a[6,i6];        if (s mod 3 <> 0) and (s > sMax) then sMax := s    end;    writeln(sMax)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol11363\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание Б. Cначала рассмотрим решение для более общего задания (вариант Б).<p class=\"left_margin\">Решение 1.<p class=\"left_margin\">Чтобы получить максимально возможную сумму, будем брать из каждой пары самое большое число. Если полученная при этом сумма будет делиться на 3, её необходимо уменьшить. Для этого достаточно в одной из пар, где числа имеют разные остатки при делении на 3, заменить ранее выбранное число на другое число из той же пары. При этом разница между числами в паре должна быть минимально возможной. Если во всех парах оба числа имеют одинаковый остаток при делении на 3, получить нужную сумму невозможно.<p class=\"left_margin\">Замечание для эксперта. От ученика не требуется доказывать правильность предложенного алгоритма. Для удобства экспертов докажем, что при наличии решения достаточно заменить одно число. Пусть это не так, т.е. найдутся две такие пары, от которых в искомую сумму входят не бόльшие в своих парах числа <i>x</i><sub>1</sub> и <i>y</i><sub>1</sub>, а меньшие числа из соответствующих пар: <i>x</i><sub>2</sub> и <i>y</i><sub>2</sub>. При том <i>x</i><sub>2</sub> + <i>y</i><sub>2</sub> имеет остаток от деления на 3, отличный от остатка от деления на 3 числа <i>x</i><sub>1</sub> + <i>y</i><sub>1</sub> (иначе мы могли бы включить в сумму <i>x</i><sub>1</sub> + <i>y</i><sub>1</sub> вместо <i>x</i><sub>2</sub> + <i>y</i><sub>2</sub>). Но это означает, что хотя бы одно из чисел <i>x</i><sub>2</sub>, <i>y</i><sub>2</sub> тоже при делении на 3 имеет остаток, отличный от соответствующего максимального числа пары. Значит, оптимальной является замена только одного из таких чисел.<p class=\"left_margin\">Программа читает все данные один раз. В каждой паре определяется большее число Max и разность между бόльшим и меньшим числами пары <i>D</i>. После обработки очередной пары программа хранит два числа: <i>s</i> — сумму всех максимальных элементов прочитанных пар и <i>D_min</i> — наименьшую возможную разность <i>D</i>, не кратную 3. Окончательным ответом будет значение <i>s</i>, если оно не делится на 3, и <i>s</i> – <i>D_min</i> в противном случае. Если <i>s</i> делится на 3, а <i>D_min</i> не определено (разность между числами во всех парах кратна 3), ответ в соответствии с условиями задачи считается равным 0<p class=\"left_margin\">Программа 1. Пример правильной и эффективной программы для задания Б на языке Паскаль<p> </p><p><tt><p>const<p>    aMax = 10000; {наибольшее возможное число в исходных данных}<p> </p><p>var<p>    N: longint; {количество пар}<p>    a, b: longint; {пара чисел}<p>    Max: longint; {максимум в паре}<p>    Min: longint; {минимум в паре}<p>    s: longint; {сумма выбранных чисел}<p>    D_min: longint; {минимальная разница Max-Min не кратная 3}<p>    i: longint;<p> </p><p>begin<p>    s := 0;<p>    D_min := aMax + 1;<p>    readln(N);<p>    for i := 1 to N do begin<p>        readln(a, b);<p>        if a&gt;b then begin Max:=a; Min:=b end<p>            else begin Max:=b; Min:=a end;<p>        s := s + Max;<p>        if ((Max - Min) mod 3 &gt; 0) and (Max - Min &lt; D_min)<p>            then D_min := Max - Min<p>    end;<p>    if s mod 3 = 0 then begin<p>        if D_min &gt; aMax then s := 0<p>        else s := s – D_min<p>    end;<p>    writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Решение 2.<p class=\"left_margin\">Возможно и решение, основанное на другой идее, а именно будем хранить для каждого прочитанного набора пар три суммы (<i>s</i><sub>0</sub>, <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>) — максимальные суммы элементов пар, имеющие при делении на 3 соответственно остатки 0, 1 и 2. При обработке очередной пары (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>) эти суммы обновляются. Для этого достаточно рассмотреть суммы <i>s</i><sub>0</sub> + <i>a</i><sub>1</sub>, <i>s</i><sub>1</sub> + <i>a</i><sub>1</sub>, <i>s</i><sub>2</sub> + <i>a</i><sub>1</sub>, <i>s</i><sub>0</sub> + <i>a</i><sub>2</sub>, <i>s</i><sub>1</sub> + <i>a</i><sub>2</sub>, <i>s</i><sub>2</sub> + <i>a</i><sub>2</sub> и для каждого возможного остатка от деления на 3 выбрать в качестве нового значения <i>s</i><sub>0</sub>, <i>s</i><sub>1</sub> или <i>s</i><sub>2</sub> значение наибольшей из указанных сумм, дающей данный остаток. Окончательным ответом будет бόльшая из сумм <i>s</i><sub>1</sub> и <i>s</i><sub>2</sub>.<p class=\"left_margin\">Эта идея приводит к более громоздкой реализации, но все основные требования по эффективности в ней выполнены, поэтому подобное решение при отсутствии ошибок можно оценить максимальным количеством баллов. Ниже приводится пример основанной на этом принципе программы на языке.<p> </p><p class=\"left_margin\">Паскаль.<p class=\"left_margin\">Замечание для эксперта. В приведённом ниже решении для хранения <i>s</i><sub>0</sub>, <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub> используется массив <i>s_new</i>[0..2]. Это упрощает реализацию, однако решение, в котором используются простые переменные, также допустимо. Не следует снижать баллы только за то, что в программе использованы простые переменные, а не массив, как в привёденном ниже примере.<p> </p><p class=\"left_margin\">Программа 2. Пример правильной и эффективной программы для задания Б на языке Паскаль<p> </p><p><tt><p>var<p>    N: longint; {количество пар}<p>    a: array[1..2] of longint; {пара чисел}<p>    s_old, s_new: array[0..2] of longint;<p>        {суммы с соответствующими остатками от деления на 3}<p>    i, j, k, r: longint;<p>begin<p>    readln(N);<p>    for j := 0 to 2 do<p>        s_old[j] := 0;<p>    for i := 1 to N do begin<p>        readln(a[1], a[2]);<p>        for j := 0 to 2 do<p>            s_new[j] := 0;<p>        for k := 1 to 2 do begin<p>            for j := 0 to 2 do begin<p>                if (s_old[j] &gt; 0) or (i = 1) then begin<p>                    r := (s_old[j] + a[k]) mod 3;<p>                    if s_new[r] &lt; s_old[j] + a[k] then<p>                        s_new[r] := s_old[j] + a[k]<p>                end<p>            end<p>        end;<p>        s_old := s_new<p>    end;<p>    if s_new[1] &gt; s_new[2] then<p>        writeln(s_new[1])<p>    else<p>        writeln(s_new[2]);<p>    {если решения не существует, то s_new[1] и s_new[2]<p>    окажутся равными нулю}<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Замечание для эксперта. Ученик может «перестраховаться» и явно проверить, что хотя бы одно из чисел <i>s_new</i>[1], <i>s_new</i>[2] отлично от 0.<p class=\"left_margin\">Эта проверка излишня (см. комментарий в конце программы), однако она не влияет на порядок роста времени программы. Снижать баллы за такую избыточную проверку не следует.<p class=\"left_margin\">Задание А. Это задание можно выполнить «в лоб»: сохранить в массиве все исходные данные, перебрать все возможные способы выбора одного элемента из каждой пары и найти максимальную сумму, соответствующую условиям задачи.<p class=\"left_margin\">Ниже приводится пример такого решения<p> </p><p class=\"left_margin\">Пример решения задачи А на языке Паскаль<p><tt><p>var<p>    a: array[1..6, 1..2] of longint;<p>    i1, i2, i3, i4, i5, i6: longint;<p>    s, sMax: longint;<p>begin<p>    for i1:= 1 to 6 do readln(a[i1,1], a[i1,2]);<p>    sMax := 0;<p>    for i1:=1 to 2 do<p>    for i2:=1 to 2 do<p>    for i3:=1 to 2 do<p>    for i4:=1 to 2 do<p>    for i5:=1 to 2 do<p>    for i6:=1 to 2 do begin<p>        s:=a[1,i1]+a[2,i2]+a[3,i3]+a[4,i4]+a[5,i5]+a[6,i6];<p>        if (s mod 3 &lt;&gt; 0) and (s &gt; sMax) then sMax := s<p>    end;<p>    writeln(sMax)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Де­мон­стра­ци­он­ная вер­сия ЕГЭ—2017 по информатике.",
            "task_id": "11363"
        },
        {
            "answer": "Решение.Можно заметить, что 26 = 13*2. Поэтому ответом является наибольшее из двух произведений:a) максимальное нечетное число, кратное 13, умноженное на максимальное четное число из оставшихся;b) максимальное число, кратное 26, умноженное на максимальное число из оставшихся.Чтобы не взять в произведении одно и тоже число, можно хранить номер их поступления. Если вдруг найдем повторяющиеся значения по этому номеру (например, на тесте из 3 элементов 52, 5 и 7 значение максимума и максимального числа кратного 26 совпадает), то найдем предмаксимумы для обоих случаев и возьмем более выгодный из них. Далее пример оптимальной программы на языке PascalABC.   var  n, i, a, r,  max2, max13, max26, max, predmax: integer;   index2, index13, index26, indexmax, ans, ans1, ans2: integer; begin  readln(n);   max:=0;  max26:=0;  max13:=0;  max2:=0;  ans:=0;  ans1:=0;  ans2:=0;  r:=0;  for i := 1 to n do   begin    readln(a);    if (a mod 13 = 0) and (a > max13) then begin      max13 := a;       index13 := i;     end;     if (a mod 2 = 0) and (a > max2) then begin      max2 := a;       index2 := i;     end;     if (a mod 26 = 0) and (a > max26) then begin      max26 := a;       index26 := i;     end;     if (a >= max) then begin      predmax:=max;      max := a;       indexmax := i;     end;    if(a < max) and (a >= predmax) then      predmax := a;  end;   readln(r);  if(index2 <> index13) then    ans1 := max2 * max13;    if(index26 <> indexmax) then    ans2 := max * max26  else    ans2 := predmax * max26;      if(ans1 > ans2) then    ans := ans1   else    ans := ans2;  writeln('Вычисленное контрольное значение:', ans);   if (ans=r) then     writeln('Контроль пройден')  else    writeln('Контроль не пройден');end.Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    max: integer; {вычисленное контролькое значение}    R: integer; {передаваемое контрольное значение}    i, j: integer;begin    readln(N);    for i := 1 to N do read(a[i]);    max := 0;    for i := 1 to N-1 do        for j := i + 1 to N do            if (a[i]*a[j] mod 26 = 0) and (a[i]*a[j]>max) then                max := a[i]*a[j];    readln(R);    if max = R then begin      writeln('Вычисленное контрольное значение: ', R);      writeln('Контроль пройден')    end    else writeln('Контроль не пройден');end.",
            "parsed": "2019-04-29 21:13:15.105661",
            "question": "На спутнике «Восход» установлен прибор, предназначенный для измерения солнечной активности. В течение времени эксперимента (это время известно заранее) прибор каждую минуту передаёт в обсерваторию по каналу связи положительное целое число, не превышающее 1000, — количество энергии солнечного излучения, полученной за последнюю минуту, измеренное в условных единицах.После окончания эксперимента передаётся контрольное значение — наибольшее число R, удовлетворяющее следующим условиям:1) R — произведение двух чисел, переданных в разные минуты;2) R делится на 26.Предполагается, что удовлетворяющее условиям контрольное значение существовало в момент передачи.В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.Напишите эффективную по времени и используемой памяти программу (укажите используемую версию языка программирования, например Free Pascal 2.6.4), которая будет проверять правильность контрольного значения. Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Программа должна напечатать отчёт по следующей форме. Вычисленное контрольное значение: …Контроль пройден (или Контроль не пройден) Если удовлетворяющее условию контрольное значение определить невозможно, то выводится только фраза «Контроль не пройден». Перед текстом программы кратко опишите используемый Вами алгоритм решения.На вход программе в первой строке подаётся количество чисел N ≤ 100 000. В каждой из последующих N строк записано одно положительное целое число, не превышающее 1000. В последней строке записано контрольное значение. Пример входных данных:552123955232860 Пример выходных данных для приведённого выше примера входных данных:Вычисленное контрольное значение: 2860Контроль пройден",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940737\" width=\"100%\"><p class=\"left_margin\">На спутнике «Восход» установлен прибор, предназначенный для измерения солнечной активности. В течение времени эксперимента (это время известно заранее) прибор каждую минуту передаёт в обсерваторию по каналу связи положительное целое число, не превышающее 1000, — количество энергии солнечного излучения, полученной за последнюю минуту, измеренное в условных единицах.<p class=\"left_margin\">После окончания эксперимента передаётся контрольное значение — наибольшее число R, удовлетворяющее следующим условиям:<p class=\"left_margin\">1) R — произведение двух чисел, переданных в разные минуты;<p class=\"left_margin\">2) R делится на 26.<p class=\"left_margin\">Предполагается, что удовлетворяющее условиям контрольное значение существовало в момент передачи.<p class=\"left_margin\">В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.<p class=\"left_margin\">Напишите эффективную по времени и используемой памяти программу (укажите используемую версию языка программирования, например Free Pascal 2.6.4), которая будет проверять правильность контрольного значения. Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Программа должна напечатать отчёт по следующей форме.<p> </p><p class=\"left_margin\">Вычисленное контрольное значение: …<p class=\"left_margin\">Контроль пройден (или Контроль не пройден)<p> </p><p class=\"left_margin\">Если удовлетворяющее условию контрольное значение определить невозможно, то выводится только фраза «Контроль не пройден». Перед текстом программы кратко опишите используемый Вами алгоритм решения.<p class=\"left_margin\">На вход программе в первой строке подаётся количество чисел N ≤ 100 000. В каждой из последующих N строк записано одно положительное целое число, не превышающее 1000. В последней строке записано контрольное значение.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">52<p class=\"left_margin\">12<p class=\"left_margin\">39<p class=\"left_margin\">55<p class=\"left_margin\">23<p class=\"left_margin\">2860<p> </p><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">Вычисленное контрольное значение: 2860<p class=\"left_margin\">Контроль пройден</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Можно заметить, что 26 = 13*2. Поэтому ответом является наибольшее из двух произведений:a) максимальное нечетное число, кратное 13, умноженное на максимальное четное число из оставшихся;b) максимальное число, кратное 26, умноженное на максимальное число из оставшихся.Чтобы не взять в произведении одно и тоже число, можно хранить номер их поступления. Если вдруг найдем повторяющиеся значения по этому номеру (например, на тесте из 3 элементов 52, 5 и 7 значение максимума и максимального числа кратного 26 совпадает), то найдем предмаксимумы для обоих случаев и возьмем более выгодный из них. Далее пример оптимальной программы на языке PascalABC.   var  n, i, a, r,  max2, max13, max26, max, predmax: integer;   index2, index13, index26, indexmax, ans, ans1, ans2: integer; begin  readln(n);   max:=0;  max26:=0;  max13:=0;  max2:=0;  ans:=0;  ans1:=0;  ans2:=0;  r:=0;  for i := 1 to n do   begin    readln(a);    if (a mod 13 = 0) and (a > max13) then begin      max13 := a;       index13 := i;     end;     if (a mod 2 = 0) and (a > max2) then begin      max2 := a;       index2 := i;     end;     if (a mod 26 = 0) and (a > max26) then begin      max26 := a;       index26 := i;     end;     if (a >= max) then begin      predmax:=max;      max := a;       indexmax := i;     end;    if(a < max) and (a >= predmax) then      predmax := a;  end;   readln(r);  if(index2 <> index13) then    ans1 := max2 * max13;    if(index26 <> indexmax) then    ans2 := max * max26  else    ans2 := predmax * max26;      if(ans1 > ans2) then    ans := ans1   else    ans := ans2;  writeln('Вычисленное контрольное значение:', ans);   if (ans=r) then     writeln('Контроль пройден')  else    writeln('Контроль не пройден');end.Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    max: integer; {вычисленное контролькое значение}    R: integer; {передаваемое контрольное значение}    i, j: integer;begin    readln(N);    for i := 1 to N do read(a[i]);    max := 0;    for i := 1 to N-1 do        for j := i + 1 to N do            if (a[i]*a[j] mod 26 = 0) and (a[i]*a[j]>max) then                max := a[i]*a[j];    readln(R);    if max = R then begin      writeln('Вычисленное контрольное значение: ', R);      writeln('Контроль пройден')    end    else writeln('Контроль не пройден');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13373\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Можно заметить, что 26 = 13*2. Поэтому ответом является наибольшее из двух произведений:<p>a) максимальное нечетное число, кратное 13, умноженное на максимальное четное число из оставшихся;<p>b) максимальное число, кратное 26, умноженное на максимальное число из оставшихся.<p class=\"left_margin\">Чтобы не взять в произведении одно и тоже число, можно хранить номер их поступления. <p class=\"left_margin\">Если вдруг найдем повторяющиеся значения по этому номеру (например, на тесте из 3 элементов 52, 5 и 7 значение максимума и максимального числа кратного 26 совпадает), то найдем предмаксимумы для обоих случаев и возьмем более выгодный из них.<p> </p><p class=\"left_margin\">Далее пример оптимальной программы на языке PascalABC. <p> </p><p> </p><pre><p>var<p>  n, i, a, r,  max2, max13, max26, max, predmax: integer; <p>  index2, index13, index26, indexmax, ans, ans1, ans2: integer;<p> </p><p>begin<p>  readln(n); <p>  max:=0;<p>  max26:=0;<p>  max13:=0;<p>  max2:=0;<p>  ans:=0;<p>  ans1:=0;<p>  ans2:=0;<p>  r:=0;<p>  for i := 1 to n do <p>  begin<p>    readln(a);<p>    if (a mod 13 = 0) and (a &gt; max13) then begin<p>      max13 := a; <p>      index13 := i; <p>    end; <p>    if (a mod 2 = 0) and (a &gt; max2) then begin<p>      max2 := a; <p>      index2 := i; <p>    end; <p>    if (a mod 26 = 0) and (a &gt; max26) then begin<p>      max26 := a; <p>      index26 := i; <p>    end; <p>    if (a &gt;= max) then begin<p>      predmax:=max;<p>      max := a; <p>      indexmax := i; <p>    end;<p>    if(a &lt; max) and (a &gt;= predmax) then<p>      predmax := a;<p>  end; <p>  readln(r);<p>  if(index2 &lt;&gt; index13) then<p>    ans1 := max2 * max13;<p>  <p>  if(index26 &lt;&gt; indexmax) then<p>    ans2 := max * max26<p>  else<p>    ans2 := predmax * max26;<p>  <p>  <p>  if(ans1 &gt; ans2) then<p>    ans := ans1 <p>  else<p>    ans := ans2;<p>  writeln('Вычисленное контрольное значение:', ans); <p>  if (ans=r) then <p>    writeln('Контроль пройден')<p>  else<p>    writeln('Контроль не пройден');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p> </p><pre>var<p>    N: integer; {количество чисел}<p>    a: array [1..1000] of integer; {исходные данные}<p>    max: integer; {вычисленное контролькое значение}<p>    R: integer; {передаваемое контрольное значение}<p>    i, j: integer;<p>begin<p>    readln(N);<p>    for i := 1 to N do read(a[i]);<p>    max := 0;<p>    for i := 1 to N-1 do<p>        for j := i + 1 to N do<p>            if (a[i]*a[j] mod 26 = 0) and (a[i]*a[j]&gt;max) then<p>                max := a[i]*a[j];<p>    readln(R);<p>    if max = R then begin<p>      writeln('Вычисленное контрольное значение: ', R);<p>      writeln('Контроль пройден')<p>    end<p>    else writeln('Контроль не пройден');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ — 2017. До­сроч­ная волна по информатике",
            "task_id": "13373"
        },
        {
            "answer": "Решение.Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы.  Далее последует пример кода, который работает за линейное время.язык - PascalABC.   var        N: integer;     {количество чисел}       a: integer;     {очередное число}      s: integer;     {сумма цифр числа}       k: array [0..27] of integer; {подсчёт сумм}       imx: integer;   {самая частая сумма}      i: integer; begin       for i:=0 to 27 do k[i]:=0;      readln(N);      for i:=1 to N do begin             readln(a);            s := 0;             while a>0 do begin                 s := s + a mod 10;                   a := a div 10;             end;             k[s] := k[s]+1;       end;       imx := 0;       for i:=1 to 27 do begin             if k[i] > k[imx] then imx := i;  end;    write(imx)  end.   import java.util.Scanner; public class P27A {\tpublic static void main(String[] args) {\t\tScanner in = new Scanner(System.in);\t\tint N = in.nextInt();\t\tint k[] = new int[28];\t\tfor (int i = 0; i < N; ++i) {\t\t\tint a = in.nextInt();\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;\t\t\t++k[s];\t\t}\t\tint imx = 0;\t\tfor (int i = 1; i < k.length; ++i) {\t\t\tif (k[i] > k[imx])\t\t\t\timx = i;\t\t}\t\tSystem.out.print(imx);\t}}   Примечание ненужно обрабатывать случай, когда k[i] = k[imx] так как тогда нам все равно нужно будет оставить значение imx неизменным. Пример правильной, но неэффективной программы на языке Паскаль. var   N: integer; {количество чисел}  val: integer; {самая частая сумма}  a: array [1..10000] of integer;  max_lenght: integer;  i, j, k, lenght: integer;begin  readln(N);  for i:=1 to N do read(a[i]);  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;  for i:=1 to N-1 do    for j:=1 to N-i do      if a[j]>a[j+1] then begin        k := a[j];       a[j] := a[j+1];       a[j+1] := k;      end;  max_lenght := N+1;  lenght := 0;  val := a[1];  for i := 1 to N do   if a[i]=a[i+1] then     lenght := lenght + 1    else begin    if lenght>max_lenght then begin    max_lenght := lenght;    val := a[i];    end;    lenght := 0;    end;  writeln(val);end.",
            "parsed": "2019-04-29 21:13:33.309275",
            "question": "Дан набор из N неотрицательных целых чисел, меньших 1000. Для каждого числа вычисляется сумма цифр его десятичной записи. Необходимо определить, какая сумма цифр чаще всего встречается у чисел этого набора. Если таких сумм несколько, нужно вывести наименьшую из них. Напишите эффективную по времени и по памяти программу для решения этой задачи.  Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N. Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла. Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла. Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.  Описание входных и выходных данных: В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 10 000). В каждой из последующих N строк записано одно неотрицательное число, меньшее 1000. Пример входных данных: 5 4 15 24 18 31 Пример выходных данных для приведённого примера входных данных: 4 У чисел заданного набора чаще всего — по 2 раза — встречаются суммы 4 и 6, в ответе выводится меньшая из них.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940691\" width=\"100%\"><p class=\"left_margin\">Дан набор из N неотрицательных целых чисел, меньших 1000. Для каждого числа вычисляется сумма цифр его десятичной записи. Необходимо определить, какая сумма цифр чаще всего встречается у чисел этого набора. Если таких сумм несколько, нужно вывести наименьшую из них. Напишите эффективную по времени и по памяти программу для решения этой задачи.  Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N. <p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p> <p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. <p> </p><p class=\"left_margin\">Описание входных и выходных данных:<p> </p><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 10 000). В каждой из последующих N строк записано одно неотрицательное число, меньшее 1000. <p><i>Пример входных данных: </i><p class=\"left_margin\">5 <p class=\"left_margin\">4 <p class=\"left_margin\">15 <p class=\"left_margin\">24 <p class=\"left_margin\">18 <p class=\"left_margin\">31 <p><i>Пример выходных данных для приведённого примера входных данных: </i><p class=\"left_margin\">4 <p class=\"left_margin\">У чисел заданного набора чаще всего — по 2 раза — встречаются суммы 4 и 6, в ответе выводится меньшая из них.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы.  Далее последует пример кода, который работает за линейное время.язык - PascalABC.   var        N: integer;     {количество чисел}       a: integer;     {очередное число}      s: integer;     {сумма цифр числа}       k: array [0..27] of integer; {подсчёт сумм}       imx: integer;   {самая частая сумма}      i: integer; begin       for i:=0 to 27 do k[i]:=0;      readln(N);      for i:=1 to N do begin             readln(a);            s := 0;             while a>0 do begin                 s := s + a mod 10;                   a := a div 10;             end;             k[s] := k[s]+1;       end;       imx := 0;       for i:=1 to 27 do begin             if k[i] > k[imx] then imx := i;  end;    write(imx)  end.   import java.util.Scanner; public class P27A {\tpublic static void main(String[] args) {\t\tScanner in = new Scanner(System.in);\t\tint N = in.nextInt();\t\tint k[] = new int[28];\t\tfor (int i = 0; i < N; ++i) {\t\t\tint a = in.nextInt();\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;\t\t\t++k[s];\t\t}\t\tint imx = 0;\t\tfor (int i = 1; i < k.length; ++i) {\t\t\tif (k[i] > k[imx])\t\t\t\timx = i;\t\t}\t\tSystem.out.print(imx);\t}}   Примечание ненужно обрабатывать случай, когда k[i] = k[imx] так как тогда нам все равно нужно будет оставить значение imx неизменным. Пример правильной, но неэффективной программы на языке Паскаль. var   N: integer; {количество чисел}  val: integer; {самая частая сумма}  a: array [1..10000] of integer;  max_lenght: integer;  i, j, k, lenght: integer;begin  readln(N);  for i:=1 to N do read(a[i]);  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;  for i:=1 to N-1 do    for j:=1 to N-i do      if a[j]>a[j+1] then begin        k := a[j];       a[j] := a[j+1];       a[j+1] := k;      end;  max_lenght := N+1;  lenght := 0;  val := a[1];  for i := 1 to N do   if a[i]=a[i+1] then     lenght := lenght + 1    else begin    if lenght>max_lenght then begin    max_lenght := lenght;    val := a[i];    end;    lenght := 0;    end;  writeln(val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13423\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы. <p> </p><p class=\"left_margin\">Далее последует пример кода, который работает за линейное время.<p>язык - PascalABC. <p> </p><p> </p><pre><p>var      <p>  N: integer;     {количество чисел}     <p>  a: integer;     {очередное число}    <p>  s: integer;     {сумма цифр числа}     <p>  k: array [0..27] of integer; {подсчёт сумм}     <p>  imx: integer;   {самая частая сумма}    <p>  i: integer; <p>begin     <p>  for i:=0 to 27 do k[i]:=0;    <p>  readln(N);    <p>  for i:=1 to N do begin         <p>    readln(a);        <p>    s := 0;         <p>    while a&gt;0 do begin           <p>      s := s + a mod 10;             <p>      a := a div 10;         <p>    end;         <p>    k[s] := k[s]+1;     <p>  end;     <p>  imx := 0;     <p>  for i:=1 to 27 do begin         <p>    if k[i] &gt; k[imx] then imx := i;<p>  end;  <p>  write(imx)<p>  end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p> </p><p> </p><pre><p>import java.util.Scanner;<p> </p><p>public class P27A {<p>\tpublic static void main(String[] args) {<p>\t\tScanner in = new Scanner(System.in);<p>\t\tint N = in.nextInt();<p>\t\tint k[] = new int[28];<p>\t\tfor (int i = 0; i &lt; N; ++i) {<p>\t\t\tint a = in.nextInt();<p>\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;<p>\t\t\t++k[s];<p>\t\t}<p>\t\tint imx = 0;<p>\t\tfor (int i = 1; i &lt; k.length; ++i) {<p>\t\t\tif (k[i] &gt; k[imx])<p>\t\t\t\timx = i;<p>\t\t}<p>\t\tSystem.out.print(imx);<p>\t}<p>}<p> </p><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p> </p><p><b>Примечание</b> ненужно обрабатывать случай, когда k[i] = k[imx] так как тогда нам все равно нужно будет оставить значение imx неизменным.<p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p> </p><pre>var <p>  N: integer; {количество чисел}<p>  val: integer; {самая частая сумма}<p>  a: array [1..10000] of integer;<p>  max_lenght: integer;<p>  i, j, k, lenght: integer;<p>begin<p>  readln(N);<p>  for i:=1 to N do read(a[i]);<p>  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;<p>  for i:=1 to N-1 do<p>    for j:=1 to N-i do<p>      if a[j]&gt;a[j+1] then begin<p>        k := a[j];<p>       a[j] := a[j+1];<p>       a[j+1] := k;<p>      end;<p>  max_lenght := N+1;<p>  lenght := 0;<p>  val := a[1];<p>  for i := 1 to N do<p>   if a[i]=a[i+1] then<p>     lenght := lenght + 1<p>    else begin<p>    if lenght&gt;max_lenght then begin<p>    max_lenght := lenght;<p>    val := a[i];<p>    end;<p>    lenght := 0;<p>    end;<p>  writeln(val);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 18 января 2017 года  Вариант ИН10303",
            "task_id": "13423"
        },
        {
            "answer": "Решение.Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы Далее последует пример кода, который работает за линейное время.Язык — PascalABC.   var       N: integer;     {количество чисел}       a: integer;     {очередное число}       s: integer;     {сумма цифр числа}      k: array [0..27] of integer; {подсчёт сумм}      mn: integer;    {минимум в массиве k}      imn: integer;   {самая редкая сумма}     i: integer; begin       for i:=0 to 27 do k[i]:=0;       readln(N);      for i:=1 to N do begin            readln(a);           s := 0;             while a>0 do begin              s := s + a mod 10;          a := a div 10;    end;             k[s] := k[s]+1;       end;       mn := N+1;       for i:=0 to 27 do begin             if (k[i]>0) and (k[i]<=mn) then begin                mn := k[i];                    imn := i;             end;     end;          write(imn); end.  import java.util.Scanner; public class P27B {\tpublic static void main(String[] args) {\t\tScanner in = new Scanner(System.in);\t\tint N = in.nextInt();\t\tint k[] = new int[28];\t\tfor (int i = 0; i < N; ++i) {\t\t\tint a = in.nextInt();\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;\t\t\t++k[s];\t\t}\t\tint mn = N + 1;\t\tint imn = 0;\t\tfor (int i = 0; i < k.length; ++i) {\t\t\tif (k[i] > 0 && k[i] <= mn) {\t\t\t\tmn = k[i];\t\t\t\timn = i;\t\t\t}\t\t}\t\tSystem.out.print(imn);\t}} Пример правильной, но неэффективной программы на языке Паскаль. var   N: integer; {количество чисел}  val: integer; {самая редкая сумма}  a: array [1..10000] of integer;  max_lenght: integer;  i, j, k, lenght: integer;begin  readln(N);  for i:=1 to N do read(a[i]);  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;  for i:=1 to N-1 do    for j:=1 to N-i do      if a[j] < a[j+1] then begin        k := a[j];        a[j] := a[j+1];       a[j+1] := k;     end;  max_lenght := N+1;  lenght := 0;  val := a[1];  for i := 1 to N do     if a[i]=a[i+1] then     lenght := lenght + 1    else begin    if lenght      max_lenght := lenght;      val := a[i];    end;    lenght := 0;    end;  writeln(val);end.",
            "parsed": "2019-04-29 21:13:33.720130",
            "question": "Дан набор из N неотрицательных целых чисел, меньших 1000. Для каждого числа вычисляется сумма цифр его десятичной записи. Необходимо определить, какая сумма цифр реже всего встречается у чисел этого набора. Если таких сумм несколько, нужно вывести наибольшую из них. Напишите эффективную по времени и по памяти программу для решения этой задачи.  Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N. Максимальная оценка за правильную ( не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла. Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла. Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.  Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.  Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N  (1 ≤ N ≤ 10 000). В каждой из последующих N строк записано одно неотрицательное число, меньшее 1000. Пример входных данных: 5 4 15 24 18 60Пример выходных данных для приведённого примера входных данных: 9 У чисел заданного набора реже всего — по одному разу — встречаются суммы 4 и 9, в ответе выводится бóльшая из них.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940632\" width=\"100%\"><p class=\"left_margin\">Дан набор из N неотрицательных целых чисел, меньших 1000. Для каждого числа вычисляется сумма цифр его десятичной записи. Необходимо определить, какая сумма цифр реже всего встречается у чисел этого набора. Если таких сумм несколько, нужно вывести наибольшую из них. Напишите эффективную по времени и по памяти программу для решения этой задачи.  Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N. <p class=\"left_margin\">Максимальная оценка за правильную ( не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла. Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла. <p> </p><p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. <p> <p class=\"left_margin\">Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N  (1 ≤ N ≤ 10 000). В каждой из последующих N строк записано одно неотрицательное число, меньшее 1000. <p><i>Пример входных данных: </i><p class=\"left_margin\">5 <p class=\"left_margin\">4 <p class=\"left_margin\">15 <p class=\"left_margin\">24 <p class=\"left_margin\">18 <p class=\"left_margin\">60<p><i>Пример выходных данных для приведённого примера входных данных: </i><p class=\"left_margin\">9 <p class=\"left_margin\">У чисел заданного набора реже всего — по одному разу — встречаются суммы 4 и 9, в ответе выводится бóльшая из них.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы Далее последует пример кода, который работает за линейное время.Язык — PascalABC.   var       N: integer;     {количество чисел}       a: integer;     {очередное число}       s: integer;     {сумма цифр числа}      k: array [0..27] of integer; {подсчёт сумм}      mn: integer;    {минимум в массиве k}      imn: integer;   {самая редкая сумма}     i: integer; begin       for i:=0 to 27 do k[i]:=0;       readln(N);      for i:=1 to N do begin            readln(a);           s := 0;             while a>0 do begin              s := s + a mod 10;          a := a div 10;    end;             k[s] := k[s]+1;       end;       mn := N+1;       for i:=0 to 27 do begin             if (k[i]>0) and (k[i]<=mn) then begin                mn := k[i];                    imn := i;             end;     end;          write(imn); end.  import java.util.Scanner; public class P27B {\tpublic static void main(String[] args) {\t\tScanner in = new Scanner(System.in);\t\tint N = in.nextInt();\t\tint k[] = new int[28];\t\tfor (int i = 0; i < N; ++i) {\t\t\tint a = in.nextInt();\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;\t\t\t++k[s];\t\t}\t\tint mn = N + 1;\t\tint imn = 0;\t\tfor (int i = 0; i < k.length; ++i) {\t\t\tif (k[i] > 0 && k[i] <= mn) {\t\t\t\tmn = k[i];\t\t\t\timn = i;\t\t\t}\t\t}\t\tSystem.out.print(imn);\t}} Пример правильной, но неэффективной программы на языке Паскаль. var   N: integer; {количество чисел}  val: integer; {самая редкая сумма}  a: array [1..10000] of integer;  max_lenght: integer;  i, j, k, lenght: integer;begin  readln(N);  for i:=1 to N do read(a[i]);  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;  for i:=1 to N-1 do    for j:=1 to N-i do      if a[j] < a[j+1] then begin        k := a[j];        a[j] := a[j+1];       a[j+1] := k;     end;  max_lenght := N+1;  lenght := 0;  val := a[1];  for i := 1 to N do     if a[i]=a[i+1] then     lenght := lenght + 1    else begin    if lenght      max_lenght := lenght;      val := a[i];    end;    lenght := 0;    end;  writeln(val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13476\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Наименьшая возможная сумма цифр числа в заданном диапазоне равна 0, наибольшая — 27. Необходимо создать массив с индексами от 0 до 27 и использовать его для подсчёта встречающихся сумм. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести его индекс. Ниже приведены реализующие описанный выше алгоритм программы на языке Паскаль (использована система программирования PascalABC) и языке Java (версия языка 5.0 или выше). Программы отличаются способом вычисления суммы цифр очередного числа: в программе на Паскале использован обычный цикл разложения числа на цифры десятичной записи, в программе на Java сумма вычисляется по формуле, учитывающей, что число содержит не более трёх цифр. Оба способа допустимы<p> </p><p class=\"left_margin\">Далее последует пример кода, который работает за линейное время.<p class=\"left_margin\">Язык — PascalABC. <p> </p><p> </p><pre><p>var     <p>  N: integer;     {количество чисел}     <p>  a: integer;     {очередное число}     <p>  s: integer;     {сумма цифр числа}    <p>  k: array [0..27] of integer; {подсчёт сумм}    <p>  mn: integer;    {минимум в массиве k}    <p>  imn: integer;   {самая редкая сумма}   <p>  i: integer; <p>begin     <p>  for i:=0 to 27 do k[i]:=0;     <p>  readln(N);    <p>  for i:=1 to N do begin        <p>    readln(a);       <p>    s := 0;         <p>    while a&gt;0 do begin    <p>          s := s + a mod 10;<p>          a := a div 10;<p>    end;         <p>    k[s] := k[s]+1;     <p>  end;     <p>  mn := N+1;     <p>  for i:=0 to 27 do begin        <p>     if (k[i]&gt;0) and (k[i]&lt;=mn) then begin       <p>         mn := k[i];           <p>         imn := i;        <p>     end;   <p>  end;        <p>  write(imn); <p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><pre><p>import java.util.Scanner;<p> </p><p>public class P27B {<p>\tpublic static void main(String[] args) {<p>\t\tScanner in = new Scanner(System.in);<p>\t\tint N = in.nextInt();<p>\t\tint k[] = new int[28];<p>\t\tfor (int i = 0; i &lt; N; ++i) {<p>\t\t\tint a = in.nextInt();<p>\t\t\tint s = a / 100 + a / 10 % 10 + a % 10;<p>\t\t\t++k[s];<p>\t\t}<p>\t\tint mn = N + 1;<p>\t\tint imn = 0;<p>\t\tfor (int i = 0; i &lt; k.length; ++i) {<p>\t\t\tif (k[i] &gt; 0 &amp;&amp; k[i] &lt;= mn) {<p>\t\t\t\tmn = k[i];<p>\t\t\t\timn = i;<p>\t\t\t}<p>\t\t}<p>\t\tSystem.out.print(imn);<p>\t}<p>}<p> </p><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p> </p><pre>var <p>  N: integer; {количество чисел}<p>  val: integer; {самая редкая сумма}<p>  a: array [1..10000] of integer;<p>  max_lenght: integer;<p>  i, j, k, lenght: integer;<p>begin<p>  readln(N);<p>  for i:=1 to N do read(a[i]);<p>  for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10 + a[i] div 100 mod 10;<p>  for i:=1 to N-1 do<p>    for j:=1 to N-i do<p>      if a[j] &lt; a[j+1] then begin<p>        k := a[j];<p>        a[j] := a[j+1];<p>       a[j+1] := k;<p>     end;<p>  max_lenght := N+1;<p>  lenght := 0;<p>  val := a[1];<p>  for i := 1 to N do <p>    if a[i]=a[i+1] then<p>     lenght := lenght + 1<p>    else begin<p>    if lenght<max_lenght begin<p=\"\" then=\"\">      max_lenght := lenght;<p>      val := a[i];<p>    end;<p>    lenght := 0;<p>    end;<p>  writeln(val);<p>end.</p></p></p></p></p></p></max_lenght></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 18 января 2017 года  Вариант ИН10304",
            "task_id": "13476"
        },
        {
            "answer": "Решение.Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести в порядке убывания индексы всех элементов, равных этому максимуму.Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) var    N: integer; {количество чисел}    a: integer; {очередное число}    digit: integer; {цифра числа}    d: array [0..9] of integer; {подсчёт цифр}    mx: integer; {максимальное количество цифр}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        while a>0 do begin                digit := a mod 10;                d[digit] := d[digit]+1;                a := a div 10;        end;    end;    mx := 0;    for i:=0 to 9 do begin        if d[i] > mx then mx := d[i];    end;    for i:=9 downto 0 do begin        if d[i]=mx then write(i, ' ');    end;end.Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    digit: integer; {количество всех цифер исходных чисел}    d: array [1..4000] of integer; {подсчёт цифр}    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    digit := 1;    for i := 1 to 4000 do d[i]:=0;    for i:= 1 to N do read(a[i]);    for i := 1 to N do      while a[i]<>0 do begin        d[digit] := a[i] mod 10;        digit := digit+1;        a[i] := a[i] div 10;      end;    for i :=1 to digit-1 do      for j:= 1 to digit-1-i do        if d[j]          k := d[j];          d[j] := d[j+1];          d[j+1] := k;        end;    max_lenght := 0;    lenght := 1;    for i := 1 to digit-1 do      if d[i]=d[i+1] then        lenght := lenght + 1      else begin      if lenght>max_lenght then begin      max_lenght := lenght;      end;      lenght := 1;      end;    lenght := 1;    for i := 1 to digit-1 do      if d[i]=d[i+1] then        lenght := lenght + 1      else begin        if lenght=max_lenght then write(d[i], ' ');        lenght := 1;      end;end.",
            "parsed": "2019-04-29 21:13:34.213086",
            "question": "Дан набор из N целых положительных чисел. Необходимо определить, какая цифра чаще всего встречается в десятичной записи чисел этого набора. Если таких цифр несколько, необходимо вывести их все в порядке убывания — от большей к меньшей.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000. Пример входных данных:3152532Пример выходных данных для приведённого выше примера входных данных:5 2 В десятичной записи чисел заданного набора чаще всего — по 2 раза — встречаются цифры 2 и 5, в ответе они выведены в порядке убывания.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940611\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Необходимо определить, какая цифра чаще всего встречается в десятичной записи чисел этого набора. Если таких цифр несколько, необходимо вывести их все в порядке убывания — от большей к меньшей.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">15<p class=\"left_margin\">25<p class=\"left_margin\">32<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">5 2<p> </p><p class=\"left_margin\">В десятичной записи чисел заданного набора чаще всего — по 2 раза — встречаются цифры 2 и 5, в ответе они выведены в порядке убывания.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести в порядке убывания индексы всех элементов, равных этому максимуму.Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) var    N: integer; {количество чисел}    a: integer; {очередное число}    digit: integer; {цифра числа}    d: array [0..9] of integer; {подсчёт цифр}    mx: integer; {максимальное количество цифр}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        while a>0 do begin                digit := a mod 10;                d[digit] := d[digit]+1;                a := a div 10;        end;    end;    mx := 0;    for i:=0 to 9 do begin        if d[i] > mx then mx := d[i];    end;    for i:=9 downto 0 do begin        if d[i]=mx then write(i, ' ');    end;end.Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    digit: integer; {количество всех цифер исходных чисел}    d: array [1..4000] of integer; {подсчёт цифр}    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    digit := 1;    for i := 1 to 4000 do d[i]:=0;    for i:= 1 to N do read(a[i]);    for i := 1 to N do      while a[i]<>0 do begin        d[digit] := a[i] mod 10;        digit := digit+1;        a[i] := a[i] div 10;      end;    for i :=1 to digit-1 do      for j:= 1 to digit-1-i do        if d[j]          k := d[j];          d[j] := d[j+1];          d[j+1] := k;        end;    max_lenght := 0;    lenght := 1;    for i := 1 to digit-1 do      if d[i]=d[i+1] then        lenght := lenght + 1      else begin      if lenght>max_lenght then begin      max_lenght := lenght;      end;      lenght := 1;      end;    lenght := 1;    for i := 1 to digit-1 do      if d[i]=d[i+1] then        lenght := lenght + 1      else begin        if lenght=max_lenght then write(d[i], ' ');        lenght := 1;      end;end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13503\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести в порядке убывания индексы всех элементов, равных этому максимуму.<p class=\"left_margin\">Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><pre><p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    digit: integer; {цифра числа}<p>    d: array [0..9] of integer; {подсчёт цифр}<p>    mx: integer; {максимальное количество цифр}<p>    i: integer;<p>begin<p>    for i:=0 to 9 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        while a&gt;0 do begin<p>                digit := a mod 10;<p>                d[digit] := d[digit]+1;<p>                a := a div 10;<p>        end;<p>    end;<p>    mx := 0;<p>    for i:=0 to 9 do begin<p>        if d[i] &gt; mx then mx := d[i];<p>    end;<p>    for i:=9 downto 0 do begin<p>        if d[i]=mx then write(i, ' ');<p>    end;<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p> </p><pre><p>var<p>    N: integer; {количество чисел}<p>    a: array [1..1000] of integer; {исходные данные}<p>    digit: integer; {количество всех цифер исходных чисел}<p>    d: array [1..4000] of integer; {подсчёт цифр}<p>    max_lenght: integer;<p>    i, j, k, lenght: integer;<p>begin<p>    readln(N);<p>    digit := 1;<p>    for i := 1 to 4000 do d[i]:=0;<p>    for i:= 1 to N do read(a[i]);<p>    for i := 1 to N do<p>      while a[i]&lt;&gt;0 do begin<p>        d[digit] := a[i] mod 10;<p>        digit := digit+1;<p>        a[i] := a[i] div 10;<p>      end;<p>    for i :=1 to digit-1 do<p>      for j:= 1 to digit-1-i do<p>        if d[j]<d[j+1] begin<p=\"\" then=\"\">          k := d[j];<p>          d[j] := d[j+1];<p>          d[j+1] := k;<p>        end;<p>    max_lenght := 0;<p>    lenght := 1;<p>    for i := 1 to digit-1 do<p>      if d[i]=d[i+1] then<p>        lenght := lenght + 1<p>      else begin<p>      if lenght&gt;max_lenght then begin<p>      max_lenght := lenght;<p>      end;<p>      lenght := 1;<p>      end;<p>    lenght := 1;<p>    for i := 1 to digit-1 do<p>      if d[i]=d[i+1] then<p>        lenght := lenght + 1<p>      else begin<p>        if lenght=max_lenght then write(d[i], ' ');<p>        lenght := 1;<p>      end;<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></d[j+1]></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 29 ноября 2016 года  Вариант ИН10203",
            "task_id": "13503"
        },
        {
            "answer": "Решение.Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести индекс этого элемента.Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) varN: integer; {количество чисел}    a: integer; {очередное число}    digit: integer; {цифра числа}    d: array [0..9] of integer; {подсчёт цифр}    dmx: integer; {самая частая цифра}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        while a>0 do begin            digit := a mod 10;            d[digit] := d[digit]+1;            a := a div 10;        end;    end;    dmx := 0;    for i:=1 to 9 do begin        if d[i] >= d[dmx] then dmx := i;    end;    writeln(dmx);end. Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    digit: integer; {количество всех цифер исходных чисел}    d: array [1..4000] of integer; {подсчёт цифр}    dmx: integer; {самая частая цифра}    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    digit := 1;    for i := 1 to 4000 do d[i]:=0;    for i:= 1 to N do read(a[i]);    for i := 1 to N do        while a[i]<>0 do begin            d[digit] := a[i] mod 10;            digit := digit+1;            a[i] := a[i] div 10;        end;    for i :=1 to digit-1 do        for j:= 1 to digit-1-i do            if d[j] < d[j+1] then begin                k := d[j];                d[j] := d[j+1];                d[j+1] := k;            end;    max_lenght := 0;    lenght := 1;    for i := 1 to digit-1 do        if d[i]=d[i+1] then            lenght := lenght + 1        else begin            if lenght>max_lenght then begin                max_lenght := lenght;                dmx := d[i];            end;            lenght := 1;        end;    writeln(dmx);end.",
            "parsed": "2019-04-29 21:13:34.728029",
            "question": "Дан набор из N целых положительных чисел. Необходимо определить, какая цифра чаще всего встречается в десятичной записи чисел этого набора. Если таких цифр несколько, необходимо вывести наибольшую из них.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.  Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000. Пример входных данных:3152532Пример выходных данных для приведённого выше примера входных данных:5В десятичной записи чисел заданного набора чаще всего — по 2 раза — встречаются цифры 2 и 5, большая из них — 5.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940582\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Необходимо определить, какая цифра чаще всего встречается в десятичной записи чисел этого набора. Если таких цифр несколько, необходимо вывести наибольшую из них.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. <p> </p><p class=\"left_margin\">Описание входных и выходных данных<p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p> </p><p><i>Пример входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">15<p class=\"left_margin\">25<p class=\"left_margin\">32<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">В десятичной записи чисел заданного набора чаще всего — по 2 раза — встречаются цифры 2 и 5, большая из них — 5.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести индекс этого элемента.Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) varN: integer; {количество чисел}    a: integer; {очередное число}    digit: integer; {цифра числа}    d: array [0..9] of integer; {подсчёт цифр}    dmx: integer; {самая частая цифра}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        while a>0 do begin            digit := a mod 10;            d[digit] := d[digit]+1;            a := a div 10;        end;    end;    dmx := 0;    for i:=1 to 9 do begin        if d[i] >= d[dmx] then dmx := i;    end;    writeln(dmx);end. Пример правильной, но неэффективной программы на языке Паскаль. var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    digit: integer; {количество всех цифер исходных чисел}    d: array [1..4000] of integer; {подсчёт цифр}    dmx: integer; {самая частая цифра}    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    digit := 1;    for i := 1 to 4000 do d[i]:=0;    for i:= 1 to N do read(a[i]);    for i := 1 to N do        while a[i]<>0 do begin            d[digit] := a[i] mod 10;            digit := digit+1;            a[i] := a[i] div 10;        end;    for i :=1 to digit-1 do        for j:= 1 to digit-1-i do            if d[j] < d[j+1] then begin                k := d[j];                d[j] := d[j+1];                d[j+1] := k;            end;    max_lenght := 0;    lenght := 1;    for i := 1 to digit-1 do        if d[i]=d[i+1] then            lenght := lenght + 1        else begin            if lenght>max_lenght then begin                max_lenght := lenght;                dmx := d[i];            end;            lenght := 1;        end;    writeln(dmx);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13530\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Необходимо создать массив из 10 элементов с индексами от 0 до 9 и использовать его для подсчёта количества всех цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести индекс этого элемента.<p class=\"left_margin\">Вместо массива можно использовать 10 отдельных переменных. В этом случае программа остаётся правильной и эффективной, но становится очень громоздкой, повышается вероятность ошибки. Если в проверяемой работе использован такой способ, эту работу следует проверить особенно тщательно.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><pre><p>var<p class=\"left_margin\">N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    digit: integer; {цифра числа}<p>    d: array [0..9] of integer; {подсчёт цифр}<p>    dmx: integer; {самая частая цифра}<p>    i: integer;<p>begin<p>    for i:=0 to 9 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        while a&gt;0 do begin<p>            digit := a mod 10;<p>            d[digit] := d[digit]+1;<p>            a := a div 10;<p>        end;<p>    end;<p>    dmx := 0;<p>    for i:=1 to 9 do begin<p>        if d[i] &gt;= d[dmx] then dmx := i;<p>    end;<p>    writeln(dmx);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p> </p><pre>var<p>    N: integer; {количество чисел}<p>    a: array [1..1000] of integer; {исходные данные}<p>    digit: integer; {количество всех цифер исходных чисел}<p>    d: array [1..4000] of integer; {подсчёт цифр}<p>    dmx: integer; {самая частая цифра}<p>    max_lenght: integer;<p>    i, j, k, lenght: integer;<p>begin<p>    readln(N);<p>    digit := 1;<p>    for i := 1 to 4000 do d[i]:=0;<p>    for i:= 1 to N do read(a[i]);<p>    for i := 1 to N do<p>        while a[i]&lt;&gt;0 do begin<p>            d[digit] := a[i] mod 10;<p>            digit := digit+1;<p>            a[i] := a[i] div 10;<p>        end;<p>    for i :=1 to digit-1 do<p>        for j:= 1 to digit-1-i do<p>            if d[j] &lt; d[j+1] then begin<p>                k := d[j];<p>                d[j] := d[j+1];<p>                d[j+1] := k;<p>            end;<p>    max_lenght := 0;<p>    lenght := 1;<p>    for i := 1 to digit-1 do<p>        if d[i]=d[i+1] then<p>            lenght := lenght + 1<p>        else begin<p>            if lenght&gt;max_lenght then begin<p>                max_lenght := lenght;<p>                dmx := d[i];<p>            end;<p>            lenght := 1;<p>        end;<p>    writeln(dmx);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 29 ноября 2016 года  Вариант ИН10204",
            "task_id": "13530"
        },
        {
            "answer": "Решение.Если сумма всех данных чисел не кратна 6, нужно просто взять все числа.Если сумма кратна 6, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 6. Если таких чисел нет (все числа в наборе кратны 6), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 6, а далее действовать по описанным выше правилам.Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC) const    d=6; {делитель}    amax = 10000; {максимально возможное число}var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма}    mn: integer; {минимальное число, не кратное d}    k: integer; {количество выбранных чисел}    i: integer;begin    readln(N);    s := 0;    mn := amax+1;    for i:=1 to N do begin        readln(a);        s := s+a;        if (a mod d <> 0) and (a < mn)            then mn := a;    end;    if s mod d <> 0 then k := N    else if mn <= amax then begin        k := N-1;        s := s - mn;    end    else begin        k := 0;        s := 0;    end;    writeln(k, ' ', s);end. Пример правильной, но неэффективной программы на языке Паскаль.var    N: integer; {количество чисел}    val: integer; {сумма выбранного количества чисел}    a: array [1..1000] of integer;    count: integer; {количество выбранных чисел}    i, j, k: integer;begin    readln(N);    val := 0;    for i:=1 to N do read(a[i]);    for i:=1 to N do val:=val+a[i];    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    count := N;    while (val mod 6 = 0) do begin        if a[count] mod 6 <> 0 then            val := val - a[count];        count := count - 1;        if count = 0 then begin            val := 0;            break;        end;    end;    writeln(count, ' ', val);end.",
            "parsed": "2019-04-29 21:13:35.122137",
            "question": "Дан набор из N целых положительных чисел. Необходимо выбрать из набора произвольное количество чисел так, чтобы их сумма была как можно больше и при этом не делилась на 6. В ответе нужно указать количество выбранных чисел и их сумму, сами числа выводить не надо. Если получить нужную сумму невозможно, считается, что выбрано 0 чисел и их сумма равна 0.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетовряющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:3123В результате работы программа должна вывести два числа: сначала количество выбранных чисел, затем их сумму.Пример выходных данных для приведённого выше примера входных данных:2 5В данном случае из предложенного набора нужно выбрать два числа (2 и 3), их сумма равна 5.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940553\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Необходимо выбрать из набора произвольное количество чисел так, чтобы их сумма была как можно больше и при этом не делилась на 6. В ответе нужно указать количество выбранных чисел и их сумму, сами числа выводить не надо. Если получить нужную сумму невозможно, считается, что выбрано 0 чисел и их сумма равна 0.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайт и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетовряющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\">Описание входных и выходных данных<p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p><i>Пример входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">3<p class=\"left_margin\">В результате работы программа должна вывести два числа: сначала количество выбранных чисел, затем их сумму.<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">2 5<p class=\"left_margin\">В данном случае из предложенного набора нужно выбрать два числа (2 и 3), их сумма равна 5.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Если сумма всех данных чисел не кратна 6, нужно просто взять все числа.Если сумма кратна 6, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 6. Если таких чисел нет (все числа в наборе кратны 6), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 6, а далее действовать по описанным выше правилам.Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC) const    d=6; {делитель}    amax = 10000; {максимально возможное число}var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма}    mn: integer; {минимальное число, не кратное d}    k: integer; {количество выбранных чисел}    i: integer;begin    readln(N);    s := 0;    mn := amax+1;    for i:=1 to N do begin        readln(a);        s := s+a;        if (a mod d <> 0) and (a < mn)            then mn := a;    end;    if s mod d <> 0 then k := N    else if mn <= amax then begin        k := N-1;        s := s - mn;    end    else begin        k := 0;        s := 0;    end;    writeln(k, ' ', s);end. Пример правильной, но неэффективной программы на языке Паскаль.var    N: integer; {количество чисел}    val: integer; {сумма выбранного количества чисел}    a: array [1..1000] of integer;    count: integer; {количество выбранных чисел}    i, j, k: integer;begin    readln(N);    val := 0;    for i:=1 to N do read(a[i]);    for i:=1 to N do val:=val+a[i];    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    count := N;    while (val mod 6 = 0) do begin        if a[count] mod 6 <> 0 then            val := val - a[count];        count := count - 1;        if count = 0 then begin            val := 0;            break;        end;    end;    writeln(count, ' ', val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13557\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Если сумма всех данных чисел не кратна 6, нужно просто взять все числа.<p class=\"left_margin\">Если сумма кратна 6, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 6. Если таких чисел нет (все числа в наборе кратны 6), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.<p class=\"left_margin\">Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 6, а далее действовать по описанным выше правилам.<p class=\"left_margin\">Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><pre><p>const<p>    d=6; {делитель}<p>    amax = 10000; {максимально возможное число}<p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    s: integer; {сумма}<p>    mn: integer; {минимальное число, не кратное d}<p>    k: integer; {количество выбранных чисел}<p>    i: integer;<p>begin<p>    readln(N);<p>    s := 0;<p>    mn := amax+1;<p>    for i:=1 to N do begin<p>        readln(a);<p>        s := s+a;<p>        if (a mod d &lt;&gt; 0) and (a &lt; mn)<p>            then mn := a;<p>    end;<p>    if s mod d &lt;&gt; 0 then k := N<p>    else if mn &lt;= amax then begin<p>        k := N-1;<p>        s := s - mn;<p>    end<p>    else begin<p>        k := 0;<p>        s := 0;<p>    end;<p>    writeln(k, ' ', s);<p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p><tt><p>var<p>    N: integer; {количество чисел}<p>    val: integer; {сумма выбранного количества чисел}<p>    a: array [1..1000] of integer;<p>    count: integer; {количество выбранных чисел}<p>    i, j, k: integer;<p>begin<p>    readln(N);<p>    val := 0;<p>    for i:=1 to N do read(a[i]);<p>    for i:=1 to N do val:=val+a[i];<p>    for i:=1 to N-1 do<p>        for j:=1 to N-i do<p>            if a[j] &lt; a[j+1] then begin<p>                k := a[j];<p>                a[j] := a[j+1];<p>                a[j+1] := k;<p>            end;<p>    count := N;<p>    while (val mod 6 = 0) do begin<p>        if a[count] mod 6 &lt;&gt; 0 then<p>            val := val - a[count];<p>        count := count - 1;<p>        if count = 0 then begin<p>            val := 0;<p>            break;<p>        end;<p>    end;<p>    writeln(count, ' ', val);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 30 сентября 2016 года  Вариант ИН10103",
            "task_id": "13557"
        },
        {
            "answer": "Решение.Если сумма всех данных чисел не кратна 8, нужно просто взять все числа.Если сумма кратна 8, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 8. Если таких чисел нет (все числа в наборе кратны 8), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 8, а далее действовать по описанным выше правилам.Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC) const    d=8; {делитель}    amax = 10000; {максимально возможное число}var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма}    mn: integer; {минимальное число, не кратное d}    k: integer; {количество выбранных чисел}    i: integer;begin    readln(N);    s := 0;    mn := amax+1;    for i:=1 to N do begin      readln(a);      s := s+a;      if (a mod d <> 0) and (a < mn)        then mn := a;    end;    if s mod d <> 0 then k := N    else if mn <= amax then begin      k := N-1;      s := s - mn;    end    else begin      k := 0;      s := 0;    end;    writeln(k, ' ', s);end. Пример правильной, но неэффективной программы на языке Паскаль.var    N: integer; {количество чисел}    val: integer; {сумма выбранного количества чисел}    a: array [1..1000] of integer;    count: integer; {количество выбранных чисел}    i, j, k: integer;begin    readln(N);    val := 0;    for i:=1 to N do read(a[i]);    for i:=1 to N do val:=val+a[i];    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    count := N;    while (val mod 8 = 0) do begin        if a[count] mod 8 <> 0 then            val := val - a[count];        count := count - 1;        if count = 0 then begin            val := 0;            break;        end;    end;    writeln(count, ' ', val);end.",
            "parsed": "2019-04-29 21:13:35.539681",
            "question": "Дан набор из N целых положительных чисел. Необходимо выбрать из набора произвольное количество чисел так, чтобы их сумма была как можно больше и при этом не делилась на 8. В ответе нужно указать количество выбранных чисел и их сумму, сами числа выводить не надо. Если получить нужную сумму невозможно, считается, что выбрано 0 чисел и их сумма равна 0.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:3125В результате работы программа должна вывести два числа: сначала количество выбранных чисел, затем их сумму.Пример выходных данных для приведённого выше примера входных данных:2 7В данном случае из предложенного набора нужно выбрать два числа (2 и 5), их сумма равна 7.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body941036\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Необходимо выбрать из набора произвольное количество чисел так, чтобы их сумма была как можно больше и при этом не делилась на 8. В ответе нужно указать количество выбранных чисел и их сумму, сами числа выводить не надо. Если получить нужную сумму невозможно, считается, что выбрано 0 чисел и их сумма равна 0.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайт и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\">Описание входных и выходных данных<p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p><i>Пример входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">5<p class=\"left_margin\">В результате работы программа должна вывести два числа: сначала количество выбранных чисел, затем их сумму.<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">2 7<p class=\"left_margin\">В данном случае из предложенного набора нужно выбрать два числа (2 и 5), их сумма равна 7.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Если сумма всех данных чисел не кратна 8, нужно просто взять все числа.Если сумма кратна 8, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 8. Если таких чисел нет (все числа в наборе кратны 8), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 8, а далее действовать по описанным выше правилам.Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC) const    d=8; {делитель}    amax = 10000; {максимально возможное число}var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма}    mn: integer; {минимальное число, не кратное d}    k: integer; {количество выбранных чисел}    i: integer;begin    readln(N);    s := 0;    mn := amax+1;    for i:=1 to N do begin      readln(a);      s := s+a;      if (a mod d <> 0) and (a < mn)        then mn := a;    end;    if s mod d <> 0 then k := N    else if mn <= amax then begin      k := N-1;      s := s - mn;    end    else begin      k := 0;      s := 0;    end;    writeln(k, ' ', s);end. Пример правильной, но неэффективной программы на языке Паскаль.var    N: integer; {количество чисел}    val: integer; {сумма выбранного количества чисел}    a: array [1..1000] of integer;    count: integer; {количество выбранных чисел}    i, j, k: integer;begin    readln(N);    val := 0;    for i:=1 to N do read(a[i]);    for i:=1 to N do val:=val+a[i];    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    count := N;    while (val mod 8 = 0) do begin        if a[count] mod 8 <> 0 then            val := val - a[count];        count := count - 1;        if count = 0 then begin            val := 0;            break;        end;    end;    writeln(count, ' ', val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13584\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Если сумма всех данных чисел не кратна 8, нужно просто взять все числа.<p class=\"left_margin\">Если сумма кратна 8, нужно удалить из неё минимально возможный элемент — наименьшее из заданных чисел, не кратное 8. Если таких чисел нет (все числа в наборе кратны 8), то получить требуемую сумму невозможно, в этом случае по условию задачи ответ считается равным нулю.<p class=\"left_margin\">Программа должна прочитать все числа, не сохраняя их, подсчитать общую сумму и определить наименьшее число, не кратное 8, а далее действовать по описанным выше правилам.<p class=\"left_margin\">Ниже приведена реализующая этот алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><pre><p>const<p>    d=8; {делитель}<p>    amax = 10000; {максимально возможное число}<p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    s: integer; {сумма}<p>    mn: integer; {минимальное число, не кратное d}<p>    k: integer; {количество выбранных чисел}<p>    i: integer;<p>begin<p>    readln(N);<p>    s := 0;<p>    mn := amax+1;<p>    for i:=1 to N do begin<p>      readln(a);<p>      s := s+a;<p>      if (a mod d &lt;&gt; 0) and (a &lt; mn)<p>        then mn := a;<p>    end;<p>    if s mod d &lt;&gt; 0 then k := N<p>    else if mn &lt;= amax then begin<p>      k := N-1;<p>      s := s - mn;<p>    end<p>    else begin<p>      k := 0;<p>      s := 0;<p>    end;<p>    writeln(k, ' ', s);<p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль.<p><tt><p>var<p>    N: integer; {количество чисел}<p>    val: integer; {сумма выбранного количества чисел}<p>    a: array [1..1000] of integer;<p>    count: integer; {количество выбранных чисел}<p>    i, j, k: integer;<p>begin<p>    readln(N);<p>    val := 0;<p>    for i:=1 to N do read(a[i]);<p>    for i:=1 to N do val:=val+a[i];<p>    for i:=1 to N-1 do<p>        for j:=1 to N-i do<p>            if a[j] &lt; a[j+1] then begin<p>                k := a[j];<p>                a[j] := a[j+1];<p>                a[j+1] := k;<p>            end;<p>    count := N;<p>    while (val mod 8 = 0) do begin<p>        if a[count] mod 8 &lt;&gt; 0 then<p>            val := val - a[count];<p>        count := count - 1;<p>        if count = 0 then begin<p>            val := 0;<p>            break;<p>        end;<p>    end;<p>    writeln(count, ' ', val);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 30 сентября 2016 года  Вариант ИН10104",
            "task_id": "13584"
        },
        {
            "answer": "Решение.При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму и сам максимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке ПаскальvarN: integer; {количество чисел}a: integer; {очередное число}d: array[1..8] of integer; {подсчет}mx: integer; {максимальное количество}imx: integer; {самая частая длина}i,k: integer;beginfor i:=1 to 8 do d[i]:=0;readln(N);for i:=1 to N do beginreadln(a);k:=0;while a>0 do begink := k+1;a := a div 10;end;d[k] := d[k]+1;end;mx := 0;for i:=1 to 8 do beginif d[i] >= mx then beginmx := d[i];imx := i;end;end;writeln(imx, ' ', mx)end. Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая частая длина}    a: array [1..1000] of integer;    max_lenght: integer; {максимальное количество чисел}    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do begin        k:=0;        while a[i]>0 do begin            k:=k+1;            a[i] := a[i] div 10;        end;        a[i]:=k;    end;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] :=             end;    max_lenght := 0;    lenght := 1;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght>max_lenght then begin            max_lenght := lenght;            val := a[i];            lenght := 1;        end;    writeln(val, ' ', max_lenght);    end. Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:if a<10 then k:=1else if a<100 then k:=2else if a<1000 then k:=3else if a<10000 then k:=4else if a<100000 then k:=5else if a<1000000 then k:=6else if a<10000000 then k:=7else k:=8;Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66)Пример правильной и эффективной программы на языке Javaimport java.util.Scanner;public class Problem27a {public static void main(String args[]){Scanner scan = new Scanner(System.in);import java.util.Scanner;import java.lang.String;public class problem27a {public static void main(String args[]){Scanner scan = new Scanner(System.in);int N; // количество чиселString a; // очередное число КАК СТРОКАint d[] = new int[9]; // подсчет чисел данной длиныint mx; // максимальное количество в dint imx=0; // самая частая длинаint i, k;for (i = 1; i < 9; i++) {d[i] = 0;}N = scan.nextInt();for (i = 1; i <= N; i++) {a = scan.next();k = a.length();d[k] = d[k]+1;}mx = 0;for (i=1; i< 9;i++)if (d[i] >= mx) {mx = d[i];imx = i;}System.out.println(imx+\" \"+mx);}}",
            "parsed": "2019-04-29 21:13:36.011264",
            "question": "Назовём длиной числа количество цифр в его десятичной записи. Например, длина числа 2017 равна 4, а длина числа 7 равна 1. Дан набор из N целых положительных чисел, каждое из которых меньше 108. Необходимо определить, числа какой длины чаще всего встречаются в данном наборе и сколько в нём чисел этой длины. Если числа разной длины встречаются одинаково часто (и чаще чем числа любой другой длины), нужно выбрать большую длину. Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).  В каждой из последующих N строк записано одно натуральное число, меньшее, чем 108. Пример входных данных:515417125324801Пример выходных данных для приведённого выше примера входных данных:3 2В данном наборе чаще всего (по 2 раза) встречаются числа длины 2 и 3. Выбираем большую длину, выводим саму длину (3) и количество чисел этой длины (2).",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body941015\" width=\"100%\"><p class=\"left_margin\">Назовём длиной числа количество цифр в его десятичной записи. Например, длина числа 2017 равна 4, а длина числа 7 равна 1. Дан набор из N целых положительных чисел, каждое из которых меньше 10<sup>8</sup>. Необходимо определить, числа какой длины чаще всего встречаются в данном наборе и сколько в нём чисел этой длины. Если числа разной длины встречаются одинаково часто (и чаще чем числа любой другой длины), нужно выбрать большую длину. Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. <p><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).  В каждой из последующих N строк записано одно натуральное число, меньшее, чем 10<sup>8</sup>. Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">15<p class=\"left_margin\">417<p class=\"left_margin\">125<p class=\"left_margin\">32<p class=\"left_margin\">4801<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">3 2<p class=\"left_margin\">В данном наборе чаще всего (по 2 раза) встречаются числа длины 2 и 3. Выбираем большую длину, выводим саму длину (3) и количество чисел этой длины (2).</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму и сам максимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке ПаскальvarN: integer; {количество чисел}a: integer; {очередное число}d: array[1..8] of integer; {подсчет}mx: integer; {максимальное количество}imx: integer; {самая частая длина}i,k: integer;beginfor i:=1 to 8 do d[i]:=0;readln(N);for i:=1 to N do beginreadln(a);k:=0;while a>0 do begink := k+1;a := a div 10;end;d[k] := d[k]+1;end;mx := 0;for i:=1 to 8 do beginif d[i] >= mx then beginmx := d[i];imx := i;end;end;writeln(imx, ' ', mx)end. Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая частая длина}    a: array [1..1000] of integer;    max_lenght: integer; {максимальное количество чисел}    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do begin        k:=0;        while a[i]>0 do begin            k:=k+1;            a[i] := a[i] div 10;        end;        a[i]:=k;    end;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] :=             end;    max_lenght := 0;    lenght := 1;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght>max_lenght then begin            max_lenght := lenght;            val := a[i];            lenght := 1;        end;    writeln(val, ' ', max_lenght);    end. Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:if a<10 then k:=1else if a<100 then k:=2else if a<1000 then k:=3else if a<10000 then k:=4else if a<100000 then k:=5else if a<1000000 then k:=6else if a<10000000 then k:=7else k:=8;Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66)Пример правильной и эффективной программы на языке Javaimport java.util.Scanner;public class Problem27a {public static void main(String args[]){Scanner scan = new Scanner(System.in);import java.util.Scanner;import java.lang.String;public class problem27a {public static void main(String args[]){Scanner scan = new Scanner(System.in);int N; // количество чиселString a; // очередное число КАК СТРОКАint d[] = new int[9]; // подсчет чисел данной длиныint mx; // максимальное количество в dint imx=0; // самая частая длинаint i, k;for (i = 1; i < 9; i++) {d[i] = 0;}N = scan.nextInt();for (i = 1; i <= N; i++) {a = scan.next();k = a.length();d[k] = d[k]+1;}mx = 0;for (i=1; i< 9;i++)if (d[i] >= mx) {mx = d[i];imx = i;}System.out.println(imx+\" \"+mx);}}",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13611\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму и сам максимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль<p>var<p class=\"left_margin\">N: integer; {количество чисел}<p>a: integer; {очередное число}<p>d: array[1..8] of integer; {подсчет}<p>mx: integer; {максимальное количество}<p>imx: integer; {самая частая длина}<p>i,k: integer;<p>begin<p>for i:=1 to 8 do d[i]:=0;<p>readln(N);<p>for i:=1 to N do begin<p>readln(a);<p>k:=0;<p>while a&gt;0 do begin<p>k := k+1;<p>a := a div 10;<p>end;<p>d[k] := d[k]+1;<p>end;<p>mx := 0;<p>for i:=1 to 8 do begin<p>if d[i] &gt;= mx then begin<p>mx := d[i];<p>imx := i;<p>end;<p>end;<p>writeln(imx, ' ', mx)<p>end.<p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль<p>var <p>    N: integer; {количество чисел}<p>    val: integer; {самая частая длина}<p>    a: array [1..1000] of integer;<p>    max_lenght: integer; {максимальное количество чисел}<p>    i, j, k, lenght: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do read(a[i]);<p>    for i:=1 to N do begin<p>        k:=0;<p>        while a[i]&gt;0 do begin<p>            k:=k+1;<p>            a[i] := a[i] div 10;<p>        end;<p>        a[i]:=k;<p>    end;<p>    for i:=1 to N-1 do<p>        for j:=1 to N-i do<p>            if a[j] &lt; a[j+1] then begin<p>                k := a[j];<p>                a[j] := a[j+1];<p>                a[j+1] :=             end;<p>    max_lenght := 0;<p>    lenght := 1;<p>    val := a[1];<p>    for i := 1 to N do<p>        if a[i]=a[i+1] then<p>            lenght := lenght + 1<p>        else if lenght&gt;max_lenght then begin<p>            max_lenght := lenght;<p>            val := a[i];<p>            lenght := 1;<p>        end;<p>    writeln(val, ' ', max_lenght);<p>    end.<p> </p><p class=\"left_margin\">Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:<p>if a&lt;10 then k:=1<p>else if a&lt;100 then k:=2<p>else if a&lt;1000 then k:=3<p>else if a&lt;10000 then k:=4<p>else if a&lt;100000 then k:=5<p>else if a&lt;1000000 then k:=6<p>else if a&lt;10000000 then k:=7<p>else k:=8;<p class=\"left_margin\">Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66)<p class=\"left_margin\">Пример правильной и эффективной программы на языке Java<p>import java.util.Scanner;<p>public class Problem27a {<p>public static void main(String args[]){<p class=\"left_margin\">Scanner scan = new Scanner(System.in);<p>import java.util.Scanner;<p>import java.lang.String;<p>public class problem27a {<p>public static void main(String args[]){<p class=\"left_margin\">Scanner scan = new Scanner(System.in);<p>int N; // количество чисел<p class=\"left_margin\">String a; // очередное число КАК СТРОКА<p>int d[] = new int[9]; // подсчет чисел данной длины<p>int mx; // максимальное количество в d<p>int imx=0; // самая частая длина<p>int i, k;<p>for (i = 1; i &lt; 9; i++) {d[i] = 0;}<p class=\"left_margin\">N = scan.nextInt();<p>for (i = 1; i &lt;= N; i++) {<p>a = scan.next();<p>k = a.length();<p>d[k] = d[k]+1;<p>}<p>mx = 0;<p>for (i=1; i&lt; 9;i++)<p>if (d[i] &gt;= mx) {<p>mx = d[i];<p>imx = i;<p>}<p class=\"left_margin\">System.out.println(imx+\" \"+mx);<p>}<p>}</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 12 мая 2017 года  Вариант ИН10503",
            "task_id": "13611"
        },
        {
            "answer": "Решение.При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму, и сам минимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке ПаскальvarN: integer; {количество чисел}a: longint; {очередное число}d: array[1..8] of integer; {подсчет}mn: integer; {минимальное количество}imn: integer; {самая редкая длина}i,k: integer;beginfor i:=1 to 8 do d[i]:=0;readln(N);for i:=1 to N do beginreadln(a);k:=0;while a>0 do begink := k+1;a := a div 10;end;d[k] := d[k]+1;end;mn := N+1;for i:=1 to 8 do beginif (d[i] < mn) and (d[i] > 0) then beginmn := d[i];imn := i;end;end;writeln(imn, ' ', mn)end. Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}    val: integer; {самая редкая длина}    a: array [1..1000] of integer;    min_lenght: integer; {минимальное количество}    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do begin        k:=0;        while a[i]>0 do begin            k:=k+1;            a[i] := a[i] div 10;        end;        a[i]:=k;    end;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j]>a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    min_lenght := N+1;    lenght := 1;    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght < min_lenght then begin            min_lenght := lenght;            val := a[i];            lenght := 1;        end;    writeln(val, ' ', min_lenght);end. Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:if a<10 then k:=1else if a<100 then k:=2else if a<1000 then k:=3else if a<10000 then k:=4else if a<100000 then k:=5else if a<1000000 then k:=6else if a<10000000 then k:=7else k:=8;Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66) Пример правильной и эффективной программы на языке Javaimport java.util.Scanner;import java.lang.String;public class problem27b {public static void main(String args[]){Scanner scan = new Scanner(System.in);int N; // количество чиселString a; // очередное число КАК СТРОКАint d[] = new int[9]; // подсчет чисел данной длиныint mn; // минимальное количество в dint imn=0; // самая редкая длинаint i, k;for (i = 1; i < 9; i++) {d[i] = 0;}N = scan.nextInt();for (i = 1; i <= N; i++) {a = scan.next();k = a.length();d[k] = d[k]+1;}mn = N+1;for (i=1; i<9; i++)if ((d[i] < mn) && (d[i]>0)) {mn = d[i];imn = i;}System.out.println(imn+\" \"+mn);}}",
            "parsed": "2019-04-29 21:13:36.445050",
            "question": "Назовём длиной числа количество цифр в его десятичной записи. Например, длина числа 2017 равна 4, а длина числа 7 равна 1.Дан набор из N целых положительных чисел, каждое из которых меньше 108. Необходимо определить, числа какой длины реже всего (но не менее одного раза) встречаются в данном наборе и сколько в нём чисел этой длины. Если числа разной длины встречаются одинаково часто (и реже, чем числа любой другой длины), нужно выбрать меньшую длину. Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N. Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число,меньшее, чем 108.Пример входных данных:5124171253274801Пример выходных данных для приведённого выше примера входных данных:2 1В данном наборе реже всего (по 1 разу) встречаются числа длины 2 и 4.Выбираем меньшую длину, выводим саму длину (2) и количество чисел этой длины (1).",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940986\" width=\"100%\"><p class=\"left_margin\">Назовём длиной числа количество цифр в его десятичной записи. Например, длина числа 2017 равна 4, а длина числа 7 равна 1.<p class=\"left_margin\">Дан набор из N целых положительных чисел, каждое из которых меньше 10<sup>8</sup>. Необходимо определить, числа какой длины реже всего (но не менее одного раза) встречаются в данном наборе и сколько в нём чисел этой длины. Если числа разной длины встречаются одинаково часто (и реже, чем числа любой другой длины), нужно выбрать меньшую длину. Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N. Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число,<p>меньшее, чем 10<sup>8</sup>.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">12<p class=\"left_margin\">417<p class=\"left_margin\">125<p class=\"left_margin\">327<p class=\"left_margin\">4801<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">2 1<p class=\"left_margin\">В данном наборе реже всего (по 1 разу) встречаются числа длины 2 и 4.<p class=\"left_margin\">Выбираем меньшую длину, выводим саму длину (2) и количество чисел этой длины (1).</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму, и сам минимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке ПаскальvarN: integer; {количество чисел}a: longint; {очередное число}d: array[1..8] of integer; {подсчет}mn: integer; {минимальное количество}imn: integer; {самая редкая длина}i,k: integer;beginfor i:=1 to 8 do d[i]:=0;readln(N);for i:=1 to N do beginreadln(a);k:=0;while a>0 do begink := k+1;a := a div 10;end;d[k] := d[k]+1;end;mn := N+1;for i:=1 to 8 do beginif (d[i] < mn) and (d[i] > 0) then beginmn := d[i];imn := i;end;end;writeln(imn, ' ', mn)end. Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}    val: integer; {самая редкая длина}    a: array [1..1000] of integer;    min_lenght: integer; {минимальное количество}    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do begin        k:=0;        while a[i]>0 do begin            k:=k+1;            a[i] := a[i] div 10;        end;        a[i]:=k;    end;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j]>a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    min_lenght := N+1;    lenght := 1;    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght < min_lenght then begin            min_lenght := lenght;            val := a[i];            lenght := 1;        end;    writeln(val, ' ', min_lenght);end. Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:if a<10 then k:=1else if a<100 then k:=2else if a<1000 then k:=3else if a<10000 then k:=4else if a<100000 then k:=5else if a<1000000 then k:=6else if a<10000000 then k:=7else k:=8;Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66) Пример правильной и эффективной программы на языке Javaimport java.util.Scanner;import java.lang.String;public class problem27b {public static void main(String args[]){Scanner scan = new Scanner(System.in);int N; // количество чиселString a; // очередное число КАК СТРОКАint d[] = new int[9]; // подсчет чисел данной длиныint mn; // минимальное количество в dint imn=0; // самая редкая длинаint i, k;for (i = 1; i < 9; i++) {d[i] = 0;}N = scan.nextInt();for (i = 1; i <= N; i++) {a = scan.next();k = a.length();d[k] = d[k]+1;}mn = N+1;for (i=1; i<9; i++)if ((d[i] < mn) && (d[i]>0)) {mn = d[i];imn = i;}System.out.println(imn+\" \"+mn);}}",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13638\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">При заданных ограничениях числа в наборе могут иметь длину от 1 до 8. Необходимо создать массив из 8 элементов с индексами от 1 до 8 и использовать его для подсчёта количества чисел соответствующей длины. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму, и сам минимум. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль<p>var<p class=\"left_margin\">N: integer; {количество чисел}<p>a: longint; {очередное число}<p>d: array[1..8] of integer; {подсчет}<p>mn: integer; {минимальное количество}<p>imn: integer; {самая редкая длина}<p>i,k: integer;<p>begin<p>for i:=1 to 8 do d[i]:=0;<p>readln(N);<p>for i:=1 to N do begin<p>readln(a);<p>k:=0;<p>while a&gt;0 do begin<p>k := k+1;<p>a := a div 10;<p>end;<p>d[k] := d[k]+1;<p>end;<p>mn := N+1;<p>for i:=1 to 8 do begin<p>if (d[i] &lt; mn) and (d[i] &gt; 0) then begin<p>mn := d[i];<p>imn := i;<p>end;<p>end;<p>writeln(imn, ' ', mn)<p>end.<p> </p><p class=\"left_margin\">Пример правильной, но неэффективной программы на языке Паскаль<p>var<p>    N: integer; {количество чисел}<p>    val: integer; {самая редкая длина}<p>    a: array [1..1000] of integer;<p>    min_lenght: integer; {минимальное количество}<p>    i, j, k, lenght: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do read(a[i]);<p>    for i:=1 to N do begin<p>        k:=0;<p>        while a[i]&gt;0 do begin<p>            k:=k+1;<p>            a[i] := a[i] div 10;<p>        end;<p>        a[i]:=k;<p>    end;<p>    for i:=1 to N-1 do<p>        for j:=1 to N-i do<p>            if a[j]&gt;a[j+1] then begin<p>                k := a[j];<p>                a[j] := a[j+1];<p>                a[j+1] := k;<p>            end;<p>    min_lenght := N+1;<p>    lenght := 1;<p>    for i := 1 to N do<p>        if a[i]=a[i+1] then<p>            lenght := lenght + 1<p>        else if lenght &lt; min_lenght then begin<p>            min_lenght := lenght;<p>            val := a[i];<p>            lenght := 1;<p>        end;<p>    writeln(val, ' ', min_lenght);<p>end.<p> </p><p class=\"left_margin\">Вместо определения количества цифр с помощью последовательного деления на 10 можно использовать выбор по диапазону допустимых значений. Например, в приведённой выше программе можно вместо присваивания k:=0 и следующего за ним цикла while использовать такую последовательность действий:<p>if a&lt;10 then k:=1<p>else if a&lt;100 then k:=2<p>else if a&lt;1000 then k:=3<p>else if a&lt;10000 then k:=4<p>else if a&lt;100000 then k:=5<p>else if a&lt;1000000 then k:=6<p>else if a&lt;10000000 then k:=7<p>else k:=8;<p class=\"left_margin\">Можно также преобразовывать число в строку или сразу читать его как строку и определять длину числа как длину соответствующей строки. Ниже приведена такая программа на языке Java (использована версия JDK 1.8.0_66)<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Java<p>import java.util.Scanner;<p>import java.lang.String;<p>public class problem27b {<p>public static void main(String args[]){<p class=\"left_margin\">Scanner scan = new Scanner(System.in);<p>int N; // количество чисел<p class=\"left_margin\">String a; // очередное число КАК СТРОКА<p>int d[] = new int[9]; // подсчет чисел данной длины<p>int mn; // минимальное количество в d<p>int imn=0; // самая редкая длина<p>int i, k;<p>for (i = 1; i &lt; 9; i++) {d[i] = 0;}<p class=\"left_margin\">N = scan.nextInt();<p>for (i = 1; i &lt;= N; i++) {<p>a = scan.next();<p>k = a.length();<p>d[k] = d[k]+1;<p>}<p>mn = N+1;<p>for (i=1; i&lt;9; i++)<p>if ((d[i] &lt; mn) &amp;&amp; (d[i]&gt;0)) {<p>mn = d[i];<p>imn = i;<p>}<p class=\"left_margin\">System.out.println(imn+\" \"+mn);<p>}<p>}</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Тренировочная работа по ИНФОРМАТИКЕ 11 класс 12 мая 2017 года  Вариант ИН10504",
            "task_id": "13638"
        },
        {
            "answer": "Решение.ПАСКАЛЬvar points, npupils, mean:array[1..100] of integer; ch:char;i,N, school,p,k, max:integer;beginfor i:=1 to 100 do {обнуляем массивы} beginpoints[i]:= 0; mean[i]:=0;npupils[i]:=0;end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';{считано имя}readln(school,p); {считали номер школы и балл ученика}points[school]:=points[school] + p; {накапиливаем балл учеников для расчёта среднего в дальнейшем}npupils[school]:=npupils[school] + 1; {накапливаем количество учеников в школе}end;for i:=1 to 100 do {Вычисляем средний балл в каждой школе с точностью до целого}beginmean[i]:= points[i] div npupils[i];end;max:=-1;for i:=1 to 100 do {Находим школы с наибольшим средним баллом и запоминаем их количество}beginif mean[i]>max then beginmax:=mean[i];k:=1;endelse if mean[i]=max then begink:=k+1;end;end;if k > 1 thenbeginwriteln('Всего школ:', k);writeln('Наибольший средний балл =', max);endelsebeginwriteln('Школа с лучшим средним баллом');writeln('Наибольший средний балл =', max);end;end. Приводим решение Валентина Добрингского на C++. #include  using namespace std; void main(){const int size = 99; struct base{int amount;int sum;}; base s[size]; int N = 0;int tmp=0;int count=0;int max=0;int j = 0;char surname[30]; name[20]; cin >> N;for (int i = 0; i < size; i++){s[i].amount = 0;s[i].sum = 0;} for (int i = 0; i < N; i++){cin >> surname >> name >> j >> tmp;s[j-1].amount++;s[j-1].sum = s[j-1].sum + tmp;} for (int i = 0; i < size; i++){if (max < s[i].sum){max = s[i].sum;count = 1;tmp = i;}if (max == s[i].sum)count++;} if (count == 1)cout<<\"Nomer school: \"<<<\"Sredniy ball: \"<elsecout << \"Kol-vo school: \" << count << endl<< \"Sredniy ball: \" << max / s[tmp].amount << endl; system(\"pause\");}",
            "parsed": "2019-04-29 21:14:20.611810",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.Программа должна вывести на экран номер такой школы и её средний балл.Если наибольший средний балл набрало больше одной школы — вывести количество таких школ и средний балл. Всего школ не более ста, школы нумеруются последовательно, начиная с единицы.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:  <Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).Пример входной строки: Иванов Иван 50 87Пример выходных данных: Школа с лучшим средним баллом 10 Наибольший средний балл = 84Другой вариант выходных данных: Всего школ: 3Наибольший средний балл = 78",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940924\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.<p class=\"left_margin\">Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.<p class=\"left_margin\">Программа должна вывести на экран номер такой школы и её средний балл.<p class=\"left_margin\">Если наибольший средний балл набрало больше одной школы — вывести количество таких школ и средний балл. Всего школ не более ста, школы нумеруются последовательно, начиная с единицы.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. <p class=\"left_margin\">На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt;<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. <p class=\"left_margin\">Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87<p><i>Пример выходных данных:</i> <p class=\"left_margin\">Школа с лучшим средним баллом 10 <p class=\"left_margin\">Наибольший средний балл = 84<p><i>Другой вариант выходных данных:</i> <p class=\"left_margin\">Всего школ: 3<p class=\"left_margin\">Наибольший средний балл = 78</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬvar points, npupils, mean:array[1..100] of integer; ch:char;i,N, school,p,k, max:integer;beginfor i:=1 to 100 do {обнуляем массивы} beginpoints[i]:= 0; mean[i]:=0;npupils[i]:=0;end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';{считано имя}readln(school,p); {считали номер школы и балл ученика}points[school]:=points[school] + p; {накапиливаем балл учеников для расчёта среднего в дальнейшем}npupils[school]:=npupils[school] + 1; {накапливаем количество учеников в школе}end;for i:=1 to 100 do {Вычисляем средний балл в каждой школе с точностью до целого}beginmean[i]:= points[i] div npupils[i];end;max:=-1;for i:=1 to 100 do {Находим школы с наибольшим средним баллом и запоминаем их количество}beginif mean[i]>max then beginmax:=mean[i];k:=1;endelse if mean[i]=max then begink:=k+1;end;end;if k > 1 thenbeginwriteln('Всего школ:', k);writeln('Наибольший средний балл =', max);endelsebeginwriteln('Школа с лучшим средним баллом');writeln('Наибольший средний балл =', max);end;end. Приводим решение Валентина Добрингского на C++. #include  using namespace std; void main(){const int size = 99; struct base{int amount;int sum;}; base s[size]; int N = 0;int tmp=0;int count=0;int max=0;int j = 0;char surname[30]; name[20]; cin >> N;for (int i = 0; i < size; i++){s[i].amount = 0;s[i].sum = 0;} for (int i = 0; i < N; i++){cin >> surname >> name >> j >> tmp;s[j-1].amount++;s[j-1].sum = s[j-1].sum + tmp;} for (int i = 0; i < size; i++){if (max < s[i].sum){max = s[i].sum;count = 1;tmp = i;}if (max == s[i].sum)count++;} if (count == 1)cout<<\"Nomer school: \"<<<\"Sredniy ball: \"<elsecout << \"Kol-vo school: \" << count << endl<< \"Sredniy ball: \" << max / s[tmp].amount << endl; system(\"pause\");}",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13696\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p>var points, npupils, mean:array[1..100] of integer; <p>ch:char;<p>i,N, school,p,k, max:integer;<p>begin<p>for i:=1 to 100 do {обнуляем массивы} <p>begin<p>points[i]:= 0; <p>mean[i]:=0;<p>npupils[i]:=0;<p>end;<p>readln(N); {считали количество строк} <p>for i:=1 to N do {перебираем все входные строки} <p>begin <p>repeat<p>read(ch)<p>until ch=' ';{считана фамилия} <p>repeat<p>read(ch) until ch=' ';{считано имя}<p>readln(school,p); {считали номер школы и балл ученика}<p>points[school]:=points[school] + p; {накапиливаем балл учеников для расчёта среднего в дальнейшем}<p>npupils[school]:=npupils[school] + 1; {накапливаем количество учеников в школе}<p>end;<p>for i:=1 to 100 do {Вычисляем средний балл в каждой школе с точностью до целого}<p>begin<p>mean[i]:= points[i] div npupils[i];<p>end;<p>max:=-1;<p>for i:=1 to 100 do {Находим школы с наибольшим средним баллом и запоминаем их количество}<p>begin<p>if mean[i]&gt;max then <p>begin<p>max:=mean[i];<p>k:=1;<p>end<p>else if mean[i]=max then <p>begin<p>k:=k+1;<p>end;<p>end;<p>if k &gt; 1 then<p>begin<p>writeln('Всего школ:', k);<p>writeln('Наибольший средний балл =', max);<p>end<p>else<p>begin<p>writeln('Школа с лучшим средним баллом');<p>writeln('Наибольший средний балл =', max);<p>end;<p>end.<p> </p><p><b>Приводим решение Валентина Добрингского на C++.</b><p> </p><p>#include <iostream><p> <p>using namespace std;<p> <p>void main()<p>{<p>const int size = 99;<p> <p>struct base<p>{<p>int amount;<p>int sum;<p>};<p> <p>base s[size];<p> <p>int N = 0;<p>int tmp=0;<p>int count=0;<p>int max=0;<p>int j = 0;<p>char surname[30]; name[20];<p> <p>cin &gt;&gt; N;<p>for (int i = 0; i &lt; size; i++)<p>{<p>s[i].amount = 0;<p>s[i].sum = 0;<p>}<p> <p>for (int i = 0; i &lt; N; i++)<p>{<p>cin &gt;&gt; surname &gt;&gt; name &gt;&gt; j &gt;&gt; tmp;<p>s[j-1].amount++;<p>s[j-1].sum = s[j-1].sum + tmp;<p>}<p> <p>for (int i = 0; i &lt; size; i++)<p>{<p>if (max &lt; s[i].sum)<p>{<p>max = s[i].sum;<p>count = 1;<p>tmp = i;<p>}<p>if (max == s[i].sum)<p>count++;<p>}<p> <p>if (count == 1)<p>cout&lt;&lt;\"Nomer school: \"&lt;<tmp +=\"\" 1<<endl<p=\"\">&lt;&lt;\"Sredniy ball: \"&lt;<max <<endl;<p=\"\" s[tmp].amount=\"\">else<p>cout &lt;&lt; \"Kol-vo school: \" &lt;&lt; count &lt;&lt; endl<p>&lt;&lt; \"Sredniy ball: \" &lt;&lt; max / s[tmp].amount &lt;&lt; endl;<p> <p>system(\"pause\");<p>}</p></p></p></p></p></max></tmp></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></iostream></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: РЕШУ ЕГЭ",
            "task_id": "13696"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 26, если выполнено одно из следующих условий (условия не могут выполняться одновременно).А. Оба сомножителя делятся на 26.Б. Один из сомножителей делится на 26, а другой не делится.В. Ни один из сомножителей не делится на 26, но один сомножитель делится на 2, а другой – на 13.Примечание для проверяющего. Условие делимости произведения на 26 можно сформулировать проще, например, так: (один из сомножителей делится на 26) ИЛИ (один сомножитель делится на 2, а другой – на 13). Но в этом случае пара сомножителей может удовлетворять обоим условиям, что затруднит подсчёт количества пар.При вводе чисел можно определять, делится ли каждое из них на 26, 2 и 13, и подсчитывать следующие значения:1) n26 – количество чисел, кратных 26;2) n13 – количество чисел, кратных 13, но не кратных 26;3) n2 – количество чисел, кратных 2, но не кратных 26.Примечание для проверяющего. Сами числа при этом можно не хранить. Каждое число учитывается не более чем в одном из счётчиков. Количество пар, удовлетворяющих условию А, можно вычислить по формуле n26·(n26 – 1)/2.Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n26·(N – n26). Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2·n13.Поэтому искомое количество пар вычисляется по формуле n26·(n26 – 1)/2 + n26·(N – n26) + n2·n13.Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC)  Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памятиvar     N: integer; {количество чисел}      a: integer; {очередное число}      n26, n13, n2: integer;      k26: integer; {количество требуемых пар}      i: integer; begin     readln(N);     n26:=0; n13:=0; n2:=0;     for i:=1 to N do begin          readln(a);          if a mod 26 = 0 then              n26 := n26+1        else if a mod 13 = 0 then             n13 := n13 + 1         else if a mod 2 = 0 then             n2 := n2 + 1;     end;     k26 := n26*(n26-1) div 2 + n26*(N-n26) + n2*n13;     writeln(k26)end.  Пример 2. Программа на языке Паскаль. Программа не эффективна по времени и по памятиvar N: integer;    a: array[1..1000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 26 = 0 then                k := k + 1;        writeln(k)end. Комментарии для проверяющего1. При таком решении каждое прочитанное число обрабатывается (делаются проверки делимости, изменяются счётчики) и после этого не хранится. Таким образом, используемая память не зависит от длины последовательности. Время обработки очередного числа фиксировано, т. е. не зависит от длины последовательности. Время заключительных вычислений по приведённой в решении формуле также не зависит от длины последовательности. Поэтому при увеличении длины последовательности в k раз время работы программы увеличивается не более чем в k раз. Таким образом, приведённая выше программа эффективна как по времени, так и по используемой памяти. Это решение оценивается 4 баллами.2. Общая идея решения, эффективного по времени, состоит в следующем. Просматриваем по очереди все элементы последовательности и накапливаем значения вспомогательных величин (в приведённом решении это счётчики n2, n13, n26). После того как вся последовательность обработана и подсчитаны окончательные значения вспомогательных величин, по этим значениям подсчитывается искомое количество пар. При этом можно использовать и другие вспомогательные величины. Например, можно вместо n2 и n13 использовать величины p2 и p13 – количества чисел, которые делятся соответственно на 2 и на 13. Так как n2 = p2 – n26 и n13 = p13 – n26, то итоговая формула примет вид: n26·(n26 – 1)/2 + n26·(N – n26) + (p2 – n26)·(p13 – n26).  Ещё один возможный вариант (есть и другие!) – подсчёт количества чисел, которые не делятся на 26, – можно вести по формуле n2+n13+nx, где nx – количество чисел, которые не делятся ни на 2, ни на 13. Значение nx можно вычислить с  помощью отдельного счётчика. Такая программа на языке Бейсик приведена ниже. Все подобные программы оцениваются в 4 балла. При любом наборе вспомогательных величин возможны различные способы записи итоговой формулы. Можно, например, раскрывать скобки и приводить подобные члены или, наоборот, выносить за скобки общие множители; можно вводить дополнительные переменные для отдельных слагаемых, а затем вычислять их сумму. Допустим любой способ записи вычислений, эквивалентный правильной формуле, выбранный способ записине влияет на оценку.3. Возможно решение, основанное на описанных идеях, однако предварительно сохраняющее элементы последовательности в массив. Такое решение (если в нём нет ошибок) эффективно по времени, но неэффективно по памяти. Оно оценивается в 3 балла.4. Решение, не эффективное ни по времени, ни по памяти, запоминает входную последовательность в массиве, после чего явно перебирает все возможные пары. Такое решение оценивается в 2 балла (см. критерии)  Пример 2. Программа на языке Бейсик. Программа эффективна по времени и по памяти, но использует формулы, отличные от формул программы из примера 1  N26 = 0N2 = 0N13 = 0NX = 0INPUT NFOR I = 1 TO N     INPUT AIF A MOD 26 = 0 THEN         N26 = N26 + 1     ELSE         IF A MOD 13 = 0 THEN             N13 = N13 + 1         ELSE             IF A MOD 2 = 0 THEN                 N2 = N2 + 1             ELSE NX = NX + 1             END IF         END IF     END IFNEXT IK26 = N26*(N26-1)\\2 + N26*(N2+N13+NX) + N2*N13PRINT K26 ",
            "parsed": "2019-04-29 21:13:36.771590",
            "question": "На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов делится на 26. Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов кратно 26. Пример входных данных:4 2 6 13 39 Пример выходных данных для приведённого выше примера входных данных: 4 Пояснение. Из четырёх заданных чисел можно составить 6 попарных произведений: 2·6, 2·13, 2·39, 6·13, 6·39, 13·39 (результаты: 12, 26, 78, 78, 234, 507). Из них на 26 делятся 4 произведения (2·13=26; 2·39=78; 6·13=78; 6·39=234). Требуется написать эффективную по времени и по памяти программу для решения описанной задачи. Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N. Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную только по времени – 3 балла. Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла. Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940870\" width=\"100%\"><p class=\"left_margin\">На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов делится на 26. <p><b>Описание входных и выходных данных </b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов кратно 26. <p><i>Пример входных данных</i>:<p class=\"left_margin\">4 <p class=\"left_margin\">2 <p class=\"left_margin\">6 <p class=\"left_margin\">13 <p class=\"left_margin\">39 <p><i>Пример выходных данных для приведённого выше примера входных данных</i>: <p class=\"left_margin\">4 <p><i>Пояснение.</i> Из четырёх заданных чисел можно составить 6 попарных произведений: 2·6, 2·13, 2·39, 6·13, 6·39, 13·39 (результаты: 12, 26, 78, 78, 234, 507). Из них на 26 делятся 4 произведения (2·13=26; 2·39=78; 6·13=78; 6·39=234). <p class=\"left_margin\">Требуется написать эффективную по времени и по памяти программу для решения описанной задачи. <p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. <p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N. <p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени – 3 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла. <p class=\"left_margin\">Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. <p class=\"left_margin\">Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 26, если выполнено одно из следующих условий (условия не могут выполняться одновременно).А. Оба сомножителя делятся на 26.Б. Один из сомножителей делится на 26, а другой не делится.В. Ни один из сомножителей не делится на 26, но один сомножитель делится на 2, а другой – на 13.Примечание для проверяющего. Условие делимости произведения на 26 можно сформулировать проще, например, так: (один из сомножителей делится на 26) ИЛИ (один сомножитель делится на 2, а другой – на 13). Но в этом случае пара сомножителей может удовлетворять обоим условиям, что затруднит подсчёт количества пар.При вводе чисел можно определять, делится ли каждое из них на 26, 2 и 13, и подсчитывать следующие значения:1) n26 – количество чисел, кратных 26;2) n13 – количество чисел, кратных 13, но не кратных 26;3) n2 – количество чисел, кратных 2, но не кратных 26.Примечание для проверяющего. Сами числа при этом можно не хранить. Каждое число учитывается не более чем в одном из счётчиков. Количество пар, удовлетворяющих условию А, можно вычислить по формуле n26·(n26 – 1)/2.Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n26·(N – n26). Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2·n13.Поэтому искомое количество пар вычисляется по формуле n26·(n26 – 1)/2 + n26·(N – n26) + n2·n13.Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC)  Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памятиvar     N: integer; {количество чисел}      a: integer; {очередное число}      n26, n13, n2: integer;      k26: integer; {количество требуемых пар}      i: integer; begin     readln(N);     n26:=0; n13:=0; n2:=0;     for i:=1 to N do begin          readln(a);          if a mod 26 = 0 then              n26 := n26+1        else if a mod 13 = 0 then             n13 := n13 + 1         else if a mod 2 = 0 then             n2 := n2 + 1;     end;     k26 := n26*(n26-1) div 2 + n26*(N-n26) + n2*n13;     writeln(k26)end.  Пример 2. Программа на языке Паскаль. Программа не эффективна по времени и по памятиvar N: integer;    a: array[1..1000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 26 = 0 then                k := k + 1;        writeln(k)end. Комментарии для проверяющего1. При таком решении каждое прочитанное число обрабатывается (делаются проверки делимости, изменяются счётчики) и после этого не хранится. Таким образом, используемая память не зависит от длины последовательности. Время обработки очередного числа фиксировано, т. е. не зависит от длины последовательности. Время заключительных вычислений по приведённой в решении формуле также не зависит от длины последовательности. Поэтому при увеличении длины последовательности в k раз время работы программы увеличивается не более чем в k раз. Таким образом, приведённая выше программа эффективна как по времени, так и по используемой памяти. Это решение оценивается 4 баллами.2. Общая идея решения, эффективного по времени, состоит в следующем. Просматриваем по очереди все элементы последовательности и накапливаем значения вспомогательных величин (в приведённом решении это счётчики n2, n13, n26). После того как вся последовательность обработана и подсчитаны окончательные значения вспомогательных величин, по этим значениям подсчитывается искомое количество пар. При этом можно использовать и другие вспомогательные величины. Например, можно вместо n2 и n13 использовать величины p2 и p13 – количества чисел, которые делятся соответственно на 2 и на 13. Так как n2 = p2 – n26 и n13 = p13 – n26, то итоговая формула примет вид: n26·(n26 – 1)/2 + n26·(N – n26) + (p2 – n26)·(p13 – n26).  Ещё один возможный вариант (есть и другие!) – подсчёт количества чисел, которые не делятся на 26, – можно вести по формуле n2+n13+nx, где nx – количество чисел, которые не делятся ни на 2, ни на 13. Значение nx можно вычислить с  помощью отдельного счётчика. Такая программа на языке Бейсик приведена ниже. Все подобные программы оцениваются в 4 балла. При любом наборе вспомогательных величин возможны различные способы записи итоговой формулы. Можно, например, раскрывать скобки и приводить подобные члены или, наоборот, выносить за скобки общие множители; можно вводить дополнительные переменные для отдельных слагаемых, а затем вычислять их сумму. Допустим любой способ записи вычислений, эквивалентный правильной формуле, выбранный способ записине влияет на оценку.3. Возможно решение, основанное на описанных идеях, однако предварительно сохраняющее элементы последовательности в массив. Такое решение (если в нём нет ошибок) эффективно по времени, но неэффективно по памяти. Оно оценивается в 3 балла.4. Решение, не эффективное ни по времени, ни по памяти, запоминает входную последовательность в массиве, после чего явно перебирает все возможные пары. Такое решение оценивается в 2 балла (см. критерии)  Пример 2. Программа на языке Бейсик. Программа эффективна по времени и по памяти, но использует формулы, отличные от формул программы из примера 1  N26 = 0N2 = 0N13 = 0NX = 0INPUT NFOR I = 1 TO N     INPUT AIF A MOD 26 = 0 THEN         N26 = N26 + 1     ELSE         IF A MOD 13 = 0 THEN             N13 = N13 + 1         ELSE             IF A MOD 2 = 0 THEN                 N2 = N2 + 1             ELSE NX = NX + 1             END IF         END IF     END IFNEXT IK26 = N26*(N26-1)\\2 + N26*(N2+N13+NX) + N2*N13PRINT K26 ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol13754\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 26, если выполнено одно из следующих условий (условия не могут выполняться одновременно).<p class=\"left_margin\">А. Оба сомножителя делятся на 26.<p class=\"left_margin\">Б. Один из сомножителей делится на 26, а другой не делится.<p class=\"left_margin\">В. Ни один из сомножителей не делится на 26, но один сомножитель делится на 2, а другой – на 13.<p class=\"left_margin\">Примечание для проверяющего. Условие делимости произведения на 26 можно сформулировать проще, например, так: (один из сомножителей делится на 26) ИЛИ (один сомножитель делится на 2, а другой – на 13). Но в этом случае пара сомножителей может удовлетворять обоим условиям, что затруднит подсчёт количества пар.<p class=\"left_margin\">При вводе чисел можно определять, делится ли каждое из них на 26, 2 и 13, и подсчитывать следующие значения:<p class=\"left_margin\">1) n26 – количество чисел, кратных 26;<p class=\"left_margin\">2) n13 – количество чисел, кратных 13, но не кратных 26;<p class=\"left_margin\">3) n2 – количество чисел, кратных 2, но не кратных 26.<p class=\"left_margin\">Примечание для проверяющего. Сами числа при этом можно не хранить. Каждое число учитывается не более чем в одном из счётчиков. Количество пар, удовлетворяющих условию А, можно вычислить по формуле n26·(n26 – 1)/2.<p class=\"left_margin\">Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n26·(N – n26). <p class=\"left_margin\">Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2·n13.<p class=\"left_margin\">Поэтому искомое количество пар вычисляется по формуле n26·(n26 – 1)/2 + n26·(N – n26) + n2·n13.<p class=\"left_margin\">Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC) <p> </p><p class=\"left_margin\"><b>Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памяти</b><p><tt><p>var<p>     N: integer; {количество чисел}<p>      a: integer; {очередное число}<p>      n26, n13, n2: integer;<p>      k26: integer; {количество требуемых пар}<p>      i: integer;<p> </p><p>begin<p>     readln(N);<p>     n26:=0; n13:=0; n2:=0;<p>     for i:=1 to N do begin<p>          readln(a);<p>          if a mod 26 = 0 then<p>              n26 := n26+1<p>        else if a mod 13 = 0 then<p>             n13 := n13 + 1<p>         else if a mod 2 = 0 then<p>             n2 := n2 + 1;<p>     end;<p>     k26 := n26*(n26-1) div 2 + n26*(N-n26) + n2*n13;<p>     writeln(k26)<p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p><b>Пример 2. Программа на языке Паскаль. Программа не эффективна по времени и по памяти</b><p><tt><p>var N: integer;<p>    a: array[1..1000] of integer;<p>    i, j, k: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do read(a[i]);<p>    k:= 0;<p>    for i:= 1 to N-1 do<p>        for j:= i+1 to N do<p>            if a[i]*a[j] mod 26 = 0 then<p>                k := k + 1;<p>        writeln(k)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p><b>Комментарии для проверяющего</b><p class=\"left_margin\">1. При таком решении каждое прочитанное число обрабатывается (делаются проверки делимости, изменяются счётчики) и после этого не хранится. Таким образом, используемая память не зависит от длины последовательности. Время обработки очередного числа фиксировано, т. е. не зависит от длины последовательности. Время заключительных вычислений по приведённой в решении формуле также не зависит от длины последовательности. Поэтому при увеличении длины последовательности в k раз время работы программы увеличивается не более чем в k раз. Таким образом, приведённая выше программа эффективна как по времени, так и по используемой памяти. Это решение оценивается 4 баллами.<p class=\"left_margin\">2. Общая идея решения, эффективного по времени, состоит в следующем. Просматриваем по очереди все элементы последовательности и накапливаем значения вспомогательных величин (в приведённом решении это счётчики n2, n13, n26). После того как вся последовательность обработана и подсчитаны окончательные значения <p>вспомогательных величин, по этим значениям подсчитывается искомое количество пар. При этом можно использовать и другие вспомогательные величины. Например, можно вместо n2 и n13 использовать величины p2 и p13 – количества чисел, которые делятся соответственно на 2 и на 13. Так как n2 = p2 – n26 и n13 = p13 – n26, то итоговая формула примет вид: n26·(n26 – 1)/2 + n26·(N – n26) + (p2 – n26)·(p13 – n26).  Ещё один возможный вариант (есть и другие!) – подсчёт количества чисел, которые не делятся на 26, – можно вести по формуле n2+n13+nx, где nx – количество чисел, которые не делятся ни на 2, ни на 13. Значение nx можно вычислить с <p> помощью отдельного счётчика. Такая программа на языке Бейсик приведена ниже. Все подобные программы оцениваются в 4 балла. При любом наборе вспомогательных величин возможны различные способы записи итоговой формулы. Можно, например, раскрывать скобки и приводить подобные члены или, наоборот, выносить за скобки общие множители; можно вводить дополнительные переменные для отдельных слагаемых, а затем вычислять их сумму. Допустим любой способ записи вычислений, эквивалентный правильной формуле, выбранный способ записи<p>не влияет на оценку.<p class=\"left_margin\">3. Возможно решение, основанное на описанных идеях, однако предварительно сохраняющее элементы последовательности в массив. Такое решение (если в нём нет ошибок) эффективно по времени, но неэффективно по памяти. Оно оценивается в 3 балла.<p class=\"left_margin\">4. Решение, не эффективное ни по времени, ни по памяти, запоминает входную последовательность в массиве, после чего явно перебирает все возможные пары. Такое решение оценивается в 2 балла (см. критерии) <p> </p><p><b>Пример 2. Программа на языке Бейсик. Программа эффективна по времени и по памяти, но использует формулы, отличные от формул программы из примера 1 </b><p> </p><p><tt><p class=\"left_margin\">N26 = 0<p class=\"left_margin\">N2 = 0<p class=\"left_margin\">N13 = 0<p class=\"left_margin\">NX = 0<p class=\"left_margin\">INPUT N<p class=\"left_margin\">FOR I = 1 TO N<p>     INPUT A<p class=\"left_margin\">IF A MOD 26 = 0 THEN<p>         N26 = N26 + 1<p>     ELSE<p>         IF A MOD 13 = 0 THEN<p>             N13 = N13 + 1<p>         ELSE<p>             IF A MOD 2 = 0 THEN<p>                 N2 = N2 + 1<p>             ELSE NX = NX + 1<p>             END IF<p>         END IF<p>     END IF<p class=\"left_margin\">NEXT I<p class=\"left_margin\">K26 = N26*(N26-1)\\2 + N26*(N2+N13+NX) + N2*N13<p class=\"left_margin\">PRINT K26 <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Де­мон­стра­ци­он­ная вер­сия ЕГЭ—2018 по информатике.",
            "task_id": "13754"
        },
        {
            "answer": "Решение.Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма двух последних цифр}    d: array [0..18] of integer; {подсчёт сумм}    mx: integer; {максимальное количество сумм}    imx: integer; {самая частая сумма}    i: integer;begin    for i:=0 to 18 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        s := a mod 10 + a div 10 mod 10;        d[s] := d[s]+1;    end;    mx := 0;    for i:=0 to 18 do begin        if d[i] >= mx then begin            mx := d[i];            imx := i;            end;    writeln(imx)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке убывания, после чего найдём сумму, которая встречается чаще всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая частая сумма}    a: array [1..1000] of integer;    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    max_lenght := 0;    lenght := 0;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght>max_lenght then begin            max_lenght := lenght;            val := a[i];            lenght := 0;        end;    writeln(val);    end.",
            "parsed": "2019-04-29 21:13:37.346687",
            "question": "Дан набор из N целых положительных чисел. Для каждого числа вычисляется сумма двух последних цифр в его десятичной записи (для однозначных чисел предпоследняя цифра считается равной нулю). Необходимо определить,какая сумма при этом получается чаще всего. Если таких сумм несколько, необходимо вывести наибольшую из них.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличиваетсяне более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой,итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.Пример входных данных:51541712364841Пример выходных данных для приведённого выше примера входных данных:6Суммы двух последних цифр для чисел из данного набора равны 6, 8, 5, 6, 5.Чаще других (по два раза) встречаются 6 и 5, в ответе выводится бо́льшая из этих сумм.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940382\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Для каждого числа вычисляется сумма двух последних цифр в его десятичной записи (для однозначных чисел предпоследняя цифра считается равной нулю). Необходимо определить,<p>какая сумма при этом получается чаще всего. Если таких сумм несколько, необходимо вывести <b>наибольшую</b> из них.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается<p>не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать <b>одну</b> или <b>две</b> программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой,итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p> </p><p><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">15<p class=\"left_margin\">417<p class=\"left_margin\">123<p class=\"left_margin\">6<p class=\"left_margin\">4841<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">6<p class=\"left_margin\">Суммы двух последних цифр для чисел из данного набора равны 6, 8, 5, 6, 5.<p class=\"left_margin\">Чаще других (по два раза) встречаются 6 и 5, в ответе выводится бо́льшая из этих сумм.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма двух последних цифр}    d: array [0..18] of integer; {подсчёт сумм}    mx: integer; {максимальное количество сумм}    imx: integer; {самая частая сумма}    i: integer;begin    for i:=0 to 18 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        s := a mod 10 + a div 10 mod 10;        d[s] := d[s]+1;    end;    mx := 0;    for i:=0 to 18 do begin        if d[i] >= mx then begin            mx := d[i];            imx := i;            end;    writeln(imx)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке убывания, после чего найдём сумму, которая встречается чаще всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая частая сумма}    a: array [1..1000] of integer;    max_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] < a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    max_lenght := 0;    lenght := 0;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght>max_lenght then begin            max_lenght := lenght;            val := a[i];            lenght := 0;        end;    writeln(val);    end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol14242\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение максимального элемента этого массива и вывести максимальный из индексов элементов, равных этому максимуму.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p><tt><p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    s: integer; {сумма двух последних цифр}<p>    d: array [0..18] of integer; {подсчёт сумм}<p>    mx: integer; {максимальное количество сумм}<p>    imx: integer; {самая частая сумма}<p>    i: integer;<p>begin<p>    for i:=0 to 18 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        s := a mod 10 + a div 10 mod 10;<p>        d[s] := d[s]+1;<p>    end;<p>    mx := 0;<p>    for i:=0 to 18 do begin<p>        if d[i] &gt;= mx then begin<p>            mx := d[i];<p>            imx := i;<p>        <p>    end;<p>    writeln(imx)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке убывания, после чего найдём сумму, которая встречается чаще всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p class=\"left_margin\">var <p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    val: integer; {самая частая сумма}<p class=\"left_margin\">    a: array [1..1000] of integer;<p class=\"left_margin\">    max_lenght: integer;<p class=\"left_margin\">    i, j, k, lenght: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do read(a[i]);<p class=\"left_margin\">    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;<p class=\"left_margin\">    for i:=1 to N-1 do<p class=\"left_margin\">        for j:=1 to N-i do<p class=\"left_margin\">            if a[j] &lt; a[j+1] then begin<p class=\"left_margin\">                k := a[j];<p class=\"left_margin\">                a[j] := a[j+1];<p class=\"left_margin\">                a[j+1] := k;<p class=\"left_margin\">            end;<p class=\"left_margin\">    max_lenght := 0;<p class=\"left_margin\">    lenght := 0;<p class=\"left_margin\">    val := a[1];<p class=\"left_margin\">    for i := 1 to N do<p class=\"left_margin\">        if a[i]=a[i+1] then<p class=\"left_margin\">            lenght := lenght + 1<p class=\"left_margin\">        else if lenght&gt;max_lenght then begin<p class=\"left_margin\">            max_lenght := lenght;<p class=\"left_margin\">            val := a[i];<p class=\"left_margin\">            lenght := 0;<p class=\"left_margin\">        end;<p class=\"left_margin\">    writeln(val);<p class=\"left_margin\">    end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "14242"
        },
        {
            "answer": "Решение.Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального ненулевого элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма двух последних цифр}    d: array [0..18] of integer; {подсчёт сумм}    mn: integer; {максимальное количество сумм}    imn: integer; {самая частая сумма}    i: integer;begin    for i:=0 to 18 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        s := a mod 10 + a div 10 mod 10;        d[s] := d[s]+1;    end;    mn := N+1;    for i:=0 to 18 do begin        if (d[i]>0) and (d[i] < mn) then begin            mn := d[i];            imn := i;            end;    writeln(imn)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке возрастания, после чего найдём сумму, которая встречается реже всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая редкая сумма}    a: array [1..1000] of integer;    min_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] > a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    min_lenght := N+1;    lenght := 0;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght            min_lenght := lenght;            val := a[i];            lenght := 0;        end;    writeln(val);end.",
            "parsed": "2019-04-29 21:13:37.751218",
            "question": "Дан набор из N целых положительных чисел. Для каждого числа вычисляется сумма двух последних цифр в его десятичной записи (для однозначных чисел предпоследняя цифра считается равной нулю). Необходимо определить, какая сумма при этом получается реже всего (но не менее одного раза). Если таких сумм несколько, необходимо вывести наименьшую из них.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бóльшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию. Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.Пример входных данных:51441712334841Пример выходных данных для приведённого выше примера входных данных:3Суммы двух последних цифр для чисел из данного набора равны 5, 8, 5, 3, 5. Реже других (по одному разу) встречаются 8 и 3, в ответе выводится меньшая из этих сумм.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body940338\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Для каждого числа вычисляется сумма двух последних цифр в его десятичной записи (для однозначных чисел предпоследняя цифра считается равной нулю). Необходимо определить, какая сумма при этом получается реже всего (но не менее одного раза). Если таких сумм несколько, необходимо вывести наименьшую из них.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бóльшая из двух оценок. <p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p> </p><p><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">14<p class=\"left_margin\">417<p class=\"left_margin\">123<p class=\"left_margin\">3<p class=\"left_margin\">4841<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">Суммы двух последних цифр для чисел из данного набора равны 5, 8, 5, 3, 5. <p class=\"left_margin\">Реже других (по одному разу) встречаются 8 и 3, в ответе выводится меньшая из этих сумм.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального ненулевого элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) var    N: integer; {количество чисел}    a: integer; {очередное число}    s: integer; {сумма двух последних цифр}    d: array [0..18] of integer; {подсчёт сумм}    mn: integer; {максимальное количество сумм}    imn: integer; {самая частая сумма}    i: integer;begin    for i:=0 to 18 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        s := a mod 10 + a div 10 mod 10;        d[s] := d[s]+1;    end;    mn := N+1;    for i:=0 to 18 do begin        if (d[i]>0) and (d[i] < mn) then begin            mn := d[i];            imn := i;            end;    writeln(imn)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке возрастания, после чего найдём сумму, которая встречается реже всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar     N: integer; {количество чисел}    val: integer; {самая редкая сумма}    a: array [1..1000] of integer;    min_lenght: integer;    i, j, k, lenght: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;    for i:=1 to N-1 do        for j:=1 to N-i do            if a[j] > a[j+1] then begin                k := a[j];                a[j] := a[j+1];                a[j+1] := k;            end;    min_lenght := N+1;    lenght := 0;    val := a[1];    for i := 1 to N do        if a[i]=a[i+1] then            lenght := lenght + 1        else if lenght            min_lenght := lenght;            val := a[i];            lenght := 0;        end;    writeln(val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol14286\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Сумма двух цифр может принимать значения от 0 до 18. Необходимо создать массив из 19 элементов с индексами от 0 до 18 и использовать его для подсчёта количества чисел с соответствующими суммами двух последних цифр. Использование массива не делает программу неэффективной по памяти, так как размер массива не зависит от N. Затем нужно найти значение минимального ненулевого элемента этого массива и вывести минимальный из индексов элементов, равных этому минимуму.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p><tt><p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    s: integer; {сумма двух последних цифр}<p>    d: array [0..18] of integer; {подсчёт сумм}<p>    mn: integer; {максимальное количество сумм}<p>    imn: integer; {самая частая сумма}<p>    i: integer;<p>begin<p>    for i:=0 to 18 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        s := a mod 10 + a div 10 mod 10;<p>        d[s] := d[s]+1;<p>    end;<p>    mn := N+1;<p>    for i:=0 to 18 do begin<p>        if (d[i]&gt;0) and (d[i] &lt; mn) then begin<p>            mn := d[i];<p>            imn := i;<p>        <p>    end;<p>    writeln(imn)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, найдём суммы двух последних цифр этих чисел и отсортируем их в порядке возрастания, после чего найдём сумму, которая встречается реже всего. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p class=\"left_margin\">var <p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    val: integer; {самая редкая сумма}<p class=\"left_margin\">    a: array [1..1000] of integer;<p class=\"left_margin\">    min_lenght: integer;<p class=\"left_margin\">    i, j, k, lenght: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do read(a[i]);<p class=\"left_margin\">    for i:=1 to N do a[i] := a[i] mod 10 + a[i] div 10 mod 10;<p class=\"left_margin\">    for i:=1 to N-1 do<p class=\"left_margin\">        for j:=1 to N-i do<p class=\"left_margin\">            if a[j] &gt; a[j+1] then begin<p class=\"left_margin\">                k := a[j];<p class=\"left_margin\">                a[j] := a[j+1];<p class=\"left_margin\">                a[j+1] := k;<p class=\"left_margin\">            end;<p class=\"left_margin\">    min_lenght := N+1;<p class=\"left_margin\">    lenght := 0;<p class=\"left_margin\">    val := a[1];<p class=\"left_margin\">    for i := 1 to N do<p class=\"left_margin\">        if a[i]=a[i+1] then<p class=\"left_margin\">            lenght := lenght + 1<p class=\"left_margin\">        else if lenght<min_lenght begin<p=\"\" class=\"left_margin\" then=\"\">            min_lenght := lenght;<p class=\"left_margin\">            val := a[i];<p class=\"left_margin\">            lenght := 0;<p class=\"left_margin\">        end;<p class=\"left_margin\">    writeln(val);<p class=\"left_margin\">end.</p></p></p></p></p></min_lenght></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "14286"
        },
        {
            "answer": "Решение.Разобьём все числа исходного набора на 7 групп по значению остатка от деления на 7 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 7 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 7 элементов и программа получится эффективной по памяти. Чтобы сумма двух чисел делилась на 7, они оба должны делиться на 7 либо сумма их остатков от деления на 7 должна быть равна 7. Зная количество элементов для каждого остатка, можно определить количество пар.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..6] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 6 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 7])    end;    s := d[0]*(d[0]-1) div 2;    for i:=1 to 3 do s := s + d[i]*d[7-i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s :=0;    for i := 1 to N-1 do begin        for j := i+1 to N do begin            if (a[i]+a[j]) mod 7 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "parsed": "2019-04-29 21:13:38.147411",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 7.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксическихошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:5136111Пример выходных данных для приведённого выше примера входных данных:3Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 7: 1 + 6, 1 + 6 (в наборе две единицы, поэтому пару 1 + 6 можно составить двумя способами), 3 + 11.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body939909\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 7.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксическихошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. <p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\">Описание входных и выходных данных<p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000).<p class=\"left_margin\">В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">6<p class=\"left_margin\">11<p class=\"left_margin\">1<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 7: 1 + 6, 1 + 6 (в наборе две единицы, поэтому пару 1 + 6 можно составить двумя способами), 3 + 11.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Разобьём все числа исходного набора на 7 групп по значению остатка от деления на 7 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 7 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 7 элементов и программа получится эффективной по памяти. Чтобы сумма двух чисел делилась на 7, они оба должны делиться на 7 либо сумма их остатков от деления на 7 должна быть равна 7. Зная количество элементов для каждого остатка, можно определить количество пар.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..6] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 6 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 7])    end;    s := d[0]*(d[0]-1) div 2;    for i:=1 to 3 do s := s + d[i]*d[7-i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s :=0;    for i := 1 to N-1 do begin        for j := i+1 to N do begin            if (a[i]+a[j]) mod 7 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol14713\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Разобьём все числа исходного набора на 7 групп по значению остатка от деления на 7 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 7 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 7 элементов и программа получится эффективной по памяти. <p class=\"left_margin\">Чтобы сумма двух чисел делилась на 7, они оба должны делиться на 7 либо сумма их остатков от деления на 7 должна быть равна 7. Зная количество элементов для каждого остатка, можно определить количество пар.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p><tt><p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    d: array [0..6] of integer; {группы по остаткам}<p>    s: integer; {количество пар}<p>    i: integer;<p>begin<p>    for i:=0 to 6 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        inc(d[a mod 7])<p>    end;<p>    s := d[0]*(d[0]-1) div 2;<p>    for i:=1 to 3 do s := s + d[i]*d[7-i];<p>    writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p><tt><p>var<p>    N: integer; {количество чисел} <p>    a: array [1..1000] of integer; {исходные данные}<p>    s: integer; {количество пар}<p>    i,j: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do readln(a[i]);<p>    s :=0;<p>    for i := 1 to N-1 do begin<p>        for j := i+1 to N do begin<p>            if (a[i]+a[j]) mod 7 = 0<p>                then s := s + 1<p>        end<p>    end;<p>    writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: СтатГрад: Тре­ни­ро­воч­ная ра­бо­та 28.11.2017 ИН10203",
            "task_id": "14713"
        },
        {
            "answer": "Решение.Разобьём все числа исходного набора на 9 групп по значению остатка от деления на 9 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 9 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 9 элементов и программа получится эффективной по памяти.Чтобы сумма двух чисел делилась на 9, они оба должны делиться на 9 либо сумма их остатков от деления на 9 должна быть равна 9. Зная количество элементов для каждого остатка, можно определить количество пар.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..8] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 8 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 9])    end;    s := d[0]*(d[0]-1) div 2;    for i:=1 to 4 do s := s + d[i]*d[9-i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s :=0;    for i := 1 to N-1 do begin        for j := i+1 to N do begin            if (a[i]+a[j]) mod 9 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "parsed": "2019-04-29 21:13:38.557582",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 9.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:5435415 Пример выходных данных для приведённого выше примера входных данных:3 Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 9: 4 + 5, 4 + 5 (в наборе две четвёрки, поэтому пару 4 + 5 можно составить двумя способами), 3 + 15.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body939832\" width=\"100%\"><p class=\"left_margin\">Дан набор из N целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 9.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, – 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\">Описание входных и выходных данных<p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">15<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">3<p> </p><p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 9: 4 + 5, 4 + 5 (в наборе две четвёрки, поэтому пару 4 + 5 можно составить двумя способами), 3 + 15.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Разобьём все числа исходного набора на 9 групп по значению остатка от деления на 9 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 9 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 9 элементов и программа получится эффективной по памяти.Чтобы сумма двух чисел делилась на 9, они оба должны делиться на 9 либо сумма их остатков от деления на 9 должна быть равна 9. Зная количество элементов для каждого остатка, можно определить количество пар.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..8] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 8 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 9])    end;    s := d[0]*(d[0]-1) div 2;    for i:=1 to 4 do s := s + d[i]*d[9-i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s :=0;    for i := 1 to N-1 do begin        for j := i+1 to N do begin            if (a[i]+a[j]) mod 9 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol14788\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Разобьём все числа исходного набора на 9 групп по значению остатка от деления на 9 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 9 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит массива из 9 элементов и программа получится эффективной по памяти.<p class=\"left_margin\">Чтобы сумма двух чисел делилась на 9, они оба должны делиться на 9 либо сумма их остатков от деления на 9 должна быть равна 9. Зная количество элементов для каждого остатка, можно определить количество пар.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p><tt><p>var<p>    N: integer; {количество чисел}<p>    a: integer; {очередное число}<p>    d: array [0..8] of integer; {группы по остаткам}<p>    s: integer; {количество пар}<p>    i: integer;<p>begin<p>    for i:=0 to 8 do d[i]:=0;<p>    readln(N);<p>    for i:=1 to N do begin<p>        readln(a);<p>        inc(d[a mod 9])<p>    end;<p>    s := d[0]*(d[0]-1) div 2;<p>    for i:=1 to 4 do s := s + d[i]*d[9-i];<p>    writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p><tt><p>var<p>    N: integer; {количество чисел} <p>    a: array [1..1000] of integer; {исходные данные}<p>    s: integer; {количество пар}<p>    i,j: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do readln(a[i]);<p>    s :=0;<p>    for i := 1 to N-1 do begin<p>        for j := i+1 to N do begin<p>            if (a[i]+a[j]) mod 9 = 0<p>                then s := s + 1<p>        end<p>    end;<p>    writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "14788"
        },
        {
            "answer": "Решение.Чтобы сумма двух чисел делилась на 8, они оба должны делиться на 8 либо сумма их остатков от деления на 8 должна быть равна 8.Разобьём все числа исходного набора на 8 групп по значению остатка от деления на 8 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 8 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 8 элементов, и программа получится эффективной по памяти.Зная количество элементов для каждого остатка, можно определить количество подходящих пар. Для чисел с остатками 0 (числа, кратные 8) и 4 оба числа в паре должны быть в одной и той же группе. Если в группе k элементов, то количество пар равно k(k-1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 7, 2 и 6, 3 и 5), количество пар равно произведению количества элементов в соответствующих группах.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..7] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 7 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 8])    end;    s := (d[0] * (d[0]−1) + d[4] * (d[4] − 1)) div 2;    for i:=1 to 3 do s := s + d[i] * d[8−i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных  данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s := 0;    for i := 1 to N−1 do begin        for j := i + 1 to N do begin            if (a[i]+a[j]) mod 8 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "parsed": "2019-04-29 21:13:38.978439",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 8.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:5157111 Пример выходных данных для приведённого выше примера входных данных:3Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 8: 1 + 7, 1 + 7 (в наборе две единицы, поэтому пару 1 + 7 можно составить двумя способами), 5 + 11.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body939502\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 8.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">1<p class=\"left_margin\">5<p class=\"left_margin\">7<p class=\"left_margin\">11<p class=\"left_margin\">1<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">3<p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 8: 1 + 7, 1 + 7 (в наборе две единицы, поэтому пару 1 + 7 можно составить двумя способами), 5 + 11.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы сумма двух чисел делилась на 8, они оба должны делиться на 8 либо сумма их остатков от деления на 8 должна быть равна 8.Разобьём все числа исходного набора на 8 групп по значению остатка от деления на 8 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 8 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 8 элементов, и программа получится эффективной по памяти.Зная количество элементов для каждого остатка, можно определить количество подходящих пар. Для чисел с остатками 0 (числа, кратные 8) и 4 оба числа в паре должны быть в одной и той же группе. Если в группе k элементов, то количество пар равно k(k-1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 7, 2 и 6, 3 и 5), количество пар равно произведению количества элементов в соответствующих группах.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..7] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 7 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc(d[a mod 8])    end;    s := (d[0] * (d[0]−1) + d[4] * (d[4] − 1)) div 2;    for i:=1 to 3 do s := s + d[i] * d[8−i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных  данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной, но неэффективной программы на языке Паскальvar    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    s := 0;    for i := 1 to N−1 do begin        for j := i + 1 to N do begin            if (a[i]+a[j]) mod 8 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15122\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы сумма двух чисел делилась на 8, они оба должны делиться на 8 либо сумма их остатков от деления на 8 должна быть равна 8.<p class=\"left_margin\">Разобьём все числа исходного набора на 8 групп по значению остатка от деления на 8 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 8 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 8 элементов, и программа получится эффективной по памяти.<p class=\"left_margin\">Зная количество элементов для каждого остатка, можно определить количество подходящих пар. Для чисел с остатками 0 (числа, кратные 8) и 4 оба числа в паре должны быть в одной и той же группе. Если в группе <i>k</i> элементов, то количество пар равно <i>k</i>(<i>k</i>-1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 7, 2 и 6, 3 и 5), количество пар равно произведению количества элементов в соответствующих группах.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    d: array [0..7] of integer; {группы по остаткам}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    for i:=0 to 7 do d[i]:=0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        inc(d[a mod 8])<p class=\"left_margin\">    end;<p class=\"left_margin\">    s := (d[0] * (d[0]−1) + d[4] * (d[4] − 1)) div 2;<p class=\"left_margin\">    for i:=1 to 3 do s := s + d[i] * d[8−i];<p class=\"left_margin\">    writeln(s)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных  данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    s := 0;<p class=\"left_margin\">    for i := 1 to N−1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if (a[i]+a[j]) mod 8 = 0<p class=\"left_margin\">                then s := s + 1<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(s)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15122"
        },
        {
            "answer": "Решение.Чтобы сумма двух числе делилась на 10, они оба должны делиться на 10 либо сумма их остатков от деления на 10 должна быть равна 10.Разобьём все числа исходного набора на 10 групп по значению остатка от деления на 10 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 10 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 10 элементов, и программа получится эффективной по памяти.Зная количество элементов для каждого остатка, можно определить количество пар. Для чисел с остатками 0 (числа, кратные 10) и 5 оба числа в паре должны быть в одной и той же группе. Если в группе k элементов, то количество пар равно k(k−1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 9, 2 и 8, 3 и 7, 4 и 6), количество пар равно произведению количества элементов в соответствующих группах.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..9] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc (d[a mod 10])    end;    s := (d[0] * (d[0] − 1) + d[5] * (d[5] − 1)) div 2;    for i:=1 to 4 do s := s + d[i] * d[10 − i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if (a[i] + a[j]) mod 10 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "parsed": "2019-04-29 21:13:39.398346",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 10.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данныхВ первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:5456415Пример выходных данных для приведённого выше примера входных данных:3Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 10: 4 + 6, 4 + 6 (в наборе две четвёрки, поэтому пару 4 + 6 можно составить двумя способами), 5 + 15.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body939473\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из этих чисел формируются все возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляется сумма элементов. Необходимо определить количество пар, для которых полученная сумма делится на 10.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">5<p class=\"left_margin\">6<p class=\"left_margin\">4<p class=\"left_margin\">15<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае у трёх пар сумма делится на 10: 4 + 6, 4 + 6 (в наборе две четвёрки, поэтому пару 4 + 6 можно составить двумя способами), 5 + 15.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы сумма двух числе делилась на 10, они оба должны делиться на 10 либо сумма их остатков от деления на 10 должна быть равна 10.Разобьём все числа исходного набора на 10 групп по значению остатка от деления на 10 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 10 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 10 элементов, и программа получится эффективной по памяти.Зная количество элементов для каждого остатка, можно определить количество пар. Для чисел с остатками 0 (числа, кратные 10) и 5 оба числа в паре должны быть в одной и той же группе. Если в группе k элементов, то количество пар равно k(k−1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 9, 2 и 8, 3 и 7, 4 и 6), количество пар равно произведению количества элементов в соответствующих группах.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    d: array [0..9] of integer; {группы по остаткам}    s: integer; {количество пар}    i: integer;begin    for i:=0 to 9 do d[i]:=0;    readln(N);    for i:=1 to N do begin        readln(a);        inc (d[a mod 10])    end;    s := (d[0] * (d[0] − 1) + d[5] * (d[5] − 1)) div 2;    for i:=1 to 4 do s := s + d[i] * d[10 − i];    writeln(s)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if (a[i] + a[j]) mod 10 = 0                then s := s + 1        end    end;    writeln(s)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15149\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы сумма двух числе делилась на 10, они оба должны делиться на 10 либо сумма их остатков от деления на 10 должна быть равна 10.<p class=\"left_margin\">Разобьём все числа исходного набора на 10 групп по значению остатка от деления на 10 и подсчитаем количество чисел в каждой группе. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 10 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе после чтения исходных данных для хранения необходимой информации хватит массива из 10 элементов, и программа получится эффективной по памяти.<p class=\"left_margin\">Зная количество элементов для каждого остатка, можно определить количество пар. Для чисел с остатками 0 (числа, кратные 10) и 5 оба числа в паре должны быть в одной и той же группе. Если в группе <i>k</i> элементов, то количество пар равно <i>k</i>(<i>k</i>−1)/2. Для чисел с другими остатками группы разбиваются на пары (1 и 9, 2 и 8, 3 и 7, 4 и 6), количество пар равно произведению количества элементов в соответствующих группах.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    d: array [0..9] of integer; {группы по остаткам}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    for i:=0 to 9 do d[i]:=0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        inc (d[a mod 10])<p class=\"left_margin\">    end;<p class=\"left_margin\">    s := (d[0] * (d[0] − 1) + d[5] * (d[5] − 1)) div 2;<p class=\"left_margin\">    for i:=1 to 4 do s := s + d[i] * d[10 − i];<p class=\"left_margin\">    writeln(s)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    s := 0;<p class=\"left_margin\">    for i := 1 to N − 1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if (a[i] + a[j]) mod 10 = 0<p class=\"left_margin\">                then s := s + 1<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(s)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15149"
        },
        {
            "answer": "Решение.Решение эффективное по памяти и времени (Задача Б). Прямой вариант.Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, не кратных 2 и не кратных 17. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел не кратных 2 и не кратных 17. Тогда количество чисел будет равноk2*(k2-1)/2 + k17*(k17-1)/2 + k*(k-1)/2 + k2*k + k17*k Программа на языке Pascal.var k2, k17, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k17 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 34 <> 0 then begin            if x mod 2 = 0 then k2 := k2 + 1            else if x mod 17 = 0 then k17 := k17 + 1            else k := k + 1;        end;    end;    writeln((k2*(k2-1)+k17*(k17-1)+k*(k-1))/2+k2*k+k17*k);end. Решение эффективное по памяти и времени (Задача Б). Решение от обратного.Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, кратных 34. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел кратных 34, n – количество введенных чисел.Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 34 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 17. Программа на языке Pascal.var k2, k17, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k17 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 34 = 0 then            k := k + 1        else if x mod 2 = 0 then            k2 := k2 + 1        else if x mod 17 = 0 then            k17 := k17 + 1;        end;        writeln(n*(n-1)/2–k34*(n-k34)–k34*(k34-1)/2–k2*k17);end. Решение не эффективное по памяти и по времени (Задача А).var N: integer;    a: array[1..10000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 34 <> 0 then                k := k + 1;        writeln(k)end.",
            "parsed": "2019-04-29 21:13:39.870940",
            "question": "На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов не делится на 34.Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (1≤N≤1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов не кратно 34.Пример входных данных:534101117Пример выходных данных для приведённого выше примера входных данных: 8Пояснение. Из шести заданных чисел можно составить 10 попарных произведений: 3·4, 3·10, 3·11, 3·17, 4·10, 4·11, 4·17, 10·11, 10·17, 11·17 (результаты: 12, 30, 33, 51, 40, 44, 68, 110, 170, 187). Из них на 34 не делятся 8 произведения (3·4=12, 3·10=30, 3·11=33, 3·17=51, 4·10=40, 4·11=44, 10·11=110, 11·17=187).Требуется написать эффективную по времени и по памяти программу для решения описанной задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938983\" width=\"100%\"><p class=\"left_margin\">На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов не делится на 34.<p><b>Описание входных и выходных данных </b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1≤N≤1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов не кратно 34.<p><i>Пример входных данных</i>:<p class=\"left_margin\">5<p class=\"left_margin\">3<p class=\"left_margin\">4<p class=\"left_margin\">10<p class=\"left_margin\">11<p class=\"left_margin\">17<p><i>Пример выходных данных для приведённого выше примера входных данных</i>: <p class=\"left_margin\">8<p><i>Пояснение.</i> Из шести заданных чисел можно составить 10 попарных произведений: 3·4, 3·10, 3·11, 3·17, 4·10, 4·11, 4·17, 10·11, 10·17, 11·17 (результаты: 12, 30, 33, 51, 40, 44, 68, 110, 170, 187). Из них на 34 не делятся 8 произведения (3·4=12, 3·10=30, 3·11=33, 3·17=51, 4·10=40, 4·11=44, 10·11=110, 11·17=187).<p class=\"left_margin\">Требуется написать эффективную по времени и по памяти программу для решения описанной задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Решение эффективное по памяти и времени (Задача Б). Прямой вариант.Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, не кратных 2 и не кратных 17. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел не кратных 2 и не кратных 17. Тогда количество чисел будет равноk2*(k2-1)/2 + k17*(k17-1)/2 + k*(k-1)/2 + k2*k + k17*k Программа на языке Pascal.var k2, k17, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k17 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 34 <> 0 then begin            if x mod 2 = 0 then k2 := k2 + 1            else if x mod 17 = 0 then k17 := k17 + 1            else k := k + 1;        end;    end;    writeln((k2*(k2-1)+k17*(k17-1)+k*(k-1))/2+k2*k+k17*k);end. Решение эффективное по памяти и времени (Задача Б). Решение от обратного.Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, кратных 34. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел кратных 34, n – количество введенных чисел.Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 34 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 17. Программа на языке Pascal.var k2, k17, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k17 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 34 = 0 then            k := k + 1        else if x mod 2 = 0 then            k2 := k2 + 1        else if x mod 17 = 0 then            k17 := k17 + 1;        end;        writeln(n*(n-1)/2–k34*(n-k34)–k34*(k34-1)/2–k2*k17);end. Решение не эффективное по памяти и по времени (Задача А).var N: integer;    a: array[1..10000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 34 <> 0 then                k := k + 1;        writeln(k)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15643\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Решение эффективное по памяти и времени (Задача Б). Прямой вариант.<p class=\"left_margin\">Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, не кратных 2 и не кратных 17. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.<p class=\"left_margin\">Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел не кратных 2 и не кратных 17. Тогда количество чисел будет равно<p>k2*(k2-1)/2 + k17*(k17-1)/2 + k*(k-1)/2 + k2*k + k17*k<p> </p><p class=\"left_margin\">Программа на языке Pascal.<p><tt><p>var k2, k17, k: integer;<p>    n, i, x: integer;<p>begin<p>    k := 0; k2 := 0; k17 := 0;<p>    readln(n);<p>    for i:=1 to n do begin<p>        readln(x);<p>        if x mod 34 &lt;&gt; 0 then begin<p>            if x mod 2 = 0 then k2 := k2 + 1<p>            else if x mod 17 = 0 then k17 := k17 + 1<p>            else k := k + 1;<p>        end;<p>    end;<p>    writeln((k2*(k2-1)+k17*(k17-1)+k*(k-1))/2+k2*k+k17*k);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Решение эффективное по памяти и времени (Задача Б). Решение от обратного.<p class=\"left_margin\">Решение основано на подсчете количества чисел кратных 2 и не кратных 17, кратных 17 и не кратных 2, кратных 34. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.<p class=\"left_margin\">Обозначим за k2 – количество чисел кратных 2 и не кратных 17, за k17 – количество чисел кратных 17 и не кратных 2, за k – количество чисел кратных 34, n – количество введенных чисел.<p class=\"left_margin\">Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 34 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 17.<p> </p><p class=\"left_margin\">Программа на языке Pascal.<p><tt><p>var k2, k17, k: integer;<p>    n, i, x: integer;<p>begin<p>    k := 0; k2 := 0; k17 := 0;<p>    readln(n);<p>    for i:=1 to n do begin<p>        readln(x);<p>        if x mod 34 = 0 then<p>            k := k + 1<p>        else if x mod 2 = 0 then<p>            k2 := k2 + 1<p>        else if x mod 17 = 0 then<p>            k17 := k17 + 1;<p>        end;<p>    <p>    writeln(n*(n-1)/2–k34*(n-k34)–k34*(k34-1)/2–k2*k17);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Решение не эффективное по памяти и по времени (Задача А).<p><tt><p>var N: integer;<p>    a: array[1..10000] of integer;<p>    i, j, k: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do read(a[i]);<p>    k:= 0;<p>    for i:= 1 to N-1 do<p>        for j:= i+1 to N do<p>            if a[i]*a[j] mod 34 &lt;&gt; 0 then<p>                k := k + 1;<p>        writeln(k)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ — 2018. До­сроч­ная волна. Вариант 1., ЕГЭ — 2018. До­сроч­ная волна. Вариант 2.",
            "task_id": "15643"
        },
        {
            "answer": "Решение.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3.Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 3. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.Пусть в результате подсчёта получилось, что в наборе данныхm1 нечётных чисел, не кратных 3;m2 чётных чисел, не кратных 3;m3 нечётных чисел, кратных 3;m6 чётных чисел, кратных 3.Тогда количество удовлетворяющих условию пар можно определить по формуле m1m6 + m2m3 + m3m6.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 3}    m2: integer; {чётные, не кратные 3}    m3: integer; {нечётные, кратные 3}    m6: integer; {чётные, кратные 3}    s: integer; {количество пар}    i: integer;begin    m1 := 0; m2 := 0; m3 := 0; m6 := 0;    readln(N);    for i:=0 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 3 = 0 then m6 := m6 + 1;            else m2 := m2 + 1;            end        else begin            if a mod 3 = 0 then m3 := m3 + 1;            else m1 := m1 + 1;            end    end;    s := m1 * m6 + m2 * m3 + m3 * m6;    writeln(s);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) then s := s + 1;        end    end;    writeln(s);end.",
            "parsed": "2019-04-29 21:13:40.371499",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все  возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляются сумма и произведение элементов. Необходимо определить количество пар, у которых сумма нечётна, а произведение делится на 3.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 100.Пример входных данных:41234Пример выходных данных для приведённого выше примера входных данных:2Из четырёх чисел можно составить 6 пар. В данном случае условиям удовлетворяют две пары: (2, 3) и (3, 4). Суммы чисел в этих парах (5 и 7) нечётны, а произведения (6 и 12) делятся на 3. У всех остальных пар как минимум одно из этих условий не выполняется.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938808\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из этих чисел формируются все  возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляются сумма и произведение элементов. Необходимо определить количество пар, у которых сумма нечётна, а произведение делится на 3.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 100.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">4<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">3<p class=\"left_margin\">4<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">2<p class=\"left_margin\">Из четырёх чисел можно составить 6 пар. В данном случае условиям удовлетворяют две пары: (2, 3) и (3, 4). Суммы чисел в этих парах (5 и 7) нечётны, а произведения (6 и 12) делятся на 3. У всех остальных пар как минимум одно из этих условий не выполняется.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3.Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 3. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.Пусть в результате подсчёта получилось, что в наборе данныхm1 нечётных чисел, не кратных 3;m2 чётных чисел, не кратных 3;m3 нечётных чисел, кратных 3;m6 чётных чисел, кратных 3.Тогда количество удовлетворяющих условию пар можно определить по формуле m1m6 + m2m3 + m3m6.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 3}    m2: integer; {чётные, не кратные 3}    m3: integer; {нечётные, кратные 3}    m6: integer; {чётные, кратные 3}    s: integer; {количество пар}    i: integer;begin    m1 := 0; m2 := 0; m3 := 0; m6 := 0;    readln(N);    for i:=0 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 3 = 0 then m6 := m6 + 1;            else m2 := m2 + 1;            end        else begin            if a mod 3 = 0 then m3 := m3 + 1;            else m1 := m1 + 1;            end    end;    s := m1 * m6 + m2 * m3 + m3 * m6;    writeln(s);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) then s := s + 1;        end    end;    writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15812\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3.<p class=\"left_margin\">Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 3. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.<p class=\"left_margin\">Пусть в результате подсчёта получилось, что в наборе данных<p><i>m<sub>1</sub></i> нечётных чисел, не кратных 3;<p><i>m<sub>2</sub></i> чётных чисел, не кратных 3;<p><i>m<sub>3</sub></i> нечётных чисел, кратных 3;<p><i>m<sub>6</sub></i> чётных чисел, кратных 3.<p class=\"left_margin\">Тогда количество удовлетворяющих условию пар можно определить по формуле <i>m<sub>1</sub>m<sub>6</sub></i> + <i>m<sub>2</sub>m<sub>3</sub></i> + <i>m<sub>3</sub>m<sub>6</sub>.</i><p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    m1: integer; {нечётные, не кратные 3}<p class=\"left_margin\">    m2: integer; {чётные, не кратные 3}<p class=\"left_margin\">    m3: integer; {нечётные, кратные 3}<p class=\"left_margin\">    m6: integer; {чётные, кратные 3}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    m1 := 0; m2 := 0; m3 := 0; m6 := 0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=0 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        if a mod 2 = 0 then begin<p class=\"left_margin\">            if a mod 3 = 0 then m6 := m6 + 1;<p class=\"left_margin\">            else m2 := m2 + 1;<p class=\"left_margin\">            end<p class=\"left_margin\">        else begin<p class=\"left_margin\">            if a mod 3 = 0 then m3 := m3 + 1;<p class=\"left_margin\">            else m1 := m1 + 1;<p class=\"left_margin\">            end<p class=\"left_margin\">    end;<p class=\"left_margin\">    s := m1 * m6 + m2 * m3 + m3 * m6;<p class=\"left_margin\">    writeln(s);<p>end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    s := 0;<p class=\"left_margin\">    for i := 1 to N − 1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) then s := s + 1;<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(s);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15812"
        },
        {
            "answer": "Решение.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5.Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 5. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.Пусть в результате подсчёта получилось, что в наборе данныхm1 нечётных чисел, не кратных 5;m2 чётных чисел, не кратных 5;m5 нечётных чисел, кратных 5;m10 чётных чисел, кратных 5.Тогда количество удовлетворяющих условию пар можно определить по формуле m1m10 + m2m5 + m5m10.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 5}    m2: integer; {чётные, не кратные 5}    m5: integer; {нечётные, кратные 5}    m10: integer; {чётные, кратные 5}    s: integer; {количество пар}    i: integer;begin    m1 := 0; m2 := 0; m5 := 0; m10 := 0;    readln(N);    for i:=0 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 5 = 0 then m10 := m10 + 1;            else m2 := m2 + 1;            end        else begin            if a mod 5 = 0 then m5 := m5 + 1;            else m1 := m1 + 1;            end    end;    s := m1 * m10 + m2 * m5 + m5 * m10;    writeln(s);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) then s := s + 1;        end    end;    writeln(s);end.",
            "parsed": "2019-04-29 21:13:40.812310",
            "question": "Дан набор из N целых положительных чисел. Из этих чисел формируются все  возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляются сумма и произведение элементов. Необходимо определить количество пар, у которых сумма нечётна, а произведение делится на 5.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 100.Пример входных данных:41245Пример выходных данных для приведённого выше примера входных данных:2Из четырёх чисел можно составить 6 пар. В данном случае условиям удовлетворяют две пары: (2, 5) и (4, 5). Суммы чисел в этих парах (7 и 9) нечётны, а произведения (10 и 20) делятся на 5. У всех остальных пар как минимум одно из этих условий не выполняется.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938787\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из этих чисел формируются все  возможные пары (парой считаются два элемента, которые находятся на разных местах в наборе, порядок чисел в паре не учитывается), в каждой паре вычисляются сумма и произведение элементов. Необходимо определить количество пар, у которых сумма нечётна, а произведение делится на 5.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает одного килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 100.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">4<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">4<p class=\"left_margin\">5<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">2<p class=\"left_margin\">Из четырёх чисел можно составить 6 пар. В данном случае условиям удовлетворяют две пары: (2, 5) и (4, 5). Суммы чисел в этих парах (7 и 9) нечётны, а произведения (10 и 20) делятся на 5. У всех остальных пар как минимум одно из этих условий не выполняется.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5.Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 5. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.Пусть в результате подсчёта получилось, что в наборе данныхm1 нечётных чисел, не кратных 5;m2 чётных чисел, не кратных 5;m5 нечётных чисел, кратных 5;m10 чётных чисел, кратных 5.Тогда количество удовлетворяющих условию пар можно определить по формуле m1m10 + m2m5 + m5m10.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 5}    m2: integer; {чётные, не кратные 5}    m5: integer; {нечётные, кратные 5}    m10: integer; {чётные, кратные 5}    s: integer; {количество пар}    i: integer;begin    m1 := 0; m2 := 0; m5 := 0; m10 := 0;    readln(N);    for i:=0 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 5 = 0 then m10 := m10 + 1;            else m2 := m2 + 1;            end        else begin            if a mod 5 = 0 then m5 := m5 + 1;            else m1 := m1 + 1;            end    end;    s := m1 * m10 + m2 * m5 + m5 * m10;    writeln(s);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    s: integer; {количество пар}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    s := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) then s := s + 1;        end    end;    writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15839\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5.<p class=\"left_margin\">Разобьём все числа исходного набора на 4 группы, в зависимости от их чётности и делимости на 5. Сами числа можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5 и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит четырёх счётчиков, и программа получится эффективной по памяти.<p class=\"left_margin\">Пусть в результате подсчёта получилось, что в наборе данных<p><i>m<sub>1</sub></i> нечётных чисел, не кратных 5;<p><i>m<sub>2</sub></i> чётных чисел, не кратных 5;<p><i>m<sub>5</sub></i> нечётных чисел, кратных 5;<p><i>m<sub>10</sub></i> чётных чисел, кратных 5.<p class=\"left_margin\">Тогда количество удовлетворяющих условию пар можно определить по формуле <i>m<sub>1</sub>m<sub>10</sub></i> + <i>m<sub>2</sub>m<sub>5</sub></i> + <i>m<sub>5</sub>m<sub>10</sub>.</i><p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    m1: integer; {нечётные, не кратные 5}<p class=\"left_margin\">    m2: integer; {чётные, не кратные 5}<p class=\"left_margin\">    m5: integer; {нечётные, кратные 5}<p class=\"left_margin\">    m10: integer; {чётные, кратные 5}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    m1 := 0; m2 := 0; m5 := 0; m10 := 0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=0 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        if a mod 2 = 0 then begin<p class=\"left_margin\">            if a mod 5 = 0 then m10 := m10 + 1;<p class=\"left_margin\">            else m2 := m2 + 1;<p class=\"left_margin\">            end<p class=\"left_margin\">        else begin<p class=\"left_margin\">            if a mod 5 = 0 then m5 := m5 + 1;<p class=\"left_margin\">            else m1 := m1 + 1;<p class=\"left_margin\">            end<p class=\"left_margin\">    end;<p class=\"left_margin\">    s := m1 * m10 + m2 * m5 + m5 * m10;<p class=\"left_margin\">    writeln(s);<p>end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    s: integer; {количество пар}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    s := 0;<p class=\"left_margin\">    for i := 1 to N − 1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) then s := s + 1;<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(s);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15839"
        },
        {
            "answer": "Решение.Решение эффективное по памяти и времени. Решение от обратного.Решение основано на подсчете количества чисел кратных 2 и не кратных 7, кратных 7 и не кратных 2 и кратных 14. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 — количество чисел кратных 2 и не кратных 7, за k7 — количество чисел кратных 14, за k — количество чисел кратных 14, за n — количество введенных чисел.Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 14 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 7. Программа на языке Pascal.var k2, k7, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k7 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 14 = 0 then            k := k + 1        else if x mod 7 = 0 then            k2 := k2 + 1        else if x mod 2 = 0 then            k7 := k7 + 1;        end;        writeln(n*(n-1)/2–k*(n-k)–k*(k-1)/2–k2*k7);end. Решение не эффективное по памяти и по времени.var N: integer;    a: array[1..1000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 14 <> 0 then                k := k + 1;        writeln(k)end.",
            "parsed": "2019-04-29 21:13:41.222762",
            "question": "На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов не кратно 14.Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (1≤N≤1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 1000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов не кратно 14.Пример входных данных:426542Пример выходных данных для приведённого выше примера входных данных: 3Пояснение. Из четырёх заданных чисел можно составить 6 попарных произведений: 2 · 6, 2 · 5, 2 · 42, 6 · 5, 6 · 42, 5 · 42. Из них на 14 не делятся 3 произведения (2 · 6, 2 · 5, 6 · 5).Требуется написать эффективную по времени и по памяти программу для решения описанной задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938759\" width=\"100%\"><p class=\"left_margin\">На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар, для которых произведение элементов не кратно 14.<p class=\"left_margin\"><b>Описание входных и выходных данных </b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (1≤N≤1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 1000. В качестве результата программа должна напечатать одно число: количество пар, в которых произведение элементов не кратно 14.<p><i>Пример входных данных</i>:<p class=\"left_margin\">4<p class=\"left_margin\">2<p class=\"left_margin\">6<p class=\"left_margin\">5<p class=\"left_margin\">42<p class=\"left_margin\"><i>Пример выходных данных для приведённого выше примера входных данных</i>: <p class=\"left_margin\">3<p><i>Пояснение.</i> Из четырёх заданных чисел можно составить 6 попарных произведений: 2 · 6, 2 · 5, 2 · 42, 6 · 5, 6 · 42, 5 · 42. Из них на 14 не делятся 3 произведения (2 · 6, 2 · 5, 6 · 5).<p class=\"left_margin\">Требуется написать эффективную по времени и по памяти программу для решения описанной задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать <b>одну</b> программу или <b>две</b> программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет <b>бо́льшая</b> из двух оценок.<p class=\"left_margin\">Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Решение эффективное по памяти и времени. Решение от обратного.Решение основано на подсчете количества чисел кратных 2 и не кратных 7, кратных 7 и не кратных 2 и кратных 14. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.Обозначим за k2 — количество чисел кратных 2 и не кратных 7, за k7 — количество чисел кратных 14, за k — количество чисел кратных 14, за n — количество введенных чисел.Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 14 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 7. Программа на языке Pascal.var k2, k7, k: integer;    n, i, x: integer;begin    k := 0; k2 := 0; k7 := 0;    readln(n);    for i:=1 to n do begin        readln(x);        if x mod 14 = 0 then            k := k + 1        else if x mod 7 = 0 then            k2 := k2 + 1        else if x mod 2 = 0 then            k7 := k7 + 1;        end;        writeln(n*(n-1)/2–k*(n-k)–k*(k-1)/2–k2*k7);end. Решение не эффективное по памяти и по времени.var N: integer;    a: array[1..1000] of integer;    i, j, k: integer;begin    readln(N);    for i:=1 to N do read(a[i]);    k:= 0;    for i:= 1 to N-1 do        for j:= i+1 to N do            if a[i]*a[j] mod 14 <> 0 then                k := k + 1;        writeln(k)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15867\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Решение эффективное по памяти и времени. Решение от обратного.<p class=\"left_margin\">Решение основано на подсчете количества чисел кратных 2 и не кратных 7, кратных 7 и не кратных 2 и кратных 14. После чего, найдя количество комбинаций чисел из этих групп, получается ответ.<p class=\"left_margin\">Обозначим за k2 — количество чисел кратных 2 и не кратных 7, за k7 — количество чисел кратных 14, за k — количество чисел кратных 14, за n — количество введенных чисел.<p class=\"left_margin\">Тогда количество чисел будет равно общему количеству за вычетом произведения количества чисел кратных 14 на общее количество и произведения количества чисел, кратных 2, и количества чисел кратных 7.<p> </p><p class=\"left_margin\"><b>Программа на языке Pascal.</b><p><tt><p>var k2, k7, k: integer;<p>    n, i, x: integer;<p>begin<p>    k := 0; k2 := 0; k7 := 0;<p>    readln(n);<p>    for i:=1 to n do begin<p>        readln(x);<p>        if x mod 14 = 0 then<p>            k := k + 1<p>        else if x mod 7 = 0 then<p>            k2 := k2 + 1<p>        else if x mod 2 = 0 then<p>            k7 := k7 + 1;<p>        end;<p>    <p>    writeln(n*(n-1)/2–k*(n-k)–k*(k-1)/2–k2*k7);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\"><b>Решение не эффективное по памяти и по времени.</b><p><tt><p>var N: integer;<p>    a: array[1..1000] of integer;<p>    i, j, k: integer;<p>begin<p>    readln(N);<p>    for i:=1 to N do read(a[i]);<p>    k:= 0;<p>    for i:= 1 to N-1 do<p>        for j:= i+1 to N do<p>            if a[i]*a[j] mod 14 &lt;&gt; 0 then<p>                k := k + 1;<p>        writeln(k)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ — 2018. До­сроч­ная волна. Вариант 2., ЕГЭ — 2018. До­сроч­ная волна. Вариант 1.",
            "task_id": "15867"
        },
        {
            "answer": "Решение.Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 3:m1 нечётные числа, не кратные 3;m2 чётные числа, не кратные 3;m3 нечётные числа, кратные 3;m6 чётные числа, кратные 3.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3. Таким образом, нужно выбрать два числа из групп m1 и m6, или из групп m2 и m3, или из групп m3 и m6. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 3}    m2: integer; {чётные, не кратные 3}    m3: integer; {нечётные, кратные 3}    m6: integer; {чётные, кратные 3}    x, y: integer; {выбранная пара}    i: integer;begin    m1 := 0; m2 := 0; m3 := 0; m6 := 0;    readln(N);    for i:=1 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 3 = 0 then begin                if a>m6 then m6 := a            end            else begin                if a>m2 then m2 := a            end        end        else begin            if a mod 3 = 0 then begin                if a>m3 then m3 := a            else begin                if a>m1 then m1 := a            end        end    end;    x := m1; y := m6;    if m2*m3 > x*y then begin        x := m2; y := m3;    end    if m3*m6 > x*y then begin        x := m3; y := m6;    end    if x*y = 0        then writeln(0)        else writeln(x, '  ', y);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    x, y: integer; {выбранная пара}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    x := 0; y := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) and (a[i](a[j] > x*y) then begin                x := a[i]; y := a[j];            end        end    end;    if x = 0        then writeln(0)        else writeln(x, '  ', y);end.",
            "parsed": "2019-04-29 21:13:41.679380",
            "question": "Дан набор из N целых положительных чисел. Из них нужно выбрать и вывести два числа так, чтобы их сумма была нечётна, а произведение делилось на 3 и при этом было максимально возможным. Выбранные числа можно выводить в любом порядке. Если есть несколько подходящих пар, можно выбрать любую из них. Если подходящих пар нет, нужно вывести 0.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 100.Пример входных данных:512345Пример выходных данных для приведённого выше примера входных данных:3 4Из 5 чисел можно составить 10 пар. В данном случае условиям удовлетворяют две пары: (2, 3) и (3, 4). Суммы чисел в этих парах (5 и 7) нечётны, а произведения (6 и 12) делятся на 3. У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938173\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из них нужно выбрать и вывести два числа так, чтобы их сумма была нечётна, а произведение делилось на 3 и при этом было максимально возможным. Выбранные числа можно выводить в любом порядке. Если есть несколько подходящих пар, можно выбрать любую из них. Если подходящих пар нет, нужно вывести 0.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 100.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">3<p class=\"left_margin\">4<p class=\"left_margin\">5<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">3 4<p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае условиям удовлетворяют две пары: (2, 3) и (3, 4). Суммы чисел в этих парах (5 и 7) нечётны, а произведения (6 и 12) делятся на 3. У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 3:m1 нечётные числа, не кратные 3;m2 чётные числа, не кратные 3;m3 нечётные числа, кратные 3;m6 чётные числа, кратные 3.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3. Таким образом, нужно выбрать два числа из групп m1 и m6, или из групп m2 и m3, или из групп m3 и m6. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 3}    m2: integer; {чётные, не кратные 3}    m3: integer; {нечётные, кратные 3}    m6: integer; {чётные, кратные 3}    x, y: integer; {выбранная пара}    i: integer;begin    m1 := 0; m2 := 0; m3 := 0; m6 := 0;    readln(N);    for i:=1 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 3 = 0 then begin                if a>m6 then m6 := a            end            else begin                if a>m2 then m2 := a            end        end        else begin            if a mod 3 = 0 then begin                if a>m3 then m3 := a            else begin                if a>m1 then m1 := a            end        end    end;    x := m1; y := m6;    if m2*m3 > x*y then begin        x := m2; y := m3;    end    if m3*m6 > x*y then begin        x := m3; y := m6;    end    if x*y = 0        then writeln(0)        else writeln(x, '  ', y);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    x, y: integer; {выбранная пара}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    x := 0; y := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) and (a[i](a[j] > x*y) then begin                x := a[i]; y := a[j];            end        end    end;    if x = 0        then writeln(0)        else writeln(x, '  ', y);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15937\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 3:<p><i>m<sub>1</sub></i> нечётные числа, не кратные 3;<p><i>m<sub>2</sub></i> чётные числа, не кратные 3;<p><i>m<sub>3</sub></i> нечётные числа, кратные 3;<p><i>m<sub>6</sub></i> чётные числа, кратные 3.<p class=\"left_margin\">Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 3, хотя бы одно из этих чисел должно делиться на 3. Таким образом, нужно выбрать два числа из групп <i>m</i><sub>1</sub> и <i>m</i><sub>6</sub>, или из групп <i>m</i><sub>2</sub> и <i>m</i><sub>3</sub>, или из групп <i>m</i><sub>3</sub> и <i>m</i><sub>6</sub>. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.<p class=\"left_margin\">Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 3, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    m1: integer; {нечётные, не кратные 3}<p class=\"left_margin\">    m2: integer; {чётные, не кратные 3}<p class=\"left_margin\">    m3: integer; {нечётные, кратные 3}<p class=\"left_margin\">    m6: integer; {чётные, кратные 3}<p class=\"left_margin\">    x, y: integer; {выбранная пара}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    m1 := 0; m2 := 0; m3 := 0; m6 := 0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        if a mod 2 = 0 then begin<p class=\"left_margin\">            if a mod 3 = 0 then begin<p class=\"left_margin\">                if a&gt;m6 then m6 := a<p class=\"left_margin\">            end<p class=\"left_margin\">            else begin<p>                if a&gt;m2 then m2 := a<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">        else begin<p class=\"left_margin\">            if a mod 3 = 0 then begin<p class=\"left_margin\">                if a&gt;m3 then m3 := a<p class=\"left_margin\">            else begin<p class=\"left_margin\">                if a&gt;m1 then m1 := a<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    x := m1; y := m6;<p class=\"left_margin\">    if m2*m3 &gt; x*y then begin<p class=\"left_margin\">        x := m2; y := m3;<p class=\"left_margin\">    end<p class=\"left_margin\">    if m3*m6 &gt; x*y then begin<p class=\"left_margin\">        x := m3; y := m6;<p class=\"left_margin\">    end<p class=\"left_margin\">    if x*y = 0<p class=\"left_margin\">        then writeln(0)<p class=\"left_margin\">        else writeln(x, '  ', y);<p>end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    x, y: integer; {выбранная пара}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    x := 0; y := 0;<p class=\"left_margin\">    for i := 1 to N − 1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 3 = 0) and (a[i](a[j] &gt; x*y) then begin<p class=\"left_margin\">                x := a[i]; y := a[j];<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    if x = 0<p class=\"left_margin\">        then writeln(0)<p class=\"left_margin\">        else writeln(x, '  ', y);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15937"
        },
        {
            "answer": "Решение.Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 5:m1 нечётные числа, не кратные 5;m2 чётные числа, не кратные 5;m5 нечётные числа, кратные 5;m10 чётные числа, кратные 5.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5. Таким образом, нужно выбрать два числа из групп m1 и m10, или из групп m2 и m5, или из групп m5 и m10. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 5}    m2: integer; {чётные, не кратные 5}    m5: integer; {нечётные, кратные 5}    m10: integer; {чётные, кратные 5}    x, y: integer; {выбранная пара}    i: integer;begin    m1 := 0; m2 := 0; m5 := 0; m10 := 0;    readln(N);    for i:=1 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 5 = 0 then begin                if a>m10 then m10 := a            end            else begin                if a>m2 then m2 := a            end        end        else begin            if a mod 5 = 0 then begin                if a>m5 then m5 := a            else begin                if a>m1 then m1 := a            end        end    end;    x := m1; y := m10;    if m2*m5 > x*y then begin        x := m2; y := m5;    end    if m5*m10 > x*y then begin        x := m5; y := m10;    end    if x*y = 0        then writeln(0)        else writeln(x, '  ', y);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    x, y: integer; {выбранная пара}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    x := 0; y := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) and (a[i](a[j] > x*y) then begin                x := a[i]; y := a[j];            end        end    end;    if x = 0        then writeln(0)        else writeln(x, '  ', y);end.",
            "parsed": "2019-04-29 21:13:42.086086",
            "question": "Дан набор из N целых положительных чисел. Из них нужно выбрать и вывести два числа так, чтобы их сумма была нечётна, а произведение делилось на 5 и при этом было максимально возможным. Выбранные числа можно выводить в любом порядке. Если есть несколько подходящих пар, можно выбрать любую из них. Если подходящих пар нет, нужно вывести 0.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 100.Пример входных данных:512457Пример выходных данных для приведённого выше примера входных данных:4 5Из 5 чисел можно составить 10 пар. В данном случае условиям удовлетворяют две пары: (2, 5) и (4, 5). Суммы чисел в этих парах (7 и 11) нечётны, а произведения (10 и 20) делятся на 5. У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938144\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> целых положительных чисел. Из них нужно выбрать и вывести два числа так, чтобы их сумма была нечётна, а произведение делилось на 5 и при этом было максимально возможным. Выбранные числа можно выводить в любом порядке. Если есть несколько подходящих пар, можно выбрать любую из них. Если подходящих пар нет, нужно вывести 0.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 100.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">1<p class=\"left_margin\">2<p class=\"left_margin\">4<p class=\"left_margin\">5<p class=\"left_margin\">7<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">4 5<p class=\"left_margin\">Из 5 чисел можно составить 10 пар. В данном случае условиям удовлетворяют две пары: (2, 5) и (4, 5). Суммы чисел в этих парах (7 и 11) нечётны, а произведения (10 и 20) делятся на 5. У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 5:m1 нечётные числа, не кратные 5;m2 чётные числа, не кратные 5;m5 нечётные числа, кратные 5;m10 чётные числа, кратные 5.Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5. Таким образом, нужно выбрать два числа из групп m1 и m10, или из групп m2 и m5, или из групп m5 и m10. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Пример правильной и эффективной программы на языке Паскаль:var    N: integer; {количество чисел}    a: integer; {очередное число}    m1: integer; {нечётные, не кратные 5}    m2: integer; {чётные, не кратные 5}    m5: integer; {нечётные, кратные 5}    m10: integer; {чётные, кратные 5}    x, y: integer; {выбранная пара}    i: integer;begin    m1 := 0; m2 := 0; m5 := 0; m10 := 0;    readln(N);    for i:=1 to N do begin        readln(a);        if a mod 2 = 0 then begin            if a mod 5 = 0 then begin                if a>m10 then m10 := a            end            else begin                if a>m2 then m2 := a            end        end        else begin            if a mod 5 = 0 then begin                if a>m5 then m5 := a            else begin                if a>m1 then m1 := a            end        end    end;    x := m1; y := m10;    if m2*m5 > x*y then begin        x := m2; y := m5;    end    if m5*m10 > x*y then begin        x := m5; y := m10;    end    if x*y = 0        then writeln(0)        else writeln(x, '  ', y);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    x, y: integer; {выбранная пара}    i, j: integer;begin    readln(N);    for i := 1 to N do readln(a[i]);    x := 0; y := 0;    for i := 1 to N − 1 do begin        for j := i + 1 to N do begin            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) and (a[i](a[j] > x*y) then begin                x := a[i]; y := a[j];            end        end    end;    if x = 0        then writeln(0)        else writeln(x, '  ', y);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15964\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Разобьём все числа исходного набора на 4 группы в зависимости от их чётности и делимости на 5:<p><i>m<sub>1</sub></i> нечётные числа, не кратные 5;<p><i>m<sub>2</sub></i> чётные числа, не кратные 5;<p><i>m<sub>5</sub></i> нечётные числа, кратные 5;<p><i>m<sub>10</sub></i> чётные числа, кратные 5.<p class=\"left_margin\">Чтобы сумма двух чисел было нечётной, одно из них должно быть чётным, а другое — нечётным. Чтобы произведение двух чисел делилось на 5, хотя бы одно из этих чисел должно делиться на 5. Таким образом, нужно выбрать два числа из групп <i>m</i><sub>1</sub> и <i>m</i><sub>10</sub>, или из групп <i>m</i><sub>2</sub> и <i>m</i><sub>5</sub>, или из групп <i>m</i><sub>5</sub> и <i>m</i><sub>10</sub>. Чтобы получить пару с максимальным произведением, достаточно сохранить максимальный элемент из каждой группы, сравнить соответствующие произведения и выбрать из них наибольшее.<p class=\"left_margin\">Сами числа при этом можно не хранить, достаточно при вводе определить остаток от деления очередного числа на 2 и на 5, сравнить число с текущим максимумом соответствующей группы и при необходимости обновить этот максимум и увеличить соответствующий счётчик. Таким образом, независимо от количества чисел в исходном наборе, после чтения исходных данных для хранения необходимой информации хватит 4 переменных, и программа получится эффективной по памяти.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: integer; {очередное число}<p class=\"left_margin\">    m1: integer; {нечётные, не кратные 5}<p class=\"left_margin\">    m2: integer; {чётные, не кратные 5}<p class=\"left_margin\">    m5: integer; {нечётные, кратные 5}<p class=\"left_margin\">    m10: integer; {чётные, кратные 5}<p class=\"left_margin\">    x, y: integer; {выбранная пара}<p class=\"left_margin\">    i: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    m1 := 0; m2 := 0; m5 := 0; m10 := 0;<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do begin<p class=\"left_margin\">        readln(a);<p class=\"left_margin\">        if a mod 2 = 0 then begin<p class=\"left_margin\">            if a mod 5 = 0 then begin<p class=\"left_margin\">                if a&gt;m10 then m10 := a<p class=\"left_margin\">            end<p class=\"left_margin\">            else begin<p>                if a&gt;m2 then m2 := a<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">        else begin<p class=\"left_margin\">            if a mod 5 = 0 then begin<p class=\"left_margin\">                if a&gt;m5 then m5 := a<p class=\"left_margin\">            else begin<p class=\"left_margin\">                if a&gt;m1 then m1 := a<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    x := m1; y := m10;<p class=\"left_margin\">    if m2*m5 &gt; x*y then begin<p class=\"left_margin\">        x := m2; y := m5;<p class=\"left_margin\">    end<p class=\"left_margin\">    if m5*m10 &gt; x*y then begin<p class=\"left_margin\">        x := m5; y := m10;<p class=\"left_margin\">    end<p class=\"left_margin\">    if x*y = 0<p class=\"left_margin\">        then writeln(0)<p class=\"left_margin\">        else writeln(x, '  ', y);<p>end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    x, y: integer; {выбранная пара}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    x := 0; y := 0;<p class=\"left_margin\">    for i := 1 to N − 1 do begin<p class=\"left_margin\">        for j := i + 1 to N do begin<p class=\"left_margin\">            if ((a[i] + a[j]) mod 2 = 1) and ((a[i]*a[j]) mod 5 = 0) and (a[i](a[j] &gt; x*y) then begin<p class=\"left_margin\">                x := a[i]; y := a[j];<p class=\"left_margin\">            end<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    if x = 0<p class=\"left_margin\">        then writeln(0)<p class=\"left_margin\">        else writeln(x, '  ', y);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "15964"
        },
        {
            "answer": "Решение.На каждом шаге достаём из массива один элемент, если он кратен 13, то прибавляем единицу к количеству кратных 13. Если элемент не кратен 13, то прибавляем единицу к количеству не кратных 13.Далее считываем следующий элемент. Если он кратен 13, то к количеству пар прибавляем количество элементов, кратных 13. Пример правильной и эффективной программы на языке Паскаль: const p = 5; {требуемое расстояние между числами}var    a: array[0..p] of integer; {исходные данные}    N: integer; {количество чисел}    r: integer; {очередное число}    k13: integer; {кратные 13}    nk13: integer; {не кратные 13}    count: integer; {количество пар}    i, j: integer;begin    readln(N);    count := 0; k13 := 0; nk13 := 0;    for i := 1 to p do begin      readln(r);      a[i mod p] := r;    end;    for i := p + 1 to N do begin      readln(r);      if a[i mod p] mod 13 = 0 then Inc(k13)      else Inc(nk13);      if r mod 13 = 0 then count := count + k13 + n13      else count := count + k13;      a[i mod p] := r;    end;    writeln(count);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    a: array [1..10000] of integer; {исходные данные}    N: integer; {количество чисел}    count: integer; {количество пар}    i, j: integer;begin    readln(N);    count := 0;    for i := 1 to N do readln(a[i]);    for i := 1 to N−5 do        for j := i + 5 to N do            if (a[i] * a[j] mod 13 = 0) then                count := count + 1;        writeln(count)end.",
            "parsed": "2019-04-29 21:13:42.591297",
            "question": "Дан набор из N < 1000 натуральных чисел, каждое из которых не превышает 10000. Из них необходимо определить, сколько имеется пар чисел, разница между индексами которых не меньше 5, а произведение элементов в которых кратно 13. Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (3 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.Пример входных данных:741427397213Пример выходных данных для приведённого выше примера входных данных:2Из 7 чисел можно составить 14 пар. В данном случае условиям удовлетворяют две пары: (4, 13) и (14, 13). Произведения (52 и 182) делятся на 13, а номера элементов в паре отличаются не менее, чем на . У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938119\" width=\"100%\"><p class=\"left_margin\">Дан набор из <i>N</i> &lt; 1000 натуральных чисел, каждое из которых не превышает 10000. Из них необходимо определить, сколько имеется пар чисел, разница между индексами которых не меньше 5, а произведение элементов в которых кратно 13. Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (3 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">7<p class=\"left_margin\">4<p class=\"left_margin\">14<p class=\"left_margin\">27<p class=\"left_margin\">39<p class=\"left_margin\">7<p class=\"left_margin\">2<p class=\"left_margin\">13<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">2<p class=\"left_margin\">Из 7 чисел можно составить 14 пар. В данном случае условиям удовлетворяют две пары: (4, 13) и (14, 13). Произведения (52 и 182) делятся на 13, а номера элементов в паре отличаются не менее, чем на . У всех остальных пар как минимум одно из этих условий не выполняется. Из двух возможных пар выводим ту, в которой больше произведение элементов.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.На каждом шаге достаём из массива один элемент, если он кратен 13, то прибавляем единицу к количеству кратных 13. Если элемент не кратен 13, то прибавляем единицу к количеству не кратных 13.Далее считываем следующий элемент. Если он кратен 13, то к количеству пар прибавляем количество элементов, кратных 13. Пример правильной и эффективной программы на языке Паскаль: const p = 5; {требуемое расстояние между числами}var    a: array[0..p] of integer; {исходные данные}    N: integer; {количество чисел}    r: integer; {очередное число}    k13: integer; {кратные 13}    nk13: integer; {не кратные 13}    count: integer; {количество пар}    i, j: integer;begin    readln(N);    count := 0; k13 := 0; nk13 := 0;    for i := 1 to p do begin      readln(r);      a[i mod p] := r;    end;    for i := p + 1 to N do begin      readln(r);      if a[i mod p] mod 13 = 0 then Inc(k13)      else Inc(nk13);      if r mod 13 = 0 then count := count + k13 + n13      else count := count + k13;      a[i mod p] := r;    end;    writeln(count);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль var    a: array [1..10000] of integer; {исходные данные}    N: integer; {количество чисел}    count: integer; {количество пар}    i, j: integer;begin    readln(N);    count := 0;    for i := 1 to N do readln(a[i]);    for i := 1 to N−5 do        for j := i + 5 to N do            if (a[i] * a[j] mod 13 = 0) then                count := count + 1;        writeln(count)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol15995\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">На каждом шаге достаём из массива один элемент, если он кратен 13, то прибавляем единицу к количеству кратных 13. Если элемент не кратен 13, то прибавляем единицу к количеству не кратных 13.<p class=\"left_margin\">Далее считываем следующий элемент. Если он кратен 13, то к количеству пар прибавляем количество элементов, кратных 13.<p> </p><p class=\"left_margin\"><b>Пример правильной и эффективной программы на языке Паскаль:</b><p> </p><pre>const p = 5; {требуемое расстояние между числами}<p>var<p>    a: array[0..p] of integer; {исходные данные}<p>    N: integer; {количество чисел}<p>    r: integer; {очередное число}<p>    k13: integer; {кратные 13}<p>    nk13: integer; {не кратные 13}<p>    count: integer; {количество пар}<p>    i, j: integer;<p>begin<p>    readln(N);<p>    count := 0; k13 := 0; nk13 := 0;<p>    for i := 1 to p do begin<p>      readln(r);<p>      a[i mod p] := r;<p>    end;<p>    for i := p + 1 to N do begin<p>      readln(r);<p>      if a[i mod p] mod 13 = 0 then Inc(k13)<p>      else Inc(nk13);<p>      if r mod 13 = 0 then count := count + k13 + n13<p>      else count := count + k13;<p>      a[i mod p] := r;<p>    end;<p>    writeln(count);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><p class=\"left_margin\">var<p class=\"left_margin\">    a: array [1..10000] of integer; {исходные данные}<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    count: integer; {количество пар}<p class=\"left_margin\">    i, j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    count := 0;<p class=\"left_margin\">    for i := 1 to N do readln(a[i]);<p class=\"left_margin\">    for i := 1 to N−5 do<p class=\"left_margin\">        for j := i + 5 to N do<p class=\"left_margin\">            if (a[i] * a[j] mod 13 = 0) then<p class=\"left_margin\">                count := count + 1;<p class=\"left_margin\">        writeln(count)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по информатике 28.05.2018. Основная волна, вариант А. Имаева — «Котолис».",
            "task_id": "15995"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 29, если хотя бы один из сомножителей делится на 29.При вводе чисел можно подсчитывать количество чисел, кратных 29, не считая четырёх последних. Обозначим их n29.Примечание для проверяющего. Сами числа, кроме четырёх последних, при этом можно не хранить.Очередное считанное число будем рассматривать как возможный правый элемент искомой пары. Если очередное считанное число делится на 29, то к ответу следует прибавить количество чисел до него, не считая четырёх последних (включая считанное). Если очередное считанное число на 29 не делится, то к ответу следует прибавить n29.Чтобы построить программу, эффективную по памяти, заметим, что, поскольку при обработке очередного элемента входных данных используются значения, находящиеся на четыре элемента ранее, достаточно хранить только четыре последних элемента или информацию о них. Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC). Пример 1. Программа на языке Паскаль. Программа эффективна по времени и памяти. const s = 4; {требуемое расстояние между элементами}var    n: longint;    a: array[1..s] of longint; {хранение последних s значений}    a_: longint; {очередное значение}    n29: longint; {количество делящихся на 29 элементов, не считая s последних}    cnt: longint; {количество искомых пар}    i, j: longint;begin    readln(n); {Ввод первых s чисел}    for i:=1 to s do        readln(a[i]); {Ввод остальных значений, подсчет искомых пар}    cnt := 0;    n29 := 0;    for i := s + 1 to n do    begin        if a[1] mod 29 = 0 then            n29 := n29 + 1;        readln(a_);        if a_ mod 29 = 0 then            cnt := cnt + i - s        else            cnt := cnt + n29;{сдвигаем элементы вспомогательного массива влево}        for j := 1 to s - 1 do            a[j] := a[j + 1];        a[s] := a_ {записываем текущий элемент в конец массива}    end;    writeln(cnt)end. Пример 2. Программа на языке Python. Программа эффективна по времени и памяти. s = 4a = [0]*sn = int(input())for i in range(s):    a[i] = int(input())cnt = 0n29 = 0for i in range(s, n):    k = i % s    if a[k] % 29 == 0:        n29 = n29 + 1    a_ = int(input())    if a_ % 29 == 0:        cnt = cnt + i - s + 1    else:        cnt = cnt + n29    a[i % s] = a_print(cnt) Пример 3. Программа на языке С++. Программа эффективна по времени и памяти.     #include     using namespace std;    int main()    {        int s = 4; //требуемое расстояние между элементами        int n;        int n1 = 0, n2 = 0, n3 = 0, n4 = 0;        //хранение последних s счетчиков        int a_; // очередное значение        int cnt; // количество искомых пар        cin >> n;        cnt = 0;        for (int i = 0; i < n; ++i)        {            cin >> a_; // считано очередное значение            if (i >= s)            {                if (a_ % 29 == 0)                    cnt += i - s + 1;                else                    cnt += n4;            }            //сдвигаем элементы счетчиков            n4 = n3;            n3 = n2;            n2 = n1;            //обновляем счетчик кратных 29            if (a_ % 29 == 0)                n1 += 1;        }        cout << cnt;        return 0;    } Пример 4. Программа на языке Паскаль. Программа эффективна по времени и неэффективна по памяти. const s = 4; {требуемое расстояние между элементами}var    n: longint;    a: array[1..1000] of longint;    n29: longint;    {количество делящихся на 29 элементов, не считая s последних}    cnt: longint; {количество искомых пар}    i, j: longint;begin    readln(n);    {Ввод первых s чисел}    for i:=1 to s do        readln(a[i]);    {Ввод остальных значений, подсчет искомых пар}    cnt := 0;    n29 := 0;    for i := s + 1 to n do    begin        readln(a[i]);        if a[i - s] mod 29 = 0 then            n29 := n29 + 1;        if a[i] mod 29 = 0 then            cnt := cnt + i - s        else            cnt := cnt + n29;    end;    writeln(cnt)end.",
            "parsed": "2019-04-29 21:13:43.055603",
            "question": "На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности, находящихся на расстоянии не меньше чем 4 (разница в индексах элементов пары должна быть 4 или более, порядок элементов в паре неважен). Необходимо определить количество таких пар, для которых произведение элементов делится на 29.Описание входных и выходных данных В первой строке входных данных задаётся количество чисел N (4 ≤ N ≤ 1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000.В качестве результата программа должна вывести одно число: количество пар элементов, находящихся в последовательности на расстоянии не меньше чем 4, в которых произведение элементов кратно 29.Пример входных данных:7582 3 5 4 1 29Пример выходных данных для приведённого выше примера входных данных: 5Пояснение. Из 7 заданных элементов с учётом допустимых расстояний между ними можно составить 6 произведений: 58 · 4, 58 · 1, 58 · 29, 2 · 1, 2 · 29, 3 · 29. Из них на 29 делятся 5 произведений.Требуется написать эффективную по времени и по памяти программу для решения описанной задачи. Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N. Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную только по времени – 3 балла. Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла. Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body938058\" width=\"100%\"><p class=\"left_margin\">На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности, находящихся на расстоянии не меньше чем 4 (разница в индексах элементов пары должна быть 4 или более, порядок элементов в паре неважен). Необходимо определить количество таких пар, для которых произведение элементов делится на 29.<p><b>Описание входных и выходных данных </b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел N (4 ≤ N ≤ 1000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10 000.<p class=\"left_margin\">В качестве результата программа должна вывести одно число: количество пар элементов, находящихся в последовательности на расстоянии не меньше чем 4, в которых произведение элементов кратно 29.<p><i>Пример входных данных</i>:<p class=\"left_margin\">7<p class=\"left_margin\">58<p class=\"left_margin\">2 <p class=\"left_margin\">3 <p class=\"left_margin\">5 <p class=\"left_margin\">4 <p class=\"left_margin\">1 <p class=\"left_margin\">29<p><i>Пример выходных данных для приведённого выше примера входных данных</i>: <p class=\"left_margin\">5<p><i>Пояснение.</i> Из 7 заданных элементов с учётом допустимых расстояний между ними можно составить 6 произведений: 58 · 4, 58 · 1, 58 · 29, 2 · 1, 2 · 29, 3 · 29. Из них на 29 делятся 5 произведений.<p class=\"left_margin\">Требуется написать эффективную по времени и по памяти программу для решения описанной задачи. <p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз. <p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 Кбайт и не увеличивается с ростом N. <p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, – 4 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени – 3 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, – 2 балла. <p class=\"left_margin\">Вы можете сдать одну программу или две программы решения задачи (например, одна из программ может быть менее эффективна). Если Вы сдадите две программы, то каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок. <p class=\"left_margin\">Перед текстом программы обязательно кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 29, если хотя бы один из сомножителей делится на 29.При вводе чисел можно подсчитывать количество чисел, кратных 29, не считая четырёх последних. Обозначим их n29.Примечание для проверяющего. Сами числа, кроме четырёх последних, при этом можно не хранить.Очередное считанное число будем рассматривать как возможный правый элемент искомой пары. Если очередное считанное число делится на 29, то к ответу следует прибавить количество чисел до него, не считая четырёх последних (включая считанное). Если очередное считанное число на 29 не делится, то к ответу следует прибавить n29.Чтобы построить программу, эффективную по памяти, заметим, что, поскольку при обработке очередного элемента входных данных используются значения, находящиеся на четыре элемента ранее, достаточно хранить только четыре последних элемента или информацию о них. Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC). Пример 1. Программа на языке Паскаль. Программа эффективна по времени и памяти. const s = 4; {требуемое расстояние между элементами}var    n: longint;    a: array[1..s] of longint; {хранение последних s значений}    a_: longint; {очередное значение}    n29: longint; {количество делящихся на 29 элементов, не считая s последних}    cnt: longint; {количество искомых пар}    i, j: longint;begin    readln(n); {Ввод первых s чисел}    for i:=1 to s do        readln(a[i]); {Ввод остальных значений, подсчет искомых пар}    cnt := 0;    n29 := 0;    for i := s + 1 to n do    begin        if a[1] mod 29 = 0 then            n29 := n29 + 1;        readln(a_);        if a_ mod 29 = 0 then            cnt := cnt + i - s        else            cnt := cnt + n29;{сдвигаем элементы вспомогательного массива влево}        for j := 1 to s - 1 do            a[j] := a[j + 1];        a[s] := a_ {записываем текущий элемент в конец массива}    end;    writeln(cnt)end. Пример 2. Программа на языке Python. Программа эффективна по времени и памяти. s = 4a = [0]*sn = int(input())for i in range(s):    a[i] = int(input())cnt = 0n29 = 0for i in range(s, n):    k = i % s    if a[k] % 29 == 0:        n29 = n29 + 1    a_ = int(input())    if a_ % 29 == 0:        cnt = cnt + i - s + 1    else:        cnt = cnt + n29    a[i % s] = a_print(cnt) Пример 3. Программа на языке С++. Программа эффективна по времени и памяти.     #include     using namespace std;    int main()    {        int s = 4; //требуемое расстояние между элементами        int n;        int n1 = 0, n2 = 0, n3 = 0, n4 = 0;        //хранение последних s счетчиков        int a_; // очередное значение        int cnt; // количество искомых пар        cin >> n;        cnt = 0;        for (int i = 0; i < n; ++i)        {            cin >> a_; // считано очередное значение            if (i >= s)            {                if (a_ % 29 == 0)                    cnt += i - s + 1;                else                    cnt += n4;            }            //сдвигаем элементы счетчиков            n4 = n3;            n3 = n2;            n2 = n1;            //обновляем счетчик кратных 29            if (a_ % 29 == 0)                n1 += 1;        }        cout << cnt;        return 0;    } Пример 4. Программа на языке Паскаль. Программа эффективна по времени и неэффективна по памяти. const s = 4; {требуемое расстояние между элементами}var    n: longint;    a: array[1..1000] of longint;    n29: longint;    {количество делящихся на 29 элементов, не считая s последних}    cnt: longint; {количество искомых пар}    i, j: longint;begin    readln(n);    {Ввод первых s чисел}    for i:=1 to s do        readln(a[i]);    {Ввод остальных значений, подсчет искомых пар}    cnt := 0;    n29 := 0;    for i := s + 1 to n do    begin        readln(a[i]);        if a[i - s] mod 29 = 0 then            n29 := n29 + 1;        if a[i] mod 29 = 0 then            cnt := cnt + i - s        else            cnt := cnt + n29;    end;    writeln(cnt)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol16054\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 29, если хотя бы один из сомножителей делится на 29.<p class=\"left_margin\">При вводе чисел можно подсчитывать количество чисел, кратных 29, не считая четырёх последних. Обозначим их <i>n</i>29.<p class=\"left_margin\"><i>Примечание для проверяющего.</i> Сами числа, кроме четырёх последних, при этом можно не хранить.<p class=\"left_margin\">Очередное считанное число будем рассматривать как возможный правый элемент искомой пары. Если очередное считанное число делится на 29, то к ответу следует прибавить количество чисел до него, не считая четырёх последних (включая считанное). Если очередное считанное число на 29 не делится, то к ответу следует прибавить <i>n</i>29.<p class=\"left_margin\">Чтобы построить программу, эффективную по памяти, заметим, что, поскольку при обработке очередного элемента входных данных используются значения, находящиеся на четыре элемента ранее, достаточно хранить только четыре последних элемента или информацию о них. Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Пример 1. Программа на языке Паскаль. Программа эффективна по времени и памяти.</b><p> </p><pre>const s = 4; {требуемое расстояние между элементами}<p>var<p>    n: longint;<p>    a: array[1..s] of longint; {хранение последних s значений}<p>    a_: longint; {очередное значение}<p>    n29: longint; {количество делящихся на 29 элементов, не считая s последних}<p>    cnt: longint; {количество искомых пар}<p>    i, j: longint;<p>begin<p>    readln(n); {Ввод первых s чисел}<p>    for i:=1 to s do<p>        readln(a[i]); {Ввод остальных значений, подсчет искомых пар}<p>    cnt := 0;<p>    n29 := 0;<p>    for i := s + 1 to n do<p>    begin<p>        if a[1] mod 29 = 0 then<p>            n29 := n29 + 1;<p>        readln(a_);<p>        if a_ mod 29 = 0 then<p>            cnt := cnt + i - s<p>        else<p>            cnt := cnt + n29;<p>{сдвигаем элементы вспомогательного массива влево}<p>        for j := 1 to s - 1 do<p>            a[j] := a[j + 1];<p>        a[s] := a_ {записываем текущий элемент в конец массива}<p>    end;<p>    writeln(cnt)<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p class=\"left_margin\"><b>Пример 2. Программа на языке Python. Программа эффективна по времени и памяти.</b><p> </p><pre><p class=\"left_margin\">s = 4<p class=\"left_margin\">a = [0]*s<p class=\"left_margin\">n = int(input())<p class=\"left_margin\">for i in range(s):<p class=\"left_margin\">    a[i] = int(input())<p class=\"left_margin\">cnt = 0<p class=\"left_margin\">n29 = 0<p class=\"left_margin\">for i in range(s, n):<p class=\"left_margin\">    k = i % s<p class=\"left_margin\">    if a[k] % 29 == 0:<p class=\"left_margin\">        n29 = n29 + 1<p class=\"left_margin\">    a_ = int(input())<p class=\"left_margin\">    if a_ % 29 == 0:<p class=\"left_margin\">        cnt = cnt + i - s + 1<p class=\"left_margin\">    else:<p class=\"left_margin\">        cnt = cnt + n29<p class=\"left_margin\">    a[i % s] = a_<p class=\"left_margin\">print(cnt)</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p> </p><p class=\"left_margin\"><b>Пример 3. Программа на языке С++. Программа эффективна по времени и памяти.</b><p> </p><pre><p>    #include <iostream><p>    using namespace std;<p>    int main()<p>    {<p>        int s = 4; //требуемое расстояние между элементами<p>        int n;<p>        int n1 = 0, n2 = 0, n3 = 0, n4 = 0;<p>        //хранение последних s счетчиков<p>        int a_; // очередное значение<p>        int cnt; // количество искомых пар<p>        cin &gt;&gt; n;<p>        cnt = 0;<p>        for (int i = 0; i &lt; n; ++i)<p>        {<p>            cin &gt;&gt; a_; // считано очередное значение<p>            if (i &gt;= s)<p>            {<p>                if (a_ % 29 == 0)<p>                    cnt += i - s + 1;<p>                else<p>                    cnt += n4;<p>            }<p>            //сдвигаем элементы счетчиков<p>            n4 = n3;<p>            n3 = n2;<p>            n2 = n1;<p>            //обновляем счетчик кратных 29<p>            if (a_ % 29 == 0)<p>                n1 += 1;<p>        }<p>        cout &lt;&lt; cnt;<p>        return 0;<p>    }<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></iostream></p></pre><p> </p><p class=\"left_margin\"><b>Пример 4. Программа на языке Паскаль. Программа эффективна по времени и неэффективна по памяти.</b><p> </p><pre>const s = 4; {требуемое расстояние между элементами}<p>var<p>    n: longint;<p>    a: array[1..1000] of longint;<p>    n29: longint;<p>    {количество делящихся на 29 элементов, не считая s последних}<p>    cnt: longint; {количество искомых пар}<p>    i, j: longint;<p>begin<p>    readln(n);<p>    {Ввод первых s чисел}<p>    for i:=1 to s do<p>        readln(a[i]);<p>    {Ввод остальных значений, подсчет искомых пар}<p>    cnt := 0;<p>    n29 := 0;<p>    for i := s + 1 to n do<p>    begin<p>        readln(a[i]);<p>        if a[i - s] mod 29 = 0 then<p>            n29 := n29 + 1;<p>        if a[i] mod 29 = 0 then<p>            cnt := cnt + i - s<p>        else<p>            cnt := cnt + n29;<p>    end;<p>    writeln(cnt)<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Де­мон­стра­ци­он­ная вер­сия ЕГЭ—2019 по информатике.",
            "task_id": "16054"
        },
        {
            "answer": "Решение.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 6 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в следующем решении. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0; ia:=0;    for i:=s to N − 1 do begin        readln(x);        if a[ia] > m then m := a[ia];        if m+x > sm then sm := m+x;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(sm)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы. Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] > m then m := a[1];        if m+x > sm then sm := m+x;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x    end;    writeln(sm)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    sm: integer; {максимальная сумма пары}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    sm :=0;    for i := 1 to N − s do begin        for j := i+s to N do begin            if a[i]+a[j] > sm                then sm := a[i]+a[j]        end;    end;    writeln(sm)end.",
            "parsed": "2019-04-29 21:13:43.501186",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 друг от друга (разница в индексах элементов должна быть 6 или более). Необходимо определить максимальную сумму такой пары.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (7 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.Пример входных данных:813546798Пример выходных данных для приведённого выше примера входных данных:11Пояснение. Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Максимальная сумма чисел в этих парах равна 11.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929518\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 друг от друга (разница в индексах элементов должна быть 6 или более). Необходимо определить максимальную сумму такой пары.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (7 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">8<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">8<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">11<p class=\"left_margin\"><i>Пояснение.</i> Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Максимальная сумма чисел в этих парах равна 11.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 6 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в следующем решении. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0; ia:=0;    for i:=s to N − 1 do begin        readln(x);        if a[ia] > m then m := a[ia];        if m+x > sm then sm := m+x;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(sm)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы. Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] > m then m := a[1];        if m+x > sm then sm := m+x;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x    end;    writeln(sm)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    sm: integer; {максимальная сумма пары}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    sm :=0;    for i := 1 to N − s do begin        for j := i+s to N do begin            if a[i]+a[j] > sm                then sm := a[i]+a[j]        end;    end;    writeln(sm)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol16402\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 6 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в следующем решении.<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    m: integer; {максимальное число}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s − 1 do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    m:=0; sm:=0; ia:=0;<p class=\"left_margin\">    for i:=s to N − 1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] &gt; m then m := a[ia];<p class=\"left_margin\">        if m+x &gt; sm then sm := m+x;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы.<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    m: integer; {максимальное число}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    m:=0; sm:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] &gt; m then m := a[1];<p class=\"left_margin\">        if m+x &gt; sm then sm := m+x;<p class=\"left_margin\">        for ia:=1 to s-1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    sm :=0;<p class=\"left_margin\">    for i := 1 to N − s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if a[i]+a[j] &gt; sm<p class=\"left_margin\">                then sm := a[i]+a[j]<p class=\"left_margin\">        end;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "16402"
        },
        {
            "answer": "Решение.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 8 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 8 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 8 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 8 элементов можно использовать циклический массив, как показано в следующем решении. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0; ia:=0;    for i:=s to N − 1 do begin        readln(x);        if a[ia] > m then m := a[ia];        if m+x > sm then sm := m+x;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(sm)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 7 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы. Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] > m then m := a[1];        if m+x > sm then sm := m+x;        for ia:=1 to s − 1 do a[ia]:=a[ia+1];        a[s] := x    end;    writeln(sm)end. Возможно также «лобовое» решение: запишем в се и сходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    sm: integer; {максимальная сумма пары}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    sm :=0;    for i := 1 to N − s do begin        for j := i+s to N do begin            if a[i]+a[j] > sm                then sm := a[i]+a[j]        end;    end;    writeln(sm)end.",
            "parsed": "2019-04-29 21:13:43.900781",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 8 друг от друга (разница в индексах элементов должна быть 8 или более). Необходимо определить максимальную сумму такой пары.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (9 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10000.Пример входных данных:101354679101211Пример выходных данных для приведённого выше примера входных данных:14Пояснение. Из 10 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 9, 1 и 10, 2 и 10. Для заданного набора чисел получаем пары (1, 12), (1, 11), (3, 11). Максимальная сумма чисел в этих парах равна 14.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929460\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 8 друг от друга (разница в индексах элементов должна быть 8 или более). Необходимо определить максимальную сумму такой пары.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (9 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">10<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">10<p class=\"left_margin\">12<p class=\"left_margin\">11<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">14<p class=\"left_margin\"><i>Пояснение.</i> Из 10 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 9, 1 и 10, 2 и 10. Для заданного набора чисел получаем пары (1, 12), (1, 11), (3, 11). Максимальная сумма чисел в этих парах равна 14.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 8 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 8 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 8 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 8 элементов можно использовать циклический массив, как показано в следующем решении. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0; ia:=0;    for i:=s to N − 1 do begin        readln(x);        if a[ia] > m then m := a[ia];        if m+x > sm then sm := m+x;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(sm)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 7 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы. Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    m: integer; {максимальное число}    sm: integer; {максимальная сумма пары}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    m:=0; sm:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] > m then m := a[1];        if m+x > sm then sm := m+x;        for ia:=1 to s − 1 do a[ia]:=a[ia+1];        a[s] := x    end;    writeln(sm)end. Возможно также «лобовое» решение: запишем в се и сходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=8; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    sm: integer; {максимальная сумма пары}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    sm :=0;    for i := 1 to N − s do begin        for j := i+s to N do begin            if a[i]+a[j] > sm                then sm := a[i]+a[j]        end;    end;    writeln(sm)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol16456\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 8 чисел не могут быть такими элементами). Для получения максимальной суммы нужно сложить это число с максимальным из всех элементов, расположенных от начала последовательности до элемента, расположенного на 8 позиций раньше текущего. Будем хранить этот максимум и корректировать его при вводе каждого нового элемента. Для этого понадобится хранить последние 8 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 8 элементов можно использовать циклический массив, как показано в следующем решении.<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=8; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    m: integer; {максимальное число}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s − 1 do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    m:=0; sm:=0; ia:=0;<p class=\"left_margin\">    for i:=s to N − 1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] &gt; m then m := a[ia];<p class=\"left_margin\">        if m+x &gt; sm then sm := m+x;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 7 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы.<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=8; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    m: integer; {максимальное число}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    m:=0; sm:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] &gt; m then m := a[1];<p class=\"left_margin\">        if m+x &gt; sm then sm := m+x;<p class=\"left_margin\">        for ia:=1 to s − 1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем в се и сходные числа в массив, переберём все возможные пары и выберем из них требуемую. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=8; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    sm: integer; {максимальная сумма пары}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    sm :=0;<p class=\"left_margin\">    for i := 1 to N − s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if a[i]+a[j] &gt; sm<p class=\"left_margin\">                then sm := a[i]+a[j]<p class=\"left_margin\">        end;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(sm)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "16456"
        },
        {
            "answer": "Решение.Произведение двух чисел кратно 6, если хотя бы одно из этих чисел кратно 6, или если одно из чисел кратно 2, а другое кратно 3.Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n3 — кратных 3, и n6 — кратных 6.Все эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом). Если этот элемент кратен 6, он образует n1 подходящих пар, если кратен 3 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 3 — n3, в остальных случаях — n6 Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    n1,n2,n3,n6: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n3:=0; n6:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 6 = 0 then n6 := n6 + 1;        if a[ia] mod 3 = 0 then n3 := n3 + 1;        if a[ia] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 6 = 0 then k := k + n1        else if x mod 3 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n3        else k := k + n6;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k);end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    n1,n2,n3,n6: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n3:=0; n6:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 6 = 0 then n6 := n6 + 1;        if a[1] mod 3 = 0 then n3 := n3 + 1;        if a[1] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 6 = 0 then k := k +n1        else if x mod 3 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n3        else k := k + n6;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if a[i]*a[j] mod 6 = 0                then k := k + 1;        end;    end;    writeln(k);end.",
            "parsed": "2019-04-29 21:13:44.359649",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, произведение чисел в которых кратно 6.Описание входных и выходных данных.первой строке входных данных задаётся количество чисел N (6 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:813546798Пример выходных данных для приведённого выше примера входных данных:1Пояснение. Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Произведения чисел в этих парах равны 9, 8, 24. На 6 делится одно из этих произведений.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929602\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, произведение чисел в которых кратно 6.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p>первой строке входных данных задаётся количество чисел <i>N</i> (6 ≤ N ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">8<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">8<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">1<p class=\"left_margin\"><i>Пояснение.</i> Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Произведения чисел в этих парах равны 9, 8, 24. На 6 делится одно из этих произведений.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел кратно 6, если хотя бы одно из этих чисел кратно 6, или если одно из чисел кратно 2, а другое кратно 3.Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n3 — кратных 3, и n6 — кратных 6.Все эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом). Если этот элемент кратен 6, он образует n1 подходящих пар, если кратен 3 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 3 — n3, в остальных случаях — n6 Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    n1,n2,n3,n6: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n3:=0; n6:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 6 = 0 then n6 := n6 + 1;        if a[ia] mod 3 = 0 then n3 := n3 + 1;        if a[ia] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 6 = 0 then k := k + n1        else if x mod 3 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n3        else k := k + n6;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k);end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    n1,n2,n3,n6: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n3:=0; n6:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 6 = 0 then n6 := n6 + 1;        if a[1] mod 3 = 0 then n3 := n3 + 1;        if a[1] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 6 = 0 then k := k +n1        else if x mod 3 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n3        else k := k + n6;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if a[i]*a[j] mod 6 = 0                then k := k + 1;        end;    end;    writeln(k);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol16830\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел кратно 6, если хотя бы одно из этих чисел кратно 6, или если одно из чисел кратно 2, а другое кратно 3.<p class=\"left_margin\">Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n3 — кратных 3, и n6 — кратных 6.<p class=\"left_margin\">Все эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.<p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом). Если этот элемент кратен 6, он образует n1 подходящих пар, если кратен 3 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 3 — n3, в остальных случаях — n6<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    n1,n2,n3,n6: integer; {счетчики}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s − 1 do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    n1:=0; n2:=0; n3:=0; n6:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s to N-1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] mod 6 = 0 then n6 := n6 + 1;<p class=\"left_margin\">        if a[ia] mod 3 = 0 then n3 := n3 + 1;<p class=\"left_margin\">        if a[ia] mod 2 = 0 then n2 := n2 + 1;<p class=\"left_margin\">        n1 := n1 +1;<p class=\"left_margin\">        if x mod 6 = 0 then k := k + n1<p class=\"left_margin\">        else if x mod 3 = 0 then k := k + n2<p class=\"left_margin\">        else if x mod 2 = 0 then k := k + n3<p class=\"left_margin\">        else k := k + n6;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    n1,n2,n3,n6: integer; {счетчики}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    n1:=0; n2:=0; n3:=0; n6:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] mod 6 = 0 then n6 := n6 + 1;<p class=\"left_margin\">        if a[1] mod 3 = 0 then n3 := n3 + 1;<p class=\"left_margin\">        if a[1] mod 2 = 0 then n2 := n2 + 1;<p class=\"left_margin\">        n1 := n1 +1;<p class=\"left_margin\">        if x mod 6 = 0 then k := k +n1<p class=\"left_margin\">        else if x mod 3 = 0 then k := k + n2<p class=\"left_margin\">        else if x mod 2 = 0 then k := k + n3<p class=\"left_margin\">        else k := k + n6;<p class=\"left_margin\">        for ia:=1 to s-1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    k :=0;<p class=\"left_margin\">    for i := 1 to N-s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if a[i]*a[j] mod 6 = 0<p class=\"left_margin\">                then k := k + 1;<p class=\"left_margin\">        end;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "16830"
        },
        {
            "answer": "Решение.Произведение двух чисел кратно 10, если хотя бы одно из этих чисел кратно 10, или если одно из чисел кратно 2, а другое кратно 5.Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n5 — кратных 5, и n10 — кратных 10.Все эти счётчики будем вести без учёта 10 последних элементов. Для этого понадобится хранить последние 10 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 10 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 10 чисел не могут быть таким элементом). Если этот элемент кратен 10, он образует n1 подходящих пар, если кратен 5 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 5 — n5, в остальных случаях — n10. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    n1,n2,n5,n10: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n5:=0; n10:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 10 = 0 then n10 := n10 + 1;        if a[ia] mod 5 = 0 then n5 := n5 + 1;        if a[ia] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 10 = 0 then k := k + n1        else if x mod 5 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n5        else k := k + n10;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k);end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    n1,n2,n5,n10: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n5:=0; n10:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 10 = 0 then n10 := n10 + 1;        if a[1] mod 5 = 0 then n5 := n5 + 1;        if a[1] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 10 = 0 then k := k + n1        else if x mod 5 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n5        else k := k + n10;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if a[i]*a[j] mod 10 = 0                then k := k + 1;        end;    end;    writeln(k);end.",
            "parsed": "2019-04-29 21:13:44.741314",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 10 (разница в индексах элементов должна быть 10 или более). Необходимо определить количество пар, произведение чисел в которых кратно 10.Описание входных и выходных данных.первой строке входных данных задаётся количество чисел N (10 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:1215589412146798Пример выходных данных для приведённого выше примера входных данных:1Пояснение. Из 12 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 11, 1 и 12, 2 и 12. Для заданного набора чисел получаем пары (1, 9), (1, 8), (5, 8). Произведения чисел в этих парах равны 9, 8, 40. На 10 делится одно из этих произведений.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929019\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 10 (разница в индексах элементов должна быть 10 или более). Необходимо определить количество пар, произведение чисел в которых кратно 10.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p>первой строке входных данных задаётся количество чисел <i>N</i> (10 ≤ N ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">12<p class=\"left_margin\">1<p class=\"left_margin\">5<p class=\"left_margin\">5<p class=\"left_margin\">8<p class=\"left_margin\">9<p class=\"left_margin\">4<p class=\"left_margin\">12<p class=\"left_margin\">14<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">8<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">1<p class=\"left_margin\"><i>Пояснение.</i> Из 12 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 11, 1 и 12, 2 и 12. Для заданного набора чисел получаем пары (1, 9), (1, 8), (5, 8). Произведения чисел в этих парах равны 9, 8, 40. На 10 делится одно из этих произведений.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел кратно 10, если хотя бы одно из этих чисел кратно 10, или если одно из чисел кратно 2, а другое кратно 5.Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n5 — кратных 5, и n10 — кратных 10.Все эти счётчики будем вести без учёта 10 последних элементов. Для этого понадобится хранить последние 10 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 10 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 10 чисел не могут быть таким элементом). Если этот элемент кратен 10, он образует n1 подходящих пар, если кратен 5 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 5 — n5, в остальных случаях — n10. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[0..s-1] of integer;    n1,n2,n5,n10: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s − 1 do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n5:=0; n10:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 10 = 0 then n10 := n10 + 1;        if a[ia] mod 5 = 0 then n5 := n5 + 1;        if a[ia] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 10 = 0 then k := k + n1        else if x mod 5 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n5        else k := k + n10;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k);end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    x: integer; {очередное число}    a: array[1..s] of integer;    n1,n2,n5,n10: integer; {счетчики}    k: integer; {количество пар}    i: integer; {счётчик для ввода}    ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {ввод и обработка остальных значений}    n1:=0; n2:=0; n5:=0; n10:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 10 = 0 then n10 := n10 + 1;        if a[1] mod 5 = 0 then n5 := n5 + 1;        if a[1] mod 2 = 0 then n2 := n2 + 1;        n1 := n1 +1;        if x mod 10 = 0 then k := k + n1        else if x mod 5 = 0 then k := k + n2        else if x mod 2 = 0 then k := k + n5        else k := k + n10;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k);end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC). Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=10; {требуемое расстояние между элементами}var    N: integer; {количество чисел}    a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if a[i]*a[j] mod 10 = 0                then k := k + 1;        end;    end;    writeln(k);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol16903\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел кратно 10, если хотя бы одно из этих чисел кратно 10, или если одно из чисел кратно 2, а другое кратно 5.<p class=\"left_margin\">Будем подсчитывать общее количество n1 элементов последовательности, количество n2 элементов, кратных 2, n5 — кратных 5, и n10 — кратных 10.<p class=\"left_margin\">Все эти счётчики будем вести без учёта 10 последних элементов. Для этого понадобится хранить последние 10 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 10 элементов можно использовать циклический массив, как показано в решении 1.<p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 10 чисел не могут быть таким элементом). Если этот элемент кратен 10, он образует n1 подходящих пар, если кратен 5 и не кратен 2 — n2 подходящих пар, если кратен 2 и не кратен 5 — n5, в остальных случаях — n10.<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=10; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    n1,n2,n5,n10: integer; {счетчики}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s − 1 do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    n1:=0; n2:=0; n5:=0; n10:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s to N-1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] mod 10 = 0 then n10 := n10 + 1;<p class=\"left_margin\">        if a[ia] mod 5 = 0 then n5 := n5 + 1;<p class=\"left_margin\">        if a[ia] mod 2 = 0 then n2 := n2 + 1;<p class=\"left_margin\">        n1 := n1 +1;<p class=\"left_margin\">        if x mod 10 = 0 then k := k + n1<p class=\"left_margin\">        else if x mod 5 = 0 then k := k + n2<p class=\"left_margin\">        else if x mod 2 = 0 then k := k + n5<p class=\"left_margin\">        else k := k + n10;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления максимума всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=10; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    n1,n2,n5,n10: integer; {счетчики}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i: integer; {счётчик для ввода}<p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]);<p class=\"left_margin\">    {ввод и обработка остальных значений}<p class=\"left_margin\">    n1:=0; n2:=0; n5:=0; n10:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] mod 10 = 0 then n10 := n10 + 1;<p class=\"left_margin\">        if a[1] mod 5 = 0 then n5 := n5 + 1;<p class=\"left_margin\">        if a[1] mod 2 = 0 then n2 := n2 + 1;<p class=\"left_margin\">        n1 := n1 +1;<p class=\"left_margin\">        if x mod 10 = 0 then k := k + n1<p class=\"left_margin\">        else if x mod 5 = 0 then k := k + n2<p class=\"left_margin\">        else if x mod 2 = 0 then k := k + n5<p class=\"left_margin\">        else k := k + n10;<p class=\"left_margin\">        for ia:=1 to s-1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC).<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=10; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел}<p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    k :=0;<p class=\"left_margin\">    for i := 1 to N-s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if a[i]*a[j] mod 10 = 0<p class=\"left_margin\">                then k := k + 1;<p class=\"left_margin\">        end;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k);<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "16903"
        },
        {
            "answer": "Решение.Сумма двух чисел нечётна, если эти числа имеют разную чётность.Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[0..s-1] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s-1 do readln(a[i]);     {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n1        else k := k + n0;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[1..s] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);     {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n1        else k := k + n0;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]+a[j]) mod 2 = 1                then k := k + 1        end    end;    writeln(k)end.",
            "parsed": "2019-04-29 21:13:45.205561",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, сумма чисел в которых нечётна.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (6 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:813546798Пример выходных данных для приведённого выше примера входных данных:2Пояснение. Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Суммы чисел в этих парах равны 10, 9, 11. Нечётных сумм — две.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929085\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, сумма чисел в которых нечётна.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (6 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">8<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">8<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">2<p class=\"left_margin\"><i>Пояснение.</i> Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Суммы чисел в этих парах равны 10, 9, 11. Нечётных сумм — две.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Сумма двух чисел нечётна, если эти числа имеют разную чётность.Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар. Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[0..s-1] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s-1 do readln(a[i]);     {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n1        else k := k + n0;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[1..s] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]);     {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n1        else k := k + n0;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]+a[j]) mod 2 = 1                then k := k + 1        end    end;    writeln(k)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol17345\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Сумма двух чисел нечётна, если эти числа имеют разную чётность.<p class=\"left_margin\">Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.<p class=\"left_margin\">Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.<p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар.<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    n0,n1 : integer; {счётчики чётных и нечётных элементов}<p class=\"left_margin\">    k: integer; {количество пар} <p class=\"left_margin\">    i: integer; {счётчик для ввода} <p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s-1 do readln(a[i]); <p class=\"left_margin\">    {ввод и обработка остальных значений} <p class=\"left_margin\">    n0:=0; n1:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s to N-1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] mod 2 = 0 then n0 := n0 + 1<p class=\"left_margin\">        else n1 := n1 + 1;<p class=\"left_margin\">        if x mod 2 = 0 then k := k + n1<p class=\"left_margin\">        else k := k + n0;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    n0,n1 : integer; {счётчики чётных и нечётных элементов}<p class=\"left_margin\">    k: integer; {количество пар} <p class=\"left_margin\">    i: integer; {счётчик для ввода} <p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]); <p class=\"left_margin\">    {ввод и обработка остальных значений} <p class=\"left_margin\">    n0:=0; n1:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] mod 2 = 0 then n0 := n0 + 1<p class=\"left_margin\">        else n1 := n1 + 1;<p class=\"left_margin\">        if x mod 2 = 0 then k := k + n1<p class=\"left_margin\">        else k := k + n0;<p class=\"left_margin\">        for ia:=1 to s-1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    k :=0;<p class=\"left_margin\">    for i := 1 to N-s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if (a[i]+a[j]) mod 2 = 1<p class=\"left_margin\">                then k := k + 1<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "17345"
        },
        {
            "answer": "Решение.Сумма двух чисел чётна, если эти числа имеют одинаковую чётность.Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[0..s-1] of integer;    n0, n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s-1 do readln(a[i]);  {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n0        else k := k + n1;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var     N: integer; {количество чисел}     x: integer; {очередное число}    a: array[1..s] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]); {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n0        else k := k + n1;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var     N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]+a[j]) mod 2 = 0                then k := k + 1        end    end;    writeln(k)end.",
            "parsed": "2019-04-29 21:13:45.689780",
            "question": "Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, сумма чисел в которых чётна.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (6 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10 000.Пример входных данных:813546798Пример выходных данных для приведённого выше примера входных данных:1Пояснение. Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Суммы чисел в этих парах равны 10, 9, 11. Чётная сумма — одна.Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body929043\" width=\"100%\"><p class=\"left_margin\">Дана последовательность <i>N</i> целых положительных чисел. Рассматриваются все пары элементов последовательности, находящихся на расстоянии не меньше 6 (разница в индексах элементов должна быть 6 или более). Необходимо определить количество пар, сумма чисел в которых чётна.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (6 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10 000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">8<p class=\"left_margin\">1<p class=\"left_margin\">3<p class=\"left_margin\">5<p class=\"left_margin\">4<p class=\"left_margin\">6<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">8<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">1<p class=\"left_margin\"><i>Пояснение.</i> Из 8 чисел можно составить 3 пары, удовлетворяющие условию. Это будут элементы с индексами 1 и 7, 1 и 8, 2 и 8. Для заданного набора чисел получаем пары (1, 9), (1, 8), (3, 8). Суммы чисел в этих парах равны 10, 9, 11. Чётная сумма — одна.<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Сумма двух чисел чётна, если эти числа имеют одинаковую чётность.Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар Решение 1. Правильная и эффективная программы на языке Паскаль (использован циклический массив): const s=6; {требуемое расстояние между элементами}var    N: integer; {количество чисел}     x: integer; {очередное число}    a: array[0..s-1] of integer;    n0, n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {текущий индекс в массиве a}begin    readln(N);    {ввод первых s чисел}    for i:=0 to s-1 do readln(a[i]);  {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s to N-1 do begin        readln(x);        if a[ia] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n0        else k := k + n1;        a[ia] := x;        ia := (ia+1) mod s    end;    writeln(k)end. Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в k раз количество действий растёт не более чем в k раз. Ниже приводится пример такой программы Решение 2. Правильная и эффективная программы на языке Паскаль (использован сдвиг массива) const s=6; {требуемое расстояние между элементами}var     N: integer; {количество чисел}     x: integer; {очередное число}    a: array[1..s] of integer;    n0,n1 : integer; {счётчики чётных и нечётных элементов}    k: integer; {количество пар}     i: integer; {счётчик для ввода}     ia: integer; {счётчик для сдвига}begin    readln(N);    {ввод первых s чисел}    for i:=1 to s do readln(a[i]); {ввод и обработка остальных значений}     n0:=0; n1:=0;    k := 0; ia:=0;    for i:=s+1 to N do begin        readln(x);        if a[1] mod 2 = 0 then n0 := n0 + 1        else n1 := n1 + 1;        if x mod 2 = 0 then k := k + n0        else k := k + n1;        for ia:=1 to s-1 do a[ia]:=a[ia+1];        a[s] := x;    end;    writeln(k)end. Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов. Решение 3. Правильная, но неэффективная программы на языке Паскаль: const s=6; {требуемое расстояние между элементами}var     N: integer; {количество чисел}     a: array [1..1000] of integer; {исходные данные}    k: integer; {количество пар}    i,j: integer;begin    readln(N);    for i:=1 to N do readln(a[i]);    k :=0;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]+a[j]) mod 2 = 0                then k := k + 1        end    end;    writeln(k)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol17391\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Сумма двух чисел чётна, если эти числа имеют одинаковую чётность.<p class=\"left_margin\">Будем подсчитывать отдельно количество чётных и нечётных элементов последовательности.<p class=\"left_margin\">Эти счётчики будем вести без учёта 6 последних элементов. Для этого понадобится хранить последние 6 элементов. Остальные элементы последовательности можно не хранить, это обеспечивает эффективность по памяти. Для хранения 6 элементов можно использовать циклический массив, как показано в решении 1.<p class=\"left_margin\">Будем рассматривать каждое введённое число как правый элемент возможной пары (первые 6 чисел не могут быть таким элементом) и в зависимости от его чётности определять количество подходящих пар<p> </p><p class=\"left_margin\"><b>Решение 1.</b> Правильная и эффективная программы на языке Паскаль (использован циклический массив):<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var<p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[0..s-1] of integer;<p class=\"left_margin\">    n0, n1 : integer; {счётчики чётных и нечётных элементов}<p class=\"left_margin\">    k: integer; {количество пар} <p class=\"left_margin\">    i: integer; {счётчик для ввода} <p class=\"left_margin\">    ia: integer; {текущий индекс в массиве a}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=0 to s-1 do readln(a[i]);  {ввод и обработка остальных значений} <p class=\"left_margin\">    n0:=0; n1:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s to N-1 do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[ia] mod 2 = 0 then n0 := n0 + 1<p class=\"left_margin\">        else n1 := n1 + 1;<p class=\"left_margin\">        if x mod 2 = 0 then k := k + n0<p class=\"left_margin\">        else k := k + n1;<p class=\"left_margin\">        a[ia] := x;<p class=\"left_margin\">        ia := (ia+1) mod s<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Вместо циклического массива можно использовать сдвиги. В этом случае для вычисления всегда используется первый элемент массива, а новое число записывается в последний. Хотя этот алгоритм работает медленнее, чем алгоритм с циклическим массивом (для каждого элемента требуется 5 дополнительных присваиваний при сдвигах), основное требование эффективности здесь выполнено: при увеличении размера массива в <i>k</i> раз количество действий растёт не более чем в <i>k</i> раз. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\"><b>Решение 2.</b> Правильная и эффективная программы на языке Паскаль (использован сдвиг массива)<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var <p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    x: integer; {очередное число}<p class=\"left_margin\">    a: array[1..s] of integer;<p class=\"left_margin\">    n0,n1 : integer; {счётчики чётных и нечётных элементов}<p class=\"left_margin\">    k: integer; {количество пар} <p class=\"left_margin\">    i: integer; {счётчик для ввода} <p class=\"left_margin\">    ia: integer; {счётчик для сдвига}<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    {ввод первых s чисел}<p class=\"left_margin\">    for i:=1 to s do readln(a[i]); {ввод и обработка остальных значений} <p class=\"left_margin\">    n0:=0; n1:=0;<p class=\"left_margin\">    k := 0; ia:=0;<p class=\"left_margin\">    for i:=s+1 to N do begin<p class=\"left_margin\">        readln(x);<p class=\"left_margin\">        if a[1] mod 2 = 0 then n0 := n0 + 1<p class=\"left_margin\">        else n1 := n1 + 1;<p class=\"left_margin\">        if x mod 2 = 0 then k := k + n0<p class=\"left_margin\">        else k := k + n1;<p class=\"left_margin\">        for ia:=1 to s-1 do a[ia]:=a[ia+1];<p class=\"left_margin\">        a[s] := x;<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.<p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше 2 баллов.<p> </p><p class=\"left_margin\"><b>Решение 3.</b> Правильная, но неэффективная программы на языке Паскаль:<p> </p><p class=\"left_margin\">const s=6; {требуемое расстояние между элементами}<p class=\"left_margin\">var <p class=\"left_margin\">    N: integer; {количество чисел} <p class=\"left_margin\">    a: array [1..1000] of integer; {исходные данные}<p class=\"left_margin\">    k: integer; {количество пар}<p class=\"left_margin\">    i,j: integer;<p class=\"left_margin\">begin<p class=\"left_margin\">    readln(N);<p class=\"left_margin\">    for i:=1 to N do readln(a[i]);<p class=\"left_margin\">    k :=0;<p class=\"left_margin\">    for i := 1 to N-s do begin<p class=\"left_margin\">        for j := i+s to N do begin<p class=\"left_margin\">            if (a[i]+a[j]) mod 2 = 0<p class=\"left_margin\">                then k := k + 1<p class=\"left_margin\">        end<p class=\"left_margin\">    end;<p class=\"left_margin\">    writeln(k)<p class=\"left_margin\">end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "17391"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 62, если выполнено одно из следующих условий (условия не могут выполняться одновременно).А. Оба сомножителя делятся на 62.Б. Один из сомножителей делится на 62, а другой не делится.В. Ни один из сомножителей не делится на 62, но один сомножитель делится на 2, а другой — на 31.При вводе чисел можно определять, делится ли каждое из них на 62, 2 и 31, и подсчитывать следующие значения:1) n62 — количество чисел, кратных 62;2) n31 — количество чисел, кратных 31, но не кратных 62;3) n2 — количество чисел, кратных 2, но не кратных 62.Количество пар, удовлетворяющих условию А, можно вычислить по формуле n62 · (n62 – 1)/2.Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n62 · (N – n62). Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2 · n31.Поэтому искомое количество пар вычисляется по формуле n62 · (n62 – 1)/2 + n62 · (N – n62) + n2 · n31.Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC)  Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памятиvar     N: integer; {количество чисел}      a: integer; {очередное число}      n62, n31, n2: integer;      k62: integer; {количество требуемых пар}      i: integer; begin     readln(N);     n62:=0; n31:=0; n2:=0;     for i:=1 to N do begin          readln(a);          if a mod 62 = 0 then              n62 := n62 + 1        else if a mod 31 = 0 then             n31 := n31 + 1         else if a mod 2 = 0 then             n2 := n2 + 1;     end;     k62 := n62*(n62-1) div 2 + n62*(N-n62) + n2*n31;     writeln(k62)end.  Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль varN, count: integer;a: array[1..1000] of integer;i, j: integer;begin    readln(N);    count := 0;    for i := 1 to N do        readln(a[i]);    for i := 1 to N do        for j := i to N do            if (a[i] * a[j]) mod 62 = 0 then                 count := count + 1;    writeln(count);end.",
            "parsed": "2019-04-29 21:13:46.116280",
            "question": "На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре неважен). Необходимо определить количество пар, для которых произведение элементов кратно 62.Описание входных и выходных данных.В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно натуральное число, не превышающее 10000. В качестве результата программа должна вывести одно число: количество пар, в которых произведение элементов кратно 62.Пример входных данных:526133193Пример выходных данных для приведённого выше примера входных данных:4Пояснение. Из 5 чисел можно составить 4 пары, удовлетворяющие условию. Для заданного набора чисел получаем пары (2, 31), (2, 93), (6, 31), (6, 93).Напишите эффективную по времени и по памяти программу для решения этой задачи.Программа считается эффективной по времени, если при увеличении количества исходных чисел N в k раз время работы программы увеличивается не более чем в k раз.Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом N.Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body927820\" width=\"100%\"><p class=\"left_margin\">На вход программы поступает последовательность из <i>N</i> целых положительных чисел, все числа в последовательности различны. Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре неважен). Необходимо определить количество пар, для которых произведение элементов кратно 62.<p class=\"left_margin\"><b>Описание входных и выходных данных.</b><p class=\"left_margin\">В первой строке входных данных задаётся количество чисел <i>N</i> (1 ≤ <i>N</i> ≤ 1000). В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 10000. В качестве результата программа должна вывести одно число: количество пар, в которых произведение элементов кратно 62.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">2<p class=\"left_margin\">6<p class=\"left_margin\">13<p class=\"left_margin\">31<p class=\"left_margin\">93<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">4<p class=\"left_margin\"><i>Пояснение.</i> Из 5 чисел можно составить 4 пары, удовлетворяющие условию. Для заданного набора чисел получаем пары (2, 31), (2, 93), (6, 31), (6, 93).<p class=\"left_margin\">Напишите эффективную по времени и по памяти программу для решения этой задачи.<p class=\"left_margin\">Программа считается эффективной по времени, если при увеличении количества исходных чисел <i>N</i> в <i>k</i> раз время работы программы увеличивается не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если память, необходимая для хранения всех переменных программы, не превышает 1 килобайта и не увеличивается с ростом <i>N</i>.<p class=\"left_margin\">Максимальная оценка за правильную (не содержащую синтаксических ошибок и дающую правильный ответ при любых допустимых входных данных) программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную только по времени или только по памяти, — 3 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, не удовлетворяющую требованиям эффективности, — 2 балла.<p class=\"left_margin\">Вы можете сдать одну или две программы решения задачи. Если Вы сдадите две программы, каждая из них будет оцениваться независимо от другой, итоговой станет бо́льшая из двух оценок.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения. Укажите использованный язык программирования и его версию.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 62, если выполнено одно из следующих условий (условия не могут выполняться одновременно).А. Оба сомножителя делятся на 62.Б. Один из сомножителей делится на 62, а другой не делится.В. Ни один из сомножителей не делится на 62, но один сомножитель делится на 2, а другой — на 31.При вводе чисел можно определять, делится ли каждое из них на 62, 2 и 31, и подсчитывать следующие значения:1) n62 — количество чисел, кратных 62;2) n31 — количество чисел, кратных 31, но не кратных 62;3) n2 — количество чисел, кратных 2, но не кратных 62.Количество пар, удовлетворяющих условию А, можно вычислить по формуле n62 · (n62 – 1)/2.Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n62 · (N – n62). Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2 · n31.Поэтому искомое количество пар вычисляется по формуле n62 · (n62 – 1)/2 + n62 · (N – n62) + n2 · n31.Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC)  Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памятиvar     N: integer; {количество чисел}      a: integer; {очередное число}      n62, n31, n2: integer;      k62: integer; {количество требуемых пар}      i: integer; begin     readln(N);     n62:=0; n31:=0; n2:=0;     for i:=1 to N do begin          readln(a);          if a mod 62 = 0 then              n62 := n62 + 1        else if a mod 31 = 0 then             n31 := n31 + 1         else if a mod 2 = 0 then             n2 := n2 + 1;     end;     k62 := n62*(n62-1) div 2 + n62*(N-n62) + n2*n31;     writeln(k62)end.  Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC) Пример правильной, но неэффективной программы на языке Паскаль varN, count: integer;a: array[1..1000] of integer;i, j: integer;begin    readln(N);    count := 0;    for i := 1 to N do        readln(a[i]);    for i := 1 to N do        for j := i to N do            if (a[i] * a[j]) mod 62 = 0 then                 count := count + 1;    writeln(count);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol18096\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 62, если выполнено одно из следующих условий (условия не могут выполняться одновременно).<p class=\"left_margin\">А. Оба сомножителя делятся на 62.<p class=\"left_margin\">Б. Один из сомножителей делится на 62, а другой не делится.<p class=\"left_margin\">В. Ни один из сомножителей не делится на 62, но один сомножитель делится на 2, а другой — на 31.<p class=\"left_margin\">При вводе чисел можно определять, делится ли каждое из них на 62, 2 и 31, и подсчитывать следующие значения:<p class=\"left_margin\">1) n62 — количество чисел, кратных 62;<p class=\"left_margin\">2) n31 — количество чисел, кратных 31, но не кратных 62;<p class=\"left_margin\">3) n2 — количество чисел, кратных 2, но не кратных 62.<p class=\"left_margin\">Количество пар, удовлетворяющих условию А, можно вычислить по формуле n62 · (n62 – 1)/2.<p class=\"left_margin\">Количество пар, удовлетворяющих условию Б, можно вычислить по формуле n62 · (N – n62). <p class=\"left_margin\">Количество пар, удовлетворяющих условию В, можно вычислить по формуле n2 · n31.<p class=\"left_margin\">Поэтому искомое количество пар вычисляется по формуле n62 · (n62 – 1)/2 + n62 · (N – n62) + n2 · n31.<p class=\"left_margin\">Ниже приведена реализующая описанный алгоритм программа на языке Паскаль (использована версия PascalABC) <p> </p><p class=\"left_margin\"><b>Пример 1. Программа на языке Паскаль. Программа эффективна по времени и по памяти</b><p><tt><p>var<p>     N: integer; {количество чисел}<p>      a: integer; {очередное число}<p>      n62, n31, n2: integer;<p>      k62: integer; {количество требуемых пар}<p>      i: integer;<p> </p><p>begin<p>     readln(N);<p>     n62:=0; n31:=0; n2:=0;<p>     for i:=1 to N do begin<p>          readln(a);<p>          if a mod 62 = 0 then<p>              n62 := n62 + 1<p>        else if a mod 31 = 0 then<p>             n31 := n31 + 1<p>         else if a mod 2 = 0 then<p>             n2 := n2 + 1;<p>     end;<p>     k62 := n62*(n62-1) div 2 + n62*(N-n62) + n2*n31;<p>     writeln(k62)<p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Возможно также «лобовое» решение: запишем все исходные числа в массив, переберём все возможные пары и подсчитаем количество подходящих. Такое решение не является эффективным ни по памяти (требуемая память зависит от размера исходных данных), ни по времени (количество возможных пар, а значит, количество действий и время счёта с ростом количества исходных элементов растёт квадратично). Такая программа оценивается не выше двух баллов.<p class=\"left_margin\">Ниже приведена реализующая описанный выше алгоритм программа на языке Паскаль (использована версия PascalABC)<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль</b><p> </p><pre><p>var<p class=\"left_margin\">N, count: integer;<p>a: array[1..1000] of integer;<p>i, j: integer;<p>begin<p>    readln(N);<p>    count := 0;<p>    for i := 1 to N do<p>        readln(a[i]);<p>    for i := 1 to N do<p>        for j := i to N do<p>            if (a[i] * a[j]) mod 62 = 0 then <p>                count := count + 1;<p>    writeln(count);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ — 2019. До­сроч­ная волна. Вариант 1.",
            "task_id": "18096"
        },
        {
            "answer": "Решение.varmin, ans: array[92..98] of integer;c: char;i, k, N, b: integer;beginfor i:=92 to 98 dobeginmin[i]:=3001;{допустимо и другое число, > 3000}ans[i]:=0;end;readln(N);for i:=1 to N dobeginrepeatread(c);until c=' '; {считана компания}repeatread(c);until c=' '; {считана улица}readln(k,b);if min[k] > b thenbeginmin[k]:=b;ans[k]:=1end elseif min[k] = b then ans[k]:=ans[k]+1;end;{если бензина какой-то марки не было,ans[i] осталось равным 0}writeln(ans[92],' ', ans[95],' ', ans[98])end.",
            "parsed": "2019-04-29 21:13:54.285110",
            "question": " На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида бензина, сколько АЗС продают его дешевле всего. На вход программе в первой строке подается число данных о стоимости бензина. В каждой из последующих N строк находится информация в следующем формате:<Компания> <Улица> <Марка> <Цена>где <Компания> – строка, состоящая не более, чем из 20 символов без пробелов, <Улица> – строка, состоящая не более, чем из 20 символов без пробелов, <Марка> – одно из чисел – 92, 95 или 98, <Цена> – целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. <Компания> и <Улица>, <Улица> и <Марка>, а также <Марка> и <цена> разделены ровно одним пробелом. Пример входной строки:Синойл Цветочная 95 2250Программа должна выводить через пробел 3 числа – количество АЗС, продающих дешевле всего 92-й, 95-й и 98-й бензин соответственно. Если бензин какой-то марки нигде не продавался, то следует вывести 0.Пример выходных данных:12 1 0",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942817\" width=\"100%\"><p class=\"left_margin\"> На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.<p class=\"left_margin\">Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида бензина, сколько АЗС продают его дешевле всего. На вход программе в первой строке подается число данных о стоимости бензина. В каждой из последующих N строк находится информация в следующем формате:<p>&lt;Компания&gt; &lt;Улица&gt; &lt;Марка&gt; &lt;Цена&gt;<p>где &lt;Компания&gt; – строка, состоящая не более, чем из 20 символов без пробелов, &lt;Улица&gt; – строка, состоящая не более, чем из 20 символов без пробелов, &lt;Марка&gt; – одно из чисел – 92, 95 или 98, &lt;Цена&gt; – целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. &lt;Компания&gt; и &lt;Улица&gt;, &lt;Улица&gt; и &lt;Марка&gt;, а также &lt;Марка&gt; и &lt;цена&gt; разделены ровно одним пробелом. Пример входной строки:<p class=\"left_margin\">Синойл Цветочная 95 2250<p class=\"left_margin\">Программа должна выводить через пробел 3 числа – количество АЗС, продающих дешевле всего 92-й, 95-й и 98-й бензин соответственно. Если бензин какой-то марки нигде не продавался, то следует вывести 0.<p class=\"left_margin\">Пример выходных данных:<p class=\"left_margin\">12 1 0</p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.varmin, ans: array[92..98] of integer;c: char;i, k, N, b: integer;beginfor i:=92 to 98 dobeginmin[i]:=3001;{допустимо и другое число, > 3000}ans[i]:=0;end;readln(N);for i:=1 to N dobeginrepeatread(c);until c=' '; {считана компания}repeatread(c);until c=' '; {считана улица}readln(k,b);if min[k] > b thenbeginmin[k]:=b;ans[k]:=1end elseif min[k] = b then ans[k]:=ans[k]+1;end;{если бензина какой-то марки не было,ans[i] осталось равным 0}writeln(ans[92],' ', ans[95],' ', ans[98])end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3101\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var<p>min, ans: array[92..98] of integer;<p>c: char;<p>i, k, N, b: integer;<p>begin<p>for i:=92 to 98 do<p>begin<p>min[i]:=3001;{допустимо и другое число, &gt; 3000}<p>ans[i]:=0;<p>end;<p>readln(N);<p>for i:=1 to N do<p>begin<p>repeat<p>read(c);<p>until c=' '; {считана компания}<p>repeat<p>read(c);<p>until c=' '; {считана улица}<p>readln(k,b);<p>if min[k] &gt; b then<p>begin<p>min[k]:=b;<p>ans[k]:=1<p>end else<p>if min[k] = b then ans[k]:=ans[k]+1;<p>end;<p>{если бензина какой-то марки не было,<p>ans[i] осталось равным 0}<p>writeln(ans[92],' ', ans[95],' ', ans[98])<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3101"
        },
        {
            "answer": "Решение.Посчитаем сколько различных цифр в строке, занесём эти данные в массив. Затем проверим есть ли цифры встречающиеся нечётное число раз, запомним какое число встречается нечётное число раз. Проверим, есть ли цифры встречающиеся более одного раза или есть ли цифры встречающиеся один раз, при том, чтобы ноль не встречался. Если цифр встречающихся нечётное число раз более одной или условие, описанное в предыдущем предложении ложно выведем \"NO\"; иначе выведем \"YES\", а затем сначала половину каждой из цифр, начиная с девятки, затем выведем запомненную цифру, оставшуюся половину цифр.  var a:array['0'..'9'] of integer;c, c_odd: char;i, k: integer;f: boolean;beginfor c:='0' to '9' do a[c]:=0;read(с);while c<>'.' dobeginif c in ['0' .. '9'] then a[c] := a[c] + 1;read(c);end;k := 0; {количество цифр, встречающихся нечетное число раз}for c := '0' to '9' doif a[c] mod 2 = 1 thenbegink := k + 1;c_odd := c;end;f := (a['0'] = 1);for c := '1' to '9' doif (a[c] > 1) or (a[c] = 1) and (a['0'] = 0) then f := true;if (k > 1)or not f then writeln('NO') elsebeginwriteln('YES');for c := '9' downto '0' dofor i := 1 to a[c] div 2 dowrite(c);if k = 1 thenwrite(c_odd);for c := '0' to '9' dofor i := 1 to a[c] div 2 dowrite(c);endend.",
            "parsed": "2019-04-29 21:13:55.565467",
            "question": "На вход программе подается набор символов, заканчивающийся точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка, или считывать данные из файла). Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая сначала будет определять, есть ли в этом наборе символы, соответствующие десятичным цифрам. Если такие символы есть, то можно ли переставить их так, чтобы полученное число было симметричным (читалось одинаково как слева направо, так и справа налево). Ведущих нулей в числе быть не должно, исключение – число 0, запись которого содержит ровно один ноль.Если требуемое число составить невозможно, то программа должна вывести на экран слово “NO”. А если возможно, то в первой строке следует вывести слово “YES”, а во второй – искомое симметричное число. Если таких чисел несколько, то программа должна выводить максимальное из них. Например, пусть на вход подаются следующие символы:Do not 911 to 09 do.В данном случае программа должна вывестиYES91019",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942818\" width=\"100%\"><p class=\"left_margin\">На вход программе подается набор символов, заканчивающийся точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка, или считывать данные из файла). Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая сначала будет определять, есть ли в этом наборе символы, соответствующие десятичным цифрам. Если такие символы есть, то можно ли переставить их так, чтобы полученное число было симметричным (читалось одинаково как слева направо, так и справа налево). Ведущих нулей в числе быть не должно, исключение – число 0, запись которого содержит ровно один ноль.<p class=\"left_margin\">Если требуемое число составить невозможно, то программа должна вывести на экран слово “NO”. А если возможно, то в первой строке следует вывести слово “YES”, а во второй – искомое симметричное число. Если таких чисел несколько, то программа должна выводить максимальное из них. Например, пусть на вход подаются следующие символы:<p class=\"left_margin\">Do not 911 to 09 do.<p class=\"left_margin\">В данном случае программа должна вывести<p class=\"left_margin\">YES<p class=\"left_margin\">91019</p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Посчитаем сколько различных цифр в строке, занесём эти данные в массив. Затем проверим есть ли цифры встречающиеся нечётное число раз, запомним какое число встречается нечётное число раз. Проверим, есть ли цифры встречающиеся более одного раза или есть ли цифры встречающиеся один раз, при том, чтобы ноль не встречался. Если цифр встречающихся нечётное число раз более одной или условие, описанное в предыдущем предложении ложно выведем \"NO\"; иначе выведем \"YES\", а затем сначала половину каждой из цифр, начиная с девятки, затем выведем запомненную цифру, оставшуюся половину цифр.  var a:array['0'..'9'] of integer;c, c_odd: char;i, k: integer;f: boolean;beginfor c:='0' to '9' do a[c]:=0;read(с);while c<>'.' dobeginif c in ['0' .. '9'] then a[c] := a[c] + 1;read(c);end;k := 0; {количество цифр, встречающихся нечетное число раз}for c := '0' to '9' doif a[c] mod 2 = 1 thenbegink := k + 1;c_odd := c;end;f := (a['0'] = 1);for c := '1' to '9' doif (a[c] > 1) or (a[c] = 1) and (a['0'] = 0) then f := true;if (k > 1)or not f then writeln('NO') elsebeginwriteln('YES');for c := '9' downto '0' dofor i := 1 to a[c] div 2 dowrite(c);if k = 1 thenwrite(c_odd);for c := '0' to '9' dofor i := 1 to a[c] div 2 dowrite(c);endend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3102\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Посчитаем сколько различных цифр в строке, занесём эти данные в массив. Затем проверим есть ли цифры встречающиеся нечётное число раз, запомним какое число встречается нечётное число раз. Проверим, есть ли цифры встречающиеся более одного раза или есть ли цифры встречающиеся один раз, при том, чтобы ноль не встречался. Если цифр встречающихся нечётное число раз более одной или условие, описанное в предыдущем предложении ложно выведем \"NO\"; иначе выведем \"YES\", а затем сначала половину каждой из цифр, начиная с девятки, затем выведем запомненную цифру, оставшуюся половину цифр.<p> </p><p> </p><p>var a:array['0'..'9'] of integer;<p>c, c_odd: char;<p>i, k: integer;<p>f: boolean;<p>begin<p>for c:='0' to '9' do a[c]:=0;<p>read(с);<p>while c&lt;&gt;'.' do<p>begin<p>if c in ['0' .. '9'] then a[c] := a[c] + 1;<p>read(c);<p>end;<p>k := 0; {количество цифр, встречающихся нечетное число раз}<p>for c := '0' to '9' do<p>if a[c] mod 2 = 1 then<p>begin<p>k := k + 1;<p>c_odd := c;<p>end;<p>f := (a['0'] = 1);<p>for c := '1' to '9' do<p>if (a[c] &gt; 1) or (a[c] = 1) and (a['0'] = 0) then f := true;<p>if (k &gt; 1)or not f then writeln('NO') else<p>begin<p>writeln('YES');<p>for c := '9' downto '0' do<p>for i := 1 to a[c] div 2 do<p>write(c);<p>if k = 1 then<p>write(c_odd);<p>for c := '0' to '9' do<p>for i := 1 to a[c] div 2 do<p>write(c);<p>end<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3102"
        },
        {
            "answer": "Решение.var f:boolean;i, k, max: integer;с,cnew:char;s:string;begin    s:=''; max:=0; k:=0;f:=false; repeatread(c);  s:=s+c;  if f then if с in ['a'..'z','A'..'Z']then k:=k+1else begin     if k>max then max:=k;   f:=falseendelse {f=false}if с in ['a'..'z','A'..'Z']   then      begin        f:=true;        k:=1      end  until c='.'; for i:=1 to length(s) dobegincnew:=chr(ord(s[i])+max);  case s[i] of'a'..'z': if cnew>'z' then write (chr (ord (cnew)-26))else write(cnew);  'A'..'Z': if cnew>'Z' then write (chr (ord (cnew)-26))else write(cnew);else   write(s[i]) end;end;readlnend.",
            "parsed": "2019-04-29 21:13:48.491798",
            "question": "На вход программе подаётся текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано Гарри Поттером следующим образом. Сначала Гарри определил количество букв в самом длинном слове, обозначив полученное число К (словом называется непрерывная последовательность английских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую английскую букву в заклинании на букву, стоящую в алфавите на К букв ранее (алфавит считается циклическим, то есть перед буквой А стоит буква Z), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные - прописными. Требуется написать как можно более эффективную программу, которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким:  Zb Ra Ca,Dab Ra. то результат расшифровки должен быть следующим:Се Ud Fd,Gde Ud.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942819\" width=\"100%\"><p class=\"left_margin\">На вход программе подаётся текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано Гарри Поттером следующим образом. Сначала Гарри определил количество букв в самом длинном слове, обозначив полученное число К (словом называется непрерывная последовательность английских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую английскую букву в заклинании на букву, стоящую в алфавите на К букв ранее (алфавит считается циклическим, то есть перед буквой А стоит буква Z), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные - прописными. Требуется написать как можно более эффективную программу, которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким: <p> </p><p class=\"left_margin\">Zb Ra Ca,Dab Ra.<p> </p><p>то результат расшифровки должен быть следующим:<p class=\"left_margin\">Се Ud Fd,Gde Ud.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var f:boolean;i, k, max: integer;с,cnew:char;s:string;begin    s:=''; max:=0; k:=0;f:=false; repeatread(c);  s:=s+c;  if f then if с in ['a'..'z','A'..'Z']then k:=k+1else begin     if k>max then max:=k;   f:=falseendelse {f=false}if с in ['a'..'z','A'..'Z']   then      begin        f:=true;        k:=1      end  until c='.'; for i:=1 to length(s) dobegincnew:=chr(ord(s[i])+max);  case s[i] of'a'..'z': if cnew>'z' then write (chr (ord (cnew)-26))else write(cnew);  'A'..'Z': if cnew>'Z' then write (chr (ord (cnew)-26))else write(cnew);else   write(s[i]) end;end;readlnend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3103\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var f:boolean;<p>i, k, max: integer;<p>с,cnew:char;<p>s:string;<p>begin<p>    s:=''; <p>max:=0; k:=0;<p>f:=false; <p>repeat<p>read(c);  <p>s:=s+c;  <p>if f then <p>if с in ['a'..'z','A'..'Z']<p>then k:=k+1<p>else begin  <p>   if k&gt;max then max:=k;<p>   f:=false<p>end<p>else {f=false}<p>if с in ['a'..'z','A'..'Z']<p>   then <p>     begin <p>       f:=true; <p>       k:=1 <p>     end  <p>until c='.'; <p>for i:=1 to length(s) do<p>begin<p>cnew:=chr(ord(s[i])+max);  <p>case s[i] of<p>'a'..'z': if cnew&gt;'z' then write (chr (ord (cnew)-26))<p>else write(cnew);  <p>'A'..'Z': if cnew&gt;'Z' then write (chr (ord (cnew)-26))<p>else write(cnew);<p>else   write(s[i]) <p>end;<p>end;<p>readln<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3103"
        },
        {
            "answer": "Решение.var р:array[1..100] of record  name:string; sum:integer; end;с:char;i,j,N,m:integer;beginreadln(N); for i:=l to N dobeginp[i].name:= ' ';repeat     read(c);   p[i].name:=p[i].name+cuntil c=' ';    repeat  read(с);  p[i].name:=p[i].name+cuntil c=' ';    p[i].sum:=0;  for j:=1 to 3 do beginread(m);if m=2 then p[i].sum:=p[i].sum+1end;   readln;end;for i:=1 to N do    if p[i].sum=3 then writeln(p[i].name); for i:=1 to N doif p[i].sum=2 then writeln(p[i].name);for i:=1 to N doif p[i].sum=1 then writeln(p[i].name) end.",
            "parsed": "2019-04-29 21:14:09.573171",
            "question": "На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат: <Фамилия> <Имя> <оценки>, где <Фамилия> - строка, состоящая не более чем из 20 символов, <Имя> — строка, состоящая не более чем из 15 символов, <оценки> - через пробел три целых числа, соответствующие оценкам по пятибалльной системе. <Фамилия> и <Имя>, а также <Имя> и <оценки> разделены одним пробелом. Пример входной строки:Иванов Петр 4 2 4 Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена неуспевающих учеников (имеющих по результатам экзаменов хотя бы одну двойку), располагая их в порядке уменьшения числа двоек.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942812\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат: &lt;Фамилия&gt; &lt;Имя&gt; &lt;оценки&gt;, где &lt;Фамилия&gt; - строка, состоящая не более чем из 20 символов, &lt;Имя&gt; — строка, состоящая не более чем из 15 символов, &lt;оценки&gt; - через пробел три целых числа, соответствующие оценкам по пятибалльной системе. &lt;Фамилия&gt; и &lt;Имя&gt;, а также &lt;Имя&gt; и &lt;оценки&gt; разделены одним пробелом. Пример входной строки:<p class=\"left_margin\">Иванов Петр 4 2 4<p> </p><p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена неуспевающих учеников (имеющих по результатам экзаменов хотя бы одну двойку), располагая их в порядке уменьшения числа двоек.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var р:array[1..100] of record  name:string; sum:integer; end;с:char;i,j,N,m:integer;beginreadln(N); for i:=l to N dobeginp[i].name:= ' ';repeat     read(c);   p[i].name:=p[i].name+cuntil c=' ';    repeat  read(с);  p[i].name:=p[i].name+cuntil c=' ';    p[i].sum:=0;  for j:=1 to 3 do beginread(m);if m=2 then p[i].sum:=p[i].sum+1end;   readln;end;for i:=1 to N do    if p[i].sum=3 then writeln(p[i].name); for i:=1 to N doif p[i].sum=2 then writeln(p[i].name);for i:=1 to N doif p[i].sum=1 then writeln(p[i].name) end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3104\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var р:array[1..100] of record  <p>name:string; <p>sum:integer; <p>end;<p>с:char;<p>i,j,N,m:integer;<p>begin<p>readln(N); <p>for i:=l to N do<p>begin<p>p[i].name:= ' ';<p>repeat  <p>   read(c);<p>   p[i].name:=p[i].name+c<p>until c=' ';    <p>repeat<p>  read(с);<p>  p[i].name:=p[i].name+c<p>until c=' ';    <p>p[i].sum:=0;  <p>for j:=1 to 3 do <p>begin<p>read(m);<p>if m=2 then p[i].sum:=p[i].sum+1<p>end;   <p>readln;<p>end;<p>for i:=1 to N do<p>    if p[i].sum=3 then writeln(p[i].name); <p>for i:=1 to N do<p>if p[i].sum=2 then writeln(p[i].name);<p>for i:=1 to N do<p>if p[i].sum=1 then writeln(p[i].name) <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3104"
        },
        {
            "answer": "Решение.var a: array[0..9] of boolean;  c: char;  i, k: integer;beginfor i:=0 to 9 do a[i]:=false;read(c);while c<>'.' dobegin   if c in ['0'..'9'] thenbegin    k:=ord(c)-ord('0');    a[k]:=true;  end;read(c);end;k:=0;for i:= 9 downto 0 do  if a[i] = true then     begin        k:=k+1;        write(i);     end;if k=0 then write(-1);end.",
            "parsed": "2019-04-29 21:13:56.446971",
            "question": "На вход программе подается последовательность символов, среди которых встречаются и цифры. Ввод символов заканчивается точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая составит из тех цифр, которые встречаются во входных данных, максимальное число. При составлении итогового числа каждая цифра может быть использована только один раз. Если во входных данных цифры не встречаются, то следует вывести \"-1\". Например, пусть на вход подаются следующие символы:14ф73п439.В данном случае программа должна вывести97431.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942813\" width=\"100%\"><p class=\"left_margin\">На вход программе подается последовательность символов, среди которых встречаются и цифры. Ввод символов заканчивается точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая составит из тех цифр, которые встречаются во входных данных, максимальное число. При составлении итогового числа каждая цифра может быть использована только один раз. Если во входных данных цифры не встречаются, то следует вывести \"-1\". Например, пусть на вход подаются следующие символы:<p class=\"left_margin\">14ф73п439.<p class=\"left_margin\">В данном случае программа должна вывести<p class=\"left_margin\">97431.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var a: array[0..9] of boolean;  c: char;  i, k: integer;beginfor i:=0 to 9 do a[i]:=false;read(c);while c<>'.' dobegin   if c in ['0'..'9'] thenbegin    k:=ord(c)-ord('0');    a[k]:=true;  end;read(c);end;k:=0;for i:= 9 downto 0 do  if a[i] = true then     begin        k:=k+1;        write(i);     end;if k=0 then write(-1);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3105\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var a: array[0..9] of boolean;<p>  c: char;<p>  i, k: integer;<p>begin<p>for i:=0 to 9 do a[i]:=false;<p>read(c);<p>while c&lt;&gt;'.' do<p>begin<p>   if c in ['0'..'9'] then<p>begin<p>    k:=ord(c)-ord('0');<p>    a[k]:=true;<p>  end;<p>read(c);<p>end;<p>k:=0;<p>for i:= 9 downto 0 do<p>  if a[i] = true then<p>     begin<p>        k:=k+1;<p>        write(i);<p>     end;<p>if k=0 then write(-1);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3105"
        },
        {
            "answer": "Решение.var nс:аrrау[1..99] of integer; р:1..99;  с: char;i, N, max: integer;beginreadln(N); for i:=l to 99 do nc[i]:=0; for i:=l to N dobegin  repeat     read(c)  until с='  ';    repeat    read(c)  until с='  ';  readln(p);  nc[p]:=nc[p]+1; end;max:=0;for i:=1 to 99 doif nc[i]>0 then     if nc[i]>max then max:=nc[i]; for i:=l to 99 do   if nc[i]=max then writeln(i); readlnend.",
            "parsed": "2019-04-29 21:14:11.360029",
            "question": "На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет следующий формат: <Фамилия> <Инициалы> <номер школы>, где <Фамилия> - строка, состоящая не более чем из 20 символов, <Инициалы> - строка, состоящая из 4-х символов (буква, точка, буква, точка), <номер школы> - не более чем двузначный номер. <Фамилия> и <Инициалы>, а также <Инициалы> и <номер школы> разделены одним пробелом. Пример входной строки:Иванов П.С. 57 Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран информацию, из какой школы (школ) было больше всего участников олимпиады.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942814\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет следующий формат: &lt;Фамилия&gt; &lt;Инициалы&gt; &lt;номер школы&gt;, где &lt;Фамилия&gt; - строка, состоящая не более чем из 20 символов, &lt;Инициалы&gt; - строка, состоящая из 4-х символов (буква, точка, буква, точка), &lt;номер школы&gt; - не более чем двузначный номер. &lt;Фамилия&gt; и &lt;Инициалы&gt;, а также &lt;Инициалы&gt; и &lt;номер школы&gt; разделены одним пробелом. Пример входной строки:<p class=\"left_margin\">Иванов П.С. 57<p> </p><p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран информацию, из какой школы (школ) было больше всего участников олимпиады.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var nс:аrrау[1..99] of integer; р:1..99;  с: char;i, N, max: integer;beginreadln(N); for i:=l to 99 do nc[i]:=0; for i:=l to N dobegin  repeat     read(c)  until с='  ';    repeat    read(c)  until с='  ';  readln(p);  nc[p]:=nc[p]+1; end;max:=0;for i:=1 to 99 doif nc[i]>0 then     if nc[i]>max then max:=nc[i]; for i:=l to 99 do   if nc[i]=max then writeln(i); readlnend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3106\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var nс:аrrау[1..99] of integer; <p>р:1..99;  <p>с: char;<p>i, N, max: integer;<p>begin<p>readln(N); <p>for i:=l to 99 do nc[i]:=0; <p>for i:=l to N do<p>begin<p>  repeat<p>     read(c)<p>  until с='  ';  <p>  repeat<p>    read(c)<p>  until с='  ';  <p>readln(p);  <p>nc[p]:=nc[p]+1; <p>end;<p>max:=0;<p>for i:=1 to 99 do<p>if nc[i]&gt;0 then  <p>   if nc[i]&gt;max then max:=nc[i]; <p>for i:=l to 99 do<p>   if nc[i]=max then writeln(i); <p>readln<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3106"
        },
        {
            "answer": "Решение.var Str,Strmax,Strmax2:string[52];simvol:char;i,N,nomer,ball,max,max2,nmax,nmax2:integer;Beginmax:=-1;max2:=-1;Strmax:='';nmax:=0;Writeln('Введите количество учеников: ');readln(N);for i:=1 to N dobeginstr:='';  Repeat          read(simvol);    Str:=Str+simvol;  Until simvol=' ';  Repeatread(simvol);Str:=Str+simvol;Until simvol=' '; read(nomer); read(ball);  if nomer=30 then         if ball>max then        begin           max2:=max;            max:=ball;             Strmax2:=strmax;             Strmax:=Str;              nmax2:=nmax;           nmax:=1; endelse  if ball=max then         begin         nmax:=nmax+1;         nmax2:=nmax;         Strmax2:=Strmax;endelse if ball>max2 then       begin     max2:=ball;     Strmax2:=Str;     nmax2:=1;endelse   if ball=max2 then nmax2:=nmax2+1; end;if (nmax=2) or (nmax=1) and (nmax2=1) then    begin    writeln(Strmax);    writeln(Strmax2); end   else   if (nmax=1) and (nmax2>1) then writeln(StrMax);    if nmax>2 then writeln(nmax);End.",
            "parsed": "2019-04-29 21:14:12.665362",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик,какой школы сколько набрал баллов.Эта информация в том же виде была разослана в школы. Завуч школы №30 решила наградить двух учащихся,которые лучше всех сдали информатику.Программа должна вывести на экран фамилии и имена этих учеников.Если наибольший балл набрало больше двух человек-вывести количество таких учеников.Если наибольший балл набрал один человек,а следующий балл набрало несколько человек-нужно вывести только фамилию и имя лучшего.Напишите эффективную,в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию.Известно,что информатику сдавало больше 5 учеников школы №30.На вход программе сначала подается число учеников,сдававших экзамен.В каждой из следующих N строк находится информация об учениках в формате:<Фамилия><Имя><Номер школы><Количество баллов><Фамилия>-строка,состоящая не более чем из 30 символов без пробелов,<Имя>-строка,состоящая не более чем из 20 символов.<Номер школы>-число в диапазоне от 1 до 99<Количество баллов>-число в диапазоне от 1 до 100.Эти данные записаны через пробел,то есть в каждой строке ровно 3 пробела.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942815\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик,какой школы сколько набрал баллов.Эта информация в том же виде была разослана в школы.<p> </p><p class=\"left_margin\">Завуч школы №30 решила наградить двух учащихся,которые лучше всех сдали информатику.<p class=\"left_margin\">Программа должна вывести на экран фамилии и имена этих учеников.<p class=\"left_margin\">Если наибольший балл набрало больше двух человек-вывести количество таких учеников.<p class=\"left_margin\">Если наибольший балл набрал один человек,а следующий балл набрало несколько человек-нужно вывести только фамилию и имя лучшего.<p class=\"left_margin\">Напишите эффективную,в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию.Известно,что информатику сдавало больше 5 учеников школы №30.<p class=\"left_margin\">На вход программе сначала подается число учеников,сдававших экзамен.В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt;&lt;Имя&gt;&lt;Номер школы&gt;&lt;Количество баллов&gt;<p>&lt;Фамилия&gt;-строка,состоящая не более чем из 30 символов без пробелов,<p>&lt;Имя&gt;-строка,состоящая не более чем из 20 символов.<p>&lt;Номер школы&gt;-число в диапазоне от 1 до 99<p>&lt;Количество баллов&gt;-число в диапазоне от 1 до 100.<p class=\"left_margin\">Эти данные записаны через пробел,то есть в каждой строке ровно 3 пробела.</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var Str,Strmax,Strmax2:string[52];simvol:char;i,N,nomer,ball,max,max2,nmax,nmax2:integer;Beginmax:=-1;max2:=-1;Strmax:='';nmax:=0;Writeln('Введите количество учеников: ');readln(N);for i:=1 to N dobeginstr:='';  Repeat          read(simvol);    Str:=Str+simvol;  Until simvol=' ';  Repeatread(simvol);Str:=Str+simvol;Until simvol=' '; read(nomer); read(ball);  if nomer=30 then         if ball>max then        begin           max2:=max;            max:=ball;             Strmax2:=strmax;             Strmax:=Str;              nmax2:=nmax;           nmax:=1; endelse  if ball=max then         begin         nmax:=nmax+1;         nmax2:=nmax;         Strmax2:=Strmax;endelse if ball>max2 then       begin     max2:=ball;     Strmax2:=Str;     nmax2:=1;endelse   if ball=max2 then nmax2:=nmax2+1; end;if (nmax=2) or (nmax=1) and (nmax2=1) then    begin    writeln(Strmax);    writeln(Strmax2); end   else   if (nmax=1) and (nmax2>1) then writeln(StrMax);    if nmax>2 then writeln(nmax);End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3107\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var Str,Strmax,Strmax2:string[52];<p>simvol:char;<p>i,N,nomer,ball,max,max2,nmax,nmax2:integer;<p class=\"left_margin\">Begin<p>max:=-1;<p>max2:=-1;<p class=\"left_margin\">Strmax:='';<p>nmax:=0;<p class=\"left_margin\">Writeln('Введите количество учеников: ');readln(N);<p>for i:=1 to N do<p>begin<p>str:='';  <p class=\"left_margin\">Repeat          <p>read(simvol);    <p class=\"left_margin\">Str:=Str+simvol;  <p class=\"left_margin\">Until simvol=' ';  <p class=\"left_margin\">Repeat<p>read(simvol);<p class=\"left_margin\">Str:=Str+simvol;<p class=\"left_margin\">Until simvol=' '; <p>read(nomer); <p>read(ball);  <p>if nomer=30 then      <p>   if ball&gt;max then  <p>      begin<p>           max2:=max; <p>           max:=ball;  <p>           Strmax2:=strmax;  <p>           Strmax:=Str;   <p>           nmax2:=nmax;<p>           nmax:=1; <p>end<p>else<p>  if ball=max then  <p>       begin<p>         nmax:=nmax+1;<p>         nmax2:=nmax;<p>         Strmax2:=Strmax;<p>end<p>else if ball&gt;max2 then  <p>     begin<p>     max2:=ball;<p>     Strmax2:=Str;<p>     nmax2:=1;<p>end<p>else   if ball=max2 then nmax2:=nmax2+1; <p>end;<p>if (nmax=2) or (nmax=1) and (nmax2=1) then <p>   begin<p>    writeln(Strmax);<p>    writeln(Strmax2);<p> end<p>   else<p>   if (nmax=1) and (nmax2&gt;1) then writeln(StrMax); <p>   if nmax&gt;2 then writeln(nmax);<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3107"
        },
        {
            "answer": "Решение.type massiv=array[1..99] of integer;var count:massiv;            sumball:massiv;         ch:char;    i,N,nomer,ball,max,nmax:integer;Beginfor i:=1 to 99 do    begin         count[i]:=0;             sumball[i]:=0;    end;write('Введите количество учеников: ');readln(n);for i:=1 to n dobeginRepeatread(ch);Until ch=' '; Repeatread(ch);Until ch=' ';read(nomer);read(ball);count[nomer]:=count[nomer]+1;    sumball[nomer]:=sumball[nomer]+ball;  end;for i:=1 to 99 doif count[i]>0 then sumball[i]:=sumball[i] div count[i];  max:=1;nmax:=1;for i:=2 to 99 doif sumball[i]>sumball[max] then          begin   max:=i;   nmax:=1;   endelse if sumball[i]=sumball[max] then inc(nmax);if nmax=1 then writeln(max,' ',sumball[max])else writeln(nmax);End.",
            "parsed": "2019-04-29 21:14:13.088627",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик, какой школы, сколько набрал баллов.Районый методист решила выяснить номер школы, ученики которой набрали наибольший средний балл,с точностью до целых.Программа должна вывести на экран номер такой школы и её средний балл.Если наибольший средний балл набрало больше одной школы, вывести количество таких школ.Напишите эффективную, в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию.Также известно, что в районе школ с некоторыми номерами не существует.На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<Фамилия><Имя><Номер школы><Количество баллов><Фамилия>-строка, состоящая не более чем из 30 символов без пробелов,<Имя>-строка, состоящая не более чем из 20 символов.<Номер школы>-число в диапазоне от 1 до 99<Количество баллов>-число в диапазоне от 1 до 100.Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942808\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик, какой школы, сколько набрал баллов.<p class=\"left_margin\">Районый методист решила выяснить номер школы, ученики которой набрали наибольший средний балл,с точностью до целых.<p class=\"left_margin\">Программа должна вывести на экран номер такой школы и её средний балл.<p class=\"left_margin\">Если наибольший средний балл набрало больше одной школы, вывести количество таких школ.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию.<p class=\"left_margin\">Также известно, что в районе школ с некоторыми номерами не существует.<p class=\"left_margin\">На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt;&lt;Имя&gt;&lt;Номер школы&gt;&lt;Количество баллов&gt;<p>&lt;Фамилия&gt;-строка, состоящая не более чем из 30 символов без пробелов,<p>&lt;Имя&gt;-строка, состоящая не более чем из 20 символов.<p>&lt;Номер школы&gt;-число в диапазоне от 1 до 99<p>&lt;Количество баллов&gt;-число в диапазоне от 1 до 100.<p class=\"left_margin\">Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.type massiv=array[1..99] of integer;var count:massiv;            sumball:massiv;         ch:char;    i,N,nomer,ball,max,nmax:integer;Beginfor i:=1 to 99 do    begin         count[i]:=0;             sumball[i]:=0;    end;write('Введите количество учеников: ');readln(n);for i:=1 to n dobeginRepeatread(ch);Until ch=' '; Repeatread(ch);Until ch=' ';read(nomer);read(ball);count[nomer]:=count[nomer]+1;    sumball[nomer]:=sumball[nomer]+ball;  end;for i:=1 to 99 doif count[i]>0 then sumball[i]:=sumball[i] div count[i];  max:=1;nmax:=1;for i:=2 to 99 doif sumball[i]>sumball[max] then          begin   max:=i;   nmax:=1;   endelse if sumball[i]=sumball[max] then inc(nmax);if nmax=1 then writeln(max,' ',sumball[max])else writeln(nmax);End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3108\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>type massiv=array[1..99] of integer;<p>var count:massiv;        <p>    sumball:massiv;     <p>    ch:char;<p>    i,N,nomer,ball,max,nmax:integer;<p class=\"left_margin\">Begin<p>for i:=1 to 99 do<p>    begin<p>         count[i]:=0;    <p>         sumball[i]:=0;<p>    end;<p>write('Введите количество учеников: ');readln(n);<p>for i:=1 to n do<p>begin<p class=\"left_margin\">Repeat<p>read(ch);<p class=\"left_margin\">Until ch=' '; <p class=\"left_margin\">Repeat<p>read(ch);<p class=\"left_margin\">Until ch=' ';<p>read(nomer);<p>read(ball);<p>count[nomer]:=count[nomer]+1;    <p>sumball[nomer]:=sumball[nomer]+ball;  <p>end;<p>for i:=1 to 99 do<p>if count[i]&gt;0 then sumball[i]:=sumball[i] div count[i];  <p>max:=1;<p>nmax:=1;<p>for i:=2 to 99 do<p>if sumball[i]&gt;sumball[max] then       <p>   begin<p>   max:=i;<p>   nmax:=1;<p>   end<p>else if sumball[i]=sumball[max] then inc(nmax);<p>if nmax=1 then writeln(max,' ',sumball[max])<p>else writeln(nmax);<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3108"
        },
        {
            "answer": "Решение.var p:array[1..100] of recordname:string;sum:integer;end;c:char;i,j,N,s1,s2,s3,m:integer;beginreadln(N);for i:=1 to N dobeginp[i].name:='';repeatread(c);p[i].name:=p[i].name+cuntil c=' '; repeatread(c);p[i].name:=p[i].name+cuntil c=' '; p[i].sum:=0;for j:=1 to 3 dobeginread(m);p[i].sum:=p[i].sum+mend;  readln;end;s1:=20; s2:=20; s3:=20;for i:=1 to N dobeginif p[i].sum < s1 thenbegins3:=s2;s2:=s1;s1:=p[i].sumend elseif p[i].sum < s2 thenbegin     s3:=s2;     s2:=p[i].sumendelseif p[i].sum < s3 then s3:=p[i].sum;end;for i:=1 to N doif p[i].sum < = s3 then writeln(p[i].name);end.",
            "parsed": "2019-04-29 21:14:10.014469",
            "question": "На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат: <Фамилия> <Имя> <оценки>, где <Фамилия> – строка, состоящая не более чем из 20 символов, <Имя> – строка, состоящая не более чем из 15 символов, <оценки> – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. <Фамилия> и <Имя>, а также <Имя> и <оценки> разделены одним пробелом. Пример входной строки: Иванов Петр 4 5 3 Требуется написать как можно более эффективную программу, которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942809\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат: <p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;оценки&gt;, <p>где &lt;Фамилия&gt; – строка, состоящая не более чем из 20 символов, &lt;Имя&gt; – строка, состоящая не более чем из 15 символов, &lt;оценки&gt; – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. &lt;Фамилия&gt; и &lt;Имя&gt;, а также &lt;Имя&gt; и &lt;оценки&gt; разделены одним пробелом. Пример входной строки: <p class=\"left_margin\">Иванов Петр 4 5 3 <p class=\"left_margin\">Требуется написать как можно более эффективную программу, которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.</p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var p:array[1..100] of recordname:string;sum:integer;end;c:char;i,j,N,s1,s2,s3,m:integer;beginreadln(N);for i:=1 to N dobeginp[i].name:='';repeatread(c);p[i].name:=p[i].name+cuntil c=' '; repeatread(c);p[i].name:=p[i].name+cuntil c=' '; p[i].sum:=0;for j:=1 to 3 dobeginread(m);p[i].sum:=p[i].sum+mend;  readln;end;s1:=20; s2:=20; s3:=20;for i:=1 to N dobeginif p[i].sum < s1 thenbegins3:=s2;s2:=s1;s1:=p[i].sumend elseif p[i].sum < s2 thenbegin     s3:=s2;     s2:=p[i].sumendelseif p[i].sum < s3 then s3:=p[i].sum;end;for i:=1 to N doif p[i].sum < = s3 then writeln(p[i].name);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3109\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var p:array[1..100] of record<p>name:string;<p>sum:integer;<p>end;<p>c:char;<p>i,j,N,s1,s2,s3,m:integer;<p>begin<p>readln(N);<p>for i:=1 to N do<p>begin<p>p[i].name:='';<p>repeat<p>read(c);<p>p[i].name:=p[i].name+c<p>until c=' '; <p>repeat<p>read(c);<p>p[i].name:=p[i].name+c<p>until c=' '; <p>p[i].sum:=0;<p>for j:=1 to 3 do<p>begin<p>read(m);<p>p[i].sum:=p[i].sum+m<p>end;  <p>readln;<p>end;<p>s1:=20; s2:=20; s3:=20;<p>for i:=1 to N do<p>begin<p>if p[i].sum &lt; s1 then<p>begin<p>s3:=s2;<p>s2:=s1;<p>s1:=p[i].sum<p>end else<p>if p[i].sum &lt; s2 then<p>begin<p>     s3:=s2;<p>     s2:=p[i].sum<p>end<p>else<p>if p[i].sum &lt; s3 then s3:=p[i].sum;<p>end;<p>for i:=1 to N do<p>if p[i].sum &lt; = s3 then writeln(p[i].name);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3109"
        },
        {
            "answer": "Решение.vara:array['a'..'z'] of integer;ch,c:char;i,k:integer;Beginfor ch:='a' to 'z' do a[ch]:=0;k:=0;read (c);while c<>'.' dobeginif c in ['a' .. 'z'] then a[c]:=a[c]+1;k:=k+1;read (c);end;for i:=1 to k do beginfor ch:='a' to 'z' doif a[ch]=i then write(ch);end;end.",
            "parsed": "2019-04-29 21:14:04.438939",
            "question": "На вход программы подаются строчные английские буквы. Ввод этих букв заканчивается точкой (другие символы, отличные от «.» и букв «a».. «z» во входных данных отсутствуют. Требуется написать программу на одном из языков программирования, которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выдаются в алфавитном порядке. Например, пусть на вход подаются следующие символы:colaclcВ данном случае программа должна вывести:аolc",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942810\" width=\"100%\"><p class=\"left_margin\">На вход программы подаются строчные английские буквы. Ввод этих букв заканчивается точкой (другие символы, отличные от «.» и букв «a».. «z» во входных данных отсутствуют. Требуется написать программу на одном из языков программирования, которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выдаются в алфавитном порядке. Например, пусть на вход подаются следующие символы:<p>colaclc<p class=\"left_margin\">В данном случае программа должна вывести:<p>аolc</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.vara:array['a'..'z'] of integer;ch,c:char;i,k:integer;Beginfor ch:='a' to 'z' do a[ch]:=0;k:=0;read (c);while c<>'.' dobeginif c in ['a' .. 'z'] then a[c]:=a[c]+1;k:=k+1;read (c);end;for i:=1 to k do beginfor ch:='a' to 'z' doif a[ch]=i then write(ch);end;end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3110\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var<p>a:array['a'..'z'] of integer;<p>ch,c:char;<p>i,k:integer;<p class=\"left_margin\">Begin<p>for ch:='a' to 'z' do a[ch]:=0;<p>k:=0;<p>read (c);<p>while c&lt;&gt;'.' do<p>begin<p>if c in ['a' .. 'z'] then a[c]:=a[c]+1;<p>k:=k+1;<p>read (c);<p>end;<p>for i:=1 to k do begin<p>for ch:='a' to 'z' do<p>if a[ch]=i then write(ch);<p>end;<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3110"
        },
        {
            "answer": "Решение.Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 10 целых чисел, количество каждой из цифр. Сами входные символы при этом не запоминаются. Затем проверяется — сколько в этом массиве нечетных элементов. Если больше одного, то задача решения не имеет. При наличии решения сначала печатается половина имеющихся цифр 9 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), затем 8 и т.д. до 0, потом печатается цифра, которая встречается во входных данных нечетное число раз, а затем — оставшаяся половина цифр 0 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), 1, и т.д. до 9. Если никаких цифр, кроме 0, во входных данных нет, то задача имеет решение, только если этот ноль единственный. Если нулей четное число, а ненулевая цифра единственная, то решения не существует. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов), или которая умеет только определять, имеет ли задача решение.Пример правильной и эффективной программы на языке Паскаль:var a:array['0'..'9'] of integer;c, c_odd: char;i, k: integer;f: boolean;beginfor c:='0' to '9' do a[c]:=0;read(с);while c<>'.' dobeginif c in ['0' .. '9'] then a[c] := a[c] + 1;read(c);end;k := 0; {количество цифр, встречающихся нечетное число раз}for c := '0' to '9' doif a[c] mod 2 = 1 thenbegink := k + 1;c_odd := cend;f := (a['0'] = 1);for c := '1' to '9' doif (a[c] > 1) or (a[c] = 1) and (a['0'] = 0) then f := true;if (k > 1)or not f then writeln('NO') elsebeginwriteln('YES');for c := '9' downto '0' dofor i := 1 to a[c] div 2 dowrite(c);if k = 1 thenwrite(c_odd);for c := '0' to '9' dofor i := 1 to a[c] div 2 dowrite(c);endend. Пример правильной и эффективной программы на языке Бейсик: DIM k, i, j, iodd, a(9) AS INTEGERFOR i = 0 TO 9a(i) = 0NEXTINPUT c$DO WHILE NOT (c$ = \".\")IF c$ >= \"0\" AND c$ <= \"9\" THENa(ASC(c$) - ASC(\"0\")) = a(ASC(c$) - ASC(\"0\")) + 1ENDIFINPUT c$LOOPk = 0IF a(0) = 1 THEN f = 1 ELSE f = 0FOR i = 0 TO 9IF a(i) MOD 2 = 1 THENk = k + 1iodd = iEND IFIF i > 0 AND a(i) > 1 THEN f = 1NEXTIF k = 1 AND a(0) = 0 THEN f = 1IF k > 1 OR f = 0 THENPRINT \"NO\"ENDENDIFPRINT \"YES\"FOR i = 9 TO 0 STEP -1FOR j = 1 TO a(i) \\ 2PRINT i;NEXTNEXTIF k = 1 THEN PRINT iodd;FOR i = 0 TO 9FOR j = 1 TO a(i) \\ 2PRINT i;NEXTNEXTEND",
            "parsed": "2019-04-29 21:13:56.026357",
            "question": "На вход программе подается набор символов, заканчивающийся точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка, или считывать данные из файла). Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая сначала будет определять, есть ли в этом наборе символы, соответствующие десятичным цифрам. Если такие символы есть, то можно ли переставить их так, чтобы полученное число было симметричным (читалось одинаково как слева направо, так и справа налево). Ведущих нулей в числе быть не должно, исключение – число 0, запись которого содержит ровно один ноль.Если требуемое число составить невозможно, то программа должна вывести на экран слово «NO». А если возможно, то в первой строке следует вывести слово «YES», а во второй – искомое симметричное число. Если таких чисел несколько, то программа должна выводить максимальное из них. Например, пусть на вход подаются следующие символы:Do not 911 to 09 do.В данном случае программа должна вывестиYES91019",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942811\" width=\"100%\"><p class=\"left_margin\">На вход программе подается набор символов, заканчивающийся точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка, или считывать данные из файла). Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая сначала будет определять, есть ли в этом наборе символы, соответствующие десятичным цифрам. Если такие символы есть, то можно ли переставить их так, чтобы полученное число было симметричным (читалось одинаково как слева направо, так и справа налево). Ведущих нулей в числе быть не должно, исключение – число 0, запись которого содержит ровно один ноль.<p class=\"left_margin\">Если требуемое число составить невозможно, то программа должна вывести на экран слово «NO». А если возможно, то в первой строке следует вывести слово «YES», а во второй – искомое симметричное число. Если таких чисел несколько, то программа должна выводить максимальное из них. Например, пусть на вход подаются следующие символы:<p class=\"left_margin\">Do not 911 to 09 do.<p class=\"left_margin\">В данном случае программа должна вывести<p class=\"left_margin\">YES<p class=\"left_margin\">91019</p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 10 целых чисел, количество каждой из цифр. Сами входные символы при этом не запоминаются. Затем проверяется — сколько в этом массиве нечетных элементов. Если больше одного, то задача решения не имеет. При наличии решения сначала печатается половина имеющихся цифр 9 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), затем 8 и т.д. до 0, потом печатается цифра, которая встречается во входных данных нечетное число раз, а затем — оставшаяся половина цифр 0 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), 1, и т.д. до 9. Если никаких цифр, кроме 0, во входных данных нет, то задача имеет решение, только если этот ноль единственный. Если нулей четное число, а ненулевая цифра единственная, то решения не существует. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов), или которая умеет только определять, имеет ли задача решение.Пример правильной и эффективной программы на языке Паскаль:var a:array['0'..'9'] of integer;c, c_odd: char;i, k: integer;f: boolean;beginfor c:='0' to '9' do a[c]:=0;read(с);while c<>'.' dobeginif c in ['0' .. '9'] then a[c] := a[c] + 1;read(c);end;k := 0; {количество цифр, встречающихся нечетное число раз}for c := '0' to '9' doif a[c] mod 2 = 1 thenbegink := k + 1;c_odd := cend;f := (a['0'] = 1);for c := '1' to '9' doif (a[c] > 1) or (a[c] = 1) and (a['0'] = 0) then f := true;if (k > 1)or not f then writeln('NO') elsebeginwriteln('YES');for c := '9' downto '0' dofor i := 1 to a[c] div 2 dowrite(c);if k = 1 thenwrite(c_odd);for c := '0' to '9' dofor i := 1 to a[c] div 2 dowrite(c);endend. Пример правильной и эффективной программы на языке Бейсик: DIM k, i, j, iodd, a(9) AS INTEGERFOR i = 0 TO 9a(i) = 0NEXTINPUT c$DO WHILE NOT (c$ = \".\")IF c$ >= \"0\" AND c$ <= \"9\" THENa(ASC(c$) - ASC(\"0\")) = a(ASC(c$) - ASC(\"0\")) + 1ENDIFINPUT c$LOOPk = 0IF a(0) = 1 THEN f = 1 ELSE f = 0FOR i = 0 TO 9IF a(i) MOD 2 = 1 THENk = k + 1iodd = iEND IFIF i > 0 AND a(i) > 1 THEN f = 1NEXTIF k = 1 AND a(0) = 0 THEN f = 1IF k > 1 OR f = 0 THENPRINT \"NO\"ENDENDIFPRINT \"YES\"FOR i = 9 TO 0 STEP -1FOR j = 1 TO a(i) \\ 2PRINT i;NEXTNEXTIF k = 1 THEN PRINT iodd;FOR i = 0 TO 9FOR j = 1 TO a(i) \\ 2PRINT i;NEXTNEXTEND",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3111\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 10 целых чисел, количество каждой из цифр. Сами входные символы при этом не запоминаются. Затем проверяется — сколько в этом массиве нечетных элементов. Если больше одного, то задача решения не имеет. При наличии решения сначала печатается половина имеющихся цифр 9 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), затем 8 и т.д. до 0, потом печатается цифра, которая встречается во входных данных нечетное число раз, а затем — оставшаяся половина цифр 0 (если таковые имеются, в случае нечетного числа цифр — меньшая половина), 1, и т.д. до 9. Если никаких цифр, кроме 0, во входных данных нет, то задача имеет решение, только если этот ноль единственный. Если нулей четное число, а ненулевая цифра единственная, то решения не существует. <p class=\"left_margin\">Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов), или которая умеет только определять, имеет ли задача решение.<p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p>var a:array['0'..'9'] of integer;<p>c, c_odd: char;<p>i, k: integer;<p>f: boolean;<p>begin<p>for c:='0' to '9' do a[c]:=0;<p>read(с);<p>while c&lt;&gt;'.' do<p>begin<p>if c in ['0' .. '9'] then a[c] := a[c] + 1;<p>read(c);<p>end;<p>k := 0; {количество цифр, встречающихся нечетное число раз}<p>for c := '0' to '9' do<p>if a[c] mod 2 = 1 then<p>begin<p>k := k + 1;<p>c_odd := c<p>end;<p>f := (a['0'] = 1);<p>for c := '1' to '9' do<p>if (a[c] &gt; 1) or (a[c] = 1) and (a['0'] = 0) then f := true;<p>if (k &gt; 1)or not f then writeln('NO') else<p>begin<p>writeln('YES');<p>for c := '9' downto '0' do<p>for i := 1 to a[c] div 2 do<p>write(c);<p>if k = 1 then<p>write(c_odd);<p>for c := '0' to '9' do<p>for i := 1 to a[c] div 2 do<p>write(c);<p>end<p>end.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Бейсик:<p> </p><p class=\"left_margin\">DIM k, i, j, iodd, a(9) AS INTEGER<p class=\"left_margin\">FOR i = 0 TO 9<p>a(i) = 0<p class=\"left_margin\">NEXT<p class=\"left_margin\">INPUT c$<p class=\"left_margin\">DO WHILE NOT (c$ = \".\")<p class=\"left_margin\">IF c$ &gt;= \"0\" AND c$ &lt;= \"9\" THEN<p>a(ASC(c$) - ASC(\"0\")) = a(ASC(c$) - ASC(\"0\")) + 1<p class=\"left_margin\">ENDIF<p class=\"left_margin\">INPUT c$<p class=\"left_margin\">LOOP<p>k = 0<p class=\"left_margin\">IF a(0) = 1 THEN f = 1 ELSE f = 0<p class=\"left_margin\">FOR i = 0 TO 9<p class=\"left_margin\">IF a(i) MOD 2 = 1 THEN<p>k = k + 1<p>iodd = i<p class=\"left_margin\">END IF<p class=\"left_margin\">IF i &gt; 0 AND a(i) &gt; 1 THEN f = 1<p class=\"left_margin\">NEXT<p class=\"left_margin\">IF k = 1 AND a(0) = 0 THEN f = 1<p class=\"left_margin\">IF k &gt; 1 OR f = 0 THEN<p class=\"left_margin\">PRINT \"NO\"<p class=\"left_margin\">END<p class=\"left_margin\">ENDIF<p class=\"left_margin\">PRINT \"YES\"<p class=\"left_margin\">FOR i = 9 TO 0 STEP -1<p class=\"left_margin\">FOR j = 1 TO a(i) \\ 2<p class=\"left_margin\">PRINT i;<p class=\"left_margin\">NEXT<p class=\"left_margin\">NEXT<p class=\"left_margin\">IF k = 1 THEN PRINT iodd;<p class=\"left_margin\">FOR i = 0 TO 9<p class=\"left_margin\">FOR j = 1 TO a(i) \\ 2<p class=\"left_margin\">PRINT i;<p class=\"left_margin\">NEXT<p class=\"left_margin\">NEXT<p class=\"left_margin\">END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3111"
        },
        {
            "answer": "Решение.Код:var f:boolean;i, k, max: integer;с,cnew:char;s:string;begin    s:=''; {длина строки – текста заклинания}{Находим К – количество букв в самом длинном слове} max:=0; k:=0;f:=false; {текущий символ не буква}repeatread(c);  //считываем по символуs:=s+c;  //прибавляем к строке if f then {слово началось}if с in ['a'..'z','A'..'Z']then k:=k+1else begin {текущий символ не буква – слово кончилось}   if k>max then max:=k;   f:=falseend else {f=false}if с in ['a'..'z','A'..'Z']   then      begin        f:=true;        k:=l      end {начало нового слова}until c='.';//считываем до точки {Расшифровка заклинания} for i:=l to length(s) dobegin cnew:=chr(ord(s[i])+max); {Находим символ, код которого =s[i]+max}case s[i] of'a'..'z': if cnew>'z' then write (chr (ord (cnew)-26))//если новый символ уже не буква,то из него вычтем 26(колво букв в алфавите) и получим нужный символ.т к алфавит у нас циклическийelse write(cnew); //иначе выводим 'A'..'Z': if cnew>'Z' then write (chr (ord (cnew)-26))                                  else write(cnew);else   write(s([i])//если не буква-выводим как естьend;end;readln end.",
            "parsed": "2019-04-29 21:13:49.300609",
            "question": "На вход программе подаётся текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано Гарри Поттером следующим образом. Сначала Гарри определил количество букв в самом длинном слове, обозначив полученное число К (словом называется непрерывная последовательность английских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую английскую букву в заклинании на букву, стоящую в алфавите на К букв ранее (алфавит считается циклическим, то есть перед буквой А стоит буква Z), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким:  Zb Ra Ca,Dab Rа. то результат расшифровки должен быть следующим:Се Ud Fd,Gde Ud.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942804\" width=\"100%\"><p class=\"left_margin\">На вход программе подаётся текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано Гарри Поттером следующим образом. Сначала Гарри определил количество букв в самом длинном слове, обозначив полученное число К (словом называется непрерывная последовательность английских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую английскую букву в заклинании на букву, стоящую в алфавите на К букв ранее (алфавит считается циклическим, то есть перед буквой А стоит буква Z), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким: <p> </p><p class=\"left_margin\">Zb Ra Ca,Dab Rа.<p> </p><p>то результат расшифровки должен быть следующим:<p class=\"left_margin\">Се Ud Fd,Gde Ud.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Код:var f:boolean;i, k, max: integer;с,cnew:char;s:string;begin    s:=''; {длина строки – текста заклинания}{Находим К – количество букв в самом длинном слове} max:=0; k:=0;f:=false; {текущий символ не буква}repeatread(c);  //считываем по символуs:=s+c;  //прибавляем к строке if f then {слово началось}if с in ['a'..'z','A'..'Z']then k:=k+1else begin {текущий символ не буква – слово кончилось}   if k>max then max:=k;   f:=falseend else {f=false}if с in ['a'..'z','A'..'Z']   then      begin        f:=true;        k:=l      end {начало нового слова}until c='.';//считываем до точки {Расшифровка заклинания} for i:=l to length(s) dobegin cnew:=chr(ord(s[i])+max); {Находим символ, код которого =s[i]+max}case s[i] of'a'..'z': if cnew>'z' then write (chr (ord (cnew)-26))//если новый символ уже не буква,то из него вычтем 26(колво букв в алфавите) и получим нужный символ.т к алфавит у нас циклическийelse write(cnew); //иначе выводим 'A'..'Z': if cnew>'Z' then write (chr (ord (cnew)-26))                                  else write(cnew);else   write(s([i])//если не буква-выводим как естьend;end;readln end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3112\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Код:<p>var f:boolean;<p>i, k, max: integer;<p>с,cnew:char;<p>s:string;<p>begin<p>    s:=''; {длина строки – текста заклинания}<p>{Находим К – количество букв в самом длинном слове}<p> </p><p>max:=0; k:=0;<p>f:=false; {текущий символ не буква}<p>repeat<p>read(c);  //считываем по символу<p>s:=s+c;  //прибавляем к строке<p> </p><p>if f then {слово началось}<p>if с in ['a'..'z','A'..'Z']<p>then k:=k+1<p>else begin {текущий символ не буква – слово кончилось}<p>   if k&gt;max then max:=k;<p>   f:=false<p>end<p> </p><p>else {f=false}<p>if с in ['a'..'z','A'..'Z']<p>   then <p>     begin <p>       f:=true; <p>       k:=l <p>     end {начало нового слова}<p>until c='.';//считываем до точки<p> </p><p>{Расшифровка заклинания}<p> </p><p>for i:=l to length(s) do<p>begin<p> </p><p>cnew:=chr(ord(s[i])+max); {Находим символ, код которого =s[i]+max}<p>case s[i] of<p>'a'..'z': if cnew&gt;'z' then write (chr (ord (cnew)-26))//если новый символ уже не буква,то из него вычтем 26(колво букв в алфавите) и получим нужный символ.т к алфавит у нас циклический<p>else write(cnew); //иначе выводим<p> </p><p>'A'..'Z': if cnew&gt;'Z' then write (chr (ord (cnew)-26))<p>                                  else write(cnew);<p>else   write(s([i])//если не буква-выводим как есть<p>end;<p>end;<p>readln<p> </p><p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3112"
        },
        {
            "answer": "Решение.varc : char;a : array [0..9] of boolean;i : integer;f : boolean; {флаг, показывающий, что в строке нашлись цифры} begin for i := 0 to 9 do a [i] := false; {обнуляем массив}f := false; {обнуляем флаг}read (c); while ( c <> '.' ) do {поиск окончания введённой строки}beginif (ord( c )-48) in [0..9] then begina [(ord( c )-48)] := true; {отнимаем 48 для того, чтобы получить искомое число}f := trueend; read (c)end;  for i := 9 downto 0 doif a [i]=true then write (i); {выводим результат}if not f then write ('-1') {проверка на то, нашлись ли цифры} end.",
            "parsed": "2019-04-29 21:13:56.759803",
            "question": "На вход программе подается последовательность символов, среди которых встречаются и цифры. Ввод символов заканчивается точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая составит из тех цифр, которые встречаются во входных данных, максимальное число. При составлении итогового числа каждая цифра может быть использована только один раз. Если во входных данных цифры не встречаются, то следует вывести \"-1\".  Например, пусть на вход подаются следующие символы:14ф73п439. В данном случае программа должна вывести97431",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942805\" width=\"100%\"><p class=\"left_margin\">На вход программе подается последовательность символов, среди которых встречаются и цифры. Ввод символов заканчивается точкой (в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая составит из тех цифр, которые встречаются во входных данных, максимальное число. При составлении итогового числа каждая цифра может быть использована только один раз. Если во входных данных цифры не встречаются, то следует вывести \"-1\". <p> </p><p class=\"left_margin\">Например, пусть на вход подаются следующие символы:<p class=\"left_margin\">14ф73п439.<p> </p><p class=\"left_margin\">В данном случае программа должна вывести<p class=\"left_margin\">97431</p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.varc : char;a : array [0..9] of boolean;i : integer;f : boolean; {флаг, показывающий, что в строке нашлись цифры} begin for i := 0 to 9 do a [i] := false; {обнуляем массив}f := false; {обнуляем флаг}read (c); while ( c <> '.' ) do {поиск окончания введённой строки}beginif (ord( c )-48) in [0..9] then begina [(ord( c )-48)] := true; {отнимаем 48 для того, чтобы получить искомое число}f := trueend; read (c)end;  for i := 9 downto 0 doif a [i]=true then write (i); {выводим результат}if not f then write ('-1') {проверка на то, нашлись ли цифры} end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3113\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var<p>c : char;<p>a : array [0..9] of boolean;<p>i : integer;<p>f : boolean; {флаг, показывающий, что в строке нашлись цифры}<p> </p><p>begin<p> </p><p>for i := 0 to 9 do a [i] := false; {обнуляем массив}<p>f := false; {обнуляем флаг}<p>read (c);<p> </p><p>while ( c &lt;&gt; '.' ) do {поиск окончания введённой строки}<p>begin<p>if (ord( c )-48) in [0..9] then<p> </p><p>begin<p>a [(ord( c )-48)] := true; {отнимаем 48 для того, чтобы получить искомое число}<p>f := true<p>end;<p> </p><p>read (c)<p>end;<p> </p><p> </p><p>for i := 9 downto 0 do<p>if a [i]=true then write (i); {выводим результат}<p>if not f then write ('-1') {проверка на то, нашлись ли цифры}<p> </p><p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3113"
        },
        {
            "answer": "Решение.var nс:аrrау[1..99] of integer; {массив числа участников от каждой школы, индекс каждого элемента – номер школы}р:1..99; {целый тип переменной задан диапазоном значений}{хотя можно и p:byte; ведь правильные входные данные гарантированы}с: char;i, k, N, max: integer; beginreadln(N); //количество учащихся for i:=l to 99 do nc[i]:=0;//обнуление,пусть видят,что Вы понимаите суть дела. for i:=l to N dobegin  repeat     read(c)  until с='  '; {считана фамилия}  repeat    read(c)  until с='  '; {считаны инициалы}readln(p); //вводим номер школыnc[p]:=nc[p]+1;//добавляем ещё участника в соответствующую школу end;max:=0; for i:=1 to 99 doif nc[i]>0 then     if nc[i]>max then max:=nc[i];//поиск максимума for i:=l to 99 do   if nc[i]=max then writeln(i);//вывод номера школыreadlnend.",
            "parsed": "2019-04-29 21:14:11.741599",
            "question": "На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет следующий формат: <Фамилия> <Инициалы> <номер школы>, где <Фамилия> - строка, состоящая не более чем из 20 символов, <Инициалы> - строка, состоящая из 4-х символов (буква, точка, буква, точка), <номер школы> - не более чем двузначный номер. <Фамилия> и <Инициалы>, а также <Инициалы> и <номер школы> разделены одним пробелом. Пример входной строки:Иванов П.С. 57Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран информацию, из какой школы (школ) было больше всего участников олимпиады.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942806\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет следующий формат: &lt;Фамилия&gt; &lt;Инициалы&gt; &lt;номер школы&gt;, где &lt;Фамилия&gt; - строка, состоящая не более чем из 20 символов, &lt;Инициалы&gt; - строка, состоящая из 4-х символов (буква, точка, буква, точка), &lt;номер школы&gt; - не более чем двузначный номер. &lt;Фамилия&gt; и &lt;Инициалы&gt;, а также &lt;Инициалы&gt; и &lt;номер школы&gt; разделены одним пробелом. Пример входной строки:<p class=\"left_margin\">Иванов П.С. 57<p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран информацию, из какой школы (школ) было больше всего участников олимпиады.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var nс:аrrау[1..99] of integer; {массив числа участников от каждой школы, индекс каждого элемента – номер школы}р:1..99; {целый тип переменной задан диапазоном значений}{хотя можно и p:byte; ведь правильные входные данные гарантированы}с: char;i, k, N, max: integer; beginreadln(N); //количество учащихся for i:=l to 99 do nc[i]:=0;//обнуление,пусть видят,что Вы понимаите суть дела. for i:=l to N dobegin  repeat     read(c)  until с='  '; {считана фамилия}  repeat    read(c)  until с='  '; {считаны инициалы}readln(p); //вводим номер школыnc[p]:=nc[p]+1;//добавляем ещё участника в соответствующую школу end;max:=0; for i:=1 to 99 doif nc[i]>0 then     if nc[i]>max then max:=nc[i];//поиск максимума for i:=l to 99 do   if nc[i]=max then writeln(i);//вывод номера школыreadlnend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3114\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var nс:аrrау[1..99] of integer; {массив числа участников от каждой школы, индекс каждого элемента – номер школы}<p>р:1..99; {целый тип переменной задан диапазоном значений}<p>{хотя можно и p:byte; ведь правильные входные данные гарантированы}<p>с: char;<p>i, k, N, max: integer;<p> </p><p>begin<p>readln(N); //количество учащихся<p> </p><p>for i:=l to 99 do nc[i]:=0;//обнуление,пусть видят,что Вы понимаите суть дела.<p> </p><p>for i:=l to N do<p>begin<p>  repeat<p>     read(c)<p>  until с='  '; {считана фамилия}<p>  repeat<p>    read(c)<p>  until с='  '; {считаны инициалы}<p>readln(p); //вводим номер школы<p>nc[p]:=nc[p]+1;//добавляем ещё участника в соответствующую школу<p> </p><p>end;<p>max:=0;<p> </p><p>for i:=1 to 99 do<p>if nc[i]&gt;0 then  <p>   if nc[i]&gt;max then max:=nc[i];//поиск максимума<p> </p><p>for i:=l to 99 do<p>   if nc[i]=max then writeln(i);//вывод номера школы<p>readln<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3114"
        },
        {
            "answer": "Решение.var Str,Strmax1,Strmax2:string[52];symbol:char;i,N,number,ball,max1,max2, nmax1, nmax2:integer; Beginmax1:=-1;max2:=-1;nmax1:=0;nmax2:=0;Strmax1:='';number:=0;Writeln('Введите количество учеников: ');readln(N);for i:=1 to N do  begin  str:=''; //обнуление строки  Repeat         //считываем до пробела  read(symbol);   //каждый символ  Str:=Str+symbol; //прибавляем к строке  Until symbol=' ';  //Фамилия считана  Repeat  read(symbol);  Str:=Str+symbol;  Until symbol=' '; //Имя считано,прибавлено к строке  read(number); //считываем номер  read(ball); //считываем балл  if number=30 then    begin //нас интересуют ученики только 30 школы    if ball>max1 then  //если текущий балл больше максимального      begin           max2:=max1; //бывший максимум-второй максимум           max1:=ball;  //максимальный балл-текущий балл           Strmax2:=Strmax1; //бывший лучший теперь второй лучший           Strmax1:=Str;  //текущий ученик набрал максимальный балл           nmax2:=nmax1;           nmax1:=1; //счетчик самых лучших равен 1      end  else if ball=max1 then    begin//если текущий балл равен максимальному        nmax1:=nmax1+1;    Strmax2:=str;    nmax2:=nmax1;  end    else if ball>max2 then  //если текущий балл больше второго лучшего      begin      max2:=ball;      Strmax2:=Str;      nmax2:=1;     endelse  if ball=max2 then nmax2:=nmax2+1; //если текущий балл равен 2 лучшемуend;end;if (nmax1 > 2) then  writeln(nmax1); //если лучших многоif (nmax1=2) then //если 2 ученика лучшие   begin    writeln(Strmax1);    writeln(Strmax2);   end; if (nmax1 = 1) and (nmax2 > 1) then writeln(Strmax1); //если один лучший и много вторых if (nmax1 = 1) and (nmax2 =1) then //если один лучший и один второй результат  begin    writeln(Strmax1);    writeln(Strmax2);   end;End.",
            "parsed": "2019-04-29 21:14:13.532222",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик, какой школы сколько набрал баллов. Эта информация в том же виде была разослана в школы.Завуч школы №30 решила наградить двух учащихся, которые лучше всех сдали информатику.Программа должна вывести на экран фамилии и имена этих учеников.Если наибольший балл набрало больше двух человек — вывести количество таких учеников.Если наибольший балл набрал один человек, а следующий балл набрало несколько человек — нужно вывести только фамилию и имя лучшего.Напишите эффективную, в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5 учеников школы №30.На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<Фамилия><Имя><Номер школы><Количество баллов><Фамилия> — строка, состоящая не более чем из 30 символов без пробелов,<Имя> — строка, состоящая не более чем из 20 символов.<Номер школы> — число в диапазоне от 1 до 99<Количество баллов> — число в диапазоне от 1 до 100.Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942800\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик, какой школы сколько набрал баллов. Эта информация в том же виде была разослана в школы.<p class=\"left_margin\">Завуч школы №30 решила наградить двух учащихся, которые лучше всех сдали информатику.<p class=\"left_margin\">Программа должна вывести на экран фамилии и имена этих учеников.<p class=\"left_margin\">Если наибольший балл набрало больше двух человек — вывести количество таких учеников.<p class=\"left_margin\">Если наибольший балл набрал один человек, а следующий балл набрало несколько человек — нужно вывести только фамилию и имя лучшего.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу(укажите используемую версию языка программирования),которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5 учеников школы №30.<p class=\"left_margin\">На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt;&lt;Имя&gt;&lt;Номер школы&gt;&lt;Количество баллов&gt;<p>&lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов,<p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов.<p>&lt;Номер школы&gt; — число в диапазоне от 1 до 99<p>&lt;Количество баллов&gt; — число в диапазоне от 1 до 100.<p class=\"left_margin\">Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var Str,Strmax1,Strmax2:string[52];symbol:char;i,N,number,ball,max1,max2, nmax1, nmax2:integer; Beginmax1:=-1;max2:=-1;nmax1:=0;nmax2:=0;Strmax1:='';number:=0;Writeln('Введите количество учеников: ');readln(N);for i:=1 to N do  begin  str:=''; //обнуление строки  Repeat         //считываем до пробела  read(symbol);   //каждый символ  Str:=Str+symbol; //прибавляем к строке  Until symbol=' ';  //Фамилия считана  Repeat  read(symbol);  Str:=Str+symbol;  Until symbol=' '; //Имя считано,прибавлено к строке  read(number); //считываем номер  read(ball); //считываем балл  if number=30 then    begin //нас интересуют ученики только 30 школы    if ball>max1 then  //если текущий балл больше максимального      begin           max2:=max1; //бывший максимум-второй максимум           max1:=ball;  //максимальный балл-текущий балл           Strmax2:=Strmax1; //бывший лучший теперь второй лучший           Strmax1:=Str;  //текущий ученик набрал максимальный балл           nmax2:=nmax1;           nmax1:=1; //счетчик самых лучших равен 1      end  else if ball=max1 then    begin//если текущий балл равен максимальному        nmax1:=nmax1+1;    Strmax2:=str;    nmax2:=nmax1;  end    else if ball>max2 then  //если текущий балл больше второго лучшего      begin      max2:=ball;      Strmax2:=Str;      nmax2:=1;     endelse  if ball=max2 then nmax2:=nmax2+1; //если текущий балл равен 2 лучшемуend;end;if (nmax1 > 2) then  writeln(nmax1); //если лучших многоif (nmax1=2) then //если 2 ученика лучшие   begin    writeln(Strmax1);    writeln(Strmax2);   end; if (nmax1 = 1) and (nmax2 > 1) then writeln(Strmax1); //если один лучший и много вторых if (nmax1 = 1) and (nmax2 =1) then //если один лучший и один второй результат  begin    writeln(Strmax1);    writeln(Strmax2);   end;End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3116\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var Str,Strmax1,Strmax2:string[52];<p>symbol:char;<p>i,N,number,ball,max1,max2, nmax1, nmax2:integer;<p> <p class=\"left_margin\">Begin<p>max1:=-1;<p>max2:=-1;<p>nmax1:=0;<p>nmax2:=0;<p class=\"left_margin\">Strmax1:='';<p>number:=0;<p class=\"left_margin\">Writeln('Введите количество учеников: ');<p>readln(N);<p>for i:=1 to N do<p>  begin<p>  str:=''; //обнуление строки<p>  Repeat         //считываем до пробела<p>  read(symbol);   //каждый символ<p>  Str:=Str+symbol; //прибавляем к строке<p>  Until symbol=' ';  //Фамилия считана<p>  Repeat<p>  read(symbol);<p>  Str:=Str+symbol;<p>  Until symbol=' '; //Имя считано,прибавлено к строке<p>  read(number); //считываем номер<p>  read(ball); //считываем балл<p>  if number=30 then<p>    begin //нас интересуют ученики только 30 школы<p>    if ball&gt;max1 then  //если текущий балл больше максимального<p>      begin<p>           max2:=max1; //бывший максимум-второй максимум<p>           max1:=ball;  //максимальный балл-текущий балл<p>           Strmax2:=Strmax1; //бывший лучший теперь второй лучший<p>           Strmax1:=Str;  //текущий ученик набрал максимальный балл<p>           nmax2:=nmax1;<p>           nmax1:=1; //счетчик самых лучших равен 1<p>      end<p>  else if ball=max1 then  <p>  begin//если текущий балл равен максимальному<p>        nmax1:=nmax1+1;<p>    Strmax2:=str;<p>    nmax2:=nmax1;<p>  end<p>    else if ball&gt;max2 then  //если текущий балл больше второго лучшего<p>      begin<p>      max2:=ball;<p>      Strmax2:=Str;<p>      nmax2:=1;<p>     end<p>else  if ball=max2 then nmax2:=nmax2+1; //если текущий балл равен 2 лучшему<p>end;<p>end;<p>if (nmax1 &gt; 2) then  writeln(nmax1); //если лучших много<p>if (nmax1=2) then //если 2 ученика лучшие<p>   begin<p>    writeln(Strmax1);<p>    writeln(Strmax2);<p>   end;<p> if (nmax1 = 1) and (nmax2 &gt; 1) then writeln(Strmax1); //если один лучший и много вторых<p> if (nmax1 = 1) and (nmax2 =1) then //если один лучший и один второй результат<p>  begin<p>    writeln(Strmax1);<p>    writeln(Strmax2);<p>   end;<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3116"
        },
        {
            "answer": "Решение.program C4_2;uses crt;type massiv=array[1..99] of integer;var count:massiv;       //массив количества учеников,где индекс-номер школы    sumball:massiv;     //массив суммы баллов    ch:char;    i,N,nomer,ball,max,nmax:integer;Beginfor i:=1 to 99 do    begin         count[i]:=0;   //обнуляем массивы         sumball[i]:=0;    end;write('Введите количество учеников: ');readln(n);for i:=1 to n dobegin Repeatread(ch);Until ch=' '; //фамилия считанаRepeatread(ch);Until ch=' ';//Имяread(nomer);read(ball); count[nomer]:=count[nomer]+1;   //счетчик количества учеников данной школыsumball[nomer]:=sumball[nomer]+ball; //сумма баллов end;for i:=1 to 99 doif count[i]>0 then sumball[i]:=round(sumball[i] / count[i]); //вычисляется средний балл// с точностью до целыхmax:=1;nmax:=1;for i:=2 to 99 doif sumball[i]>sumball[max] then       //поиск максимального среднего балла   begin   max:=i;   nmax:=1;   endelse if sumball[i]=sumball[max] then inc(nmax); if nmax=1 then writeln(max,' ',sumball[max])else writeln(nmax);End.",
            "parsed": "2019-04-29 21:14:14.028610",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик, какой школы, сколько набрал баллов.Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.Программа должна вывести на экран номер такой школы и её средний балл.Если наибольший средний балл набрало больше одной школы, вывести количество таких школ.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования), которая должна вывести на экран требуемую информацию.Также известно, что в районе школ с некоторыми номерами не существует.На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<Фамилия><Имя><Номер школы><Количество баллов><Фамилия>-строка, состоящая не более чем из 30 символов без пробелов,<Имя>-строка, состоящая не более чем из 20 символов.<Номер школы>-число в диапазоне от 1 до 99<Количество баллов>-число в диапазоне от 1 до 100.Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942801\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том,какой ученик, какой школы, сколько набрал баллов.<p class=\"left_margin\">Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.<p class=\"left_margin\">Программа должна вывести на экран номер такой школы и её средний балл.<p class=\"left_margin\">Если наибольший средний балл набрало больше одной школы, вывести количество таких школ.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования), которая должна вывести на экран требуемую информацию.<p class=\"left_margin\">Также известно, что в районе школ с некоторыми номерами не существует.<p class=\"left_margin\">На вход программе сначала подается число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt;&lt;Имя&gt;&lt;Номер школы&gt;&lt;Количество баллов&gt;<p>&lt;Фамилия&gt;-строка, состоящая не более чем из 30 символов без пробелов,<p>&lt;Имя&gt;-строка, состоящая не более чем из 20 символов.<p>&lt;Номер школы&gt;-число в диапазоне от 1 до 99<p>&lt;Количество баллов&gt;-число в диапазоне от 1 до 100.<p class=\"left_margin\">Эти данные записаны через пробел, то есть в каждой строке ровно 3 пробела.</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.program C4_2;uses crt;type massiv=array[1..99] of integer;var count:massiv;       //массив количества учеников,где индекс-номер школы    sumball:massiv;     //массив суммы баллов    ch:char;    i,N,nomer,ball,max,nmax:integer;Beginfor i:=1 to 99 do    begin         count[i]:=0;   //обнуляем массивы         sumball[i]:=0;    end;write('Введите количество учеников: ');readln(n);for i:=1 to n dobegin Repeatread(ch);Until ch=' '; //фамилия считанаRepeatread(ch);Until ch=' ';//Имяread(nomer);read(ball); count[nomer]:=count[nomer]+1;   //счетчик количества учеников данной школыsumball[nomer]:=sumball[nomer]+ball; //сумма баллов end;for i:=1 to 99 doif count[i]>0 then sumball[i]:=round(sumball[i] / count[i]); //вычисляется средний балл// с точностью до целыхmax:=1;nmax:=1;for i:=2 to 99 doif sumball[i]>sumball[max] then       //поиск максимального среднего балла   begin   max:=i;   nmax:=1;   endelse if sumball[i]=sumball[max] then inc(nmax); if nmax=1 then writeln(max,' ',sumball[max])else writeln(nmax);End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3117\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>program C4_2;<p>uses crt;<p>type massiv=array[1..99] of integer;<p>var count:massiv;       //массив количества учеников,где индекс-номер школы<p>    sumball:massiv;     //массив суммы баллов<p>    ch:char;<p>    i,N,nomer,ball,max,nmax:integer;<p class=\"left_margin\">Begin<p>for i:=1 to 99 do<p>    begin<p>         count[i]:=0;   //обнуляем массивы<p>         sumball[i]:=0;<p>    end;<p>write('Введите количество учеников: ');readln(n);<p>for i:=1 to n do<p>begin<p> </p><p class=\"left_margin\">Repeat<p>read(ch);<p class=\"left_margin\">Until ch=' '; //фамилия считана<p class=\"left_margin\">Repeat<p>read(ch);<p class=\"left_margin\">Until ch=' ';//Имя<p>read(nomer);<p>read(ball);<p> </p><p>count[nomer]:=count[nomer]+1;   //счетчик количества учеников данной школы<p>sumball[nomer]:=sumball[nomer]+ball; //сумма баллов<p> </p><p>end;<p>for i:=1 to 99 do<p>if count[i]&gt;0 then sumball[i]:=round(sumball[i] / count[i]); //вычисляется средний балл<p>// с точностью до целых<p>max:=1;<p>nmax:=1;<p>for i:=2 to 99 do<p>if sumball[i]&gt;sumball[max] then       //поиск максимального среднего балла<p>   begin<p>   max:=i;<p>   nmax:=1;<p>   end<p>else if sumball[i]=sumball[max] then inc(nmax);<p> </p><p>if nmax=1 then writeln(max,' ',sumball[max])<p>else writeln(nmax);<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3117"
        },
        {
            "answer": "Решение.Заметим, что вместо сравнения средних баллов можно сравнивать суммы баллов. Будем считывать имена, фамилии и суммы оценок в массив из 100 записей. Найдём три наименьших суммы баллов, затем, сравнивая все полученные ыллы с наибольшим из трёх полученных минимумов найдём нужных учеников. var a:array[1..100]of record                      name:string;                      point:integer;                      end;n,i,m,e,min,j,min1,min2:integer;c:char;beginmin:=20;min1:=20;min2:=20;read(n);for i:=1 to n dobegin    repeat{считываем имена фамилии}    read(c);    a[i].name:=a[i].name+c;    until c=' ';    a[i].name:=a[i].name+' ';    repeat    read(c);    a[i].name:=a[i].name+c;    until c=' ';    for j:=1 to 3 do   {считаем баллы}        begin             read(e);             m:=m+e;        end;    if m < min then   {сразу находим троих минимальных}       begin            min2:=min1;            min1:=min;            min:=m;       end    else    if m < min1 then       begin            min2:=min1;            min1:=m;       end    else    if m < min2 then    min2:=m;    a[i].point:=m;    m:=0;end;for i:=1 to n doif a[i].point<=min2       {все те кто меньше min2 будут равны или мин1 или min}then write(2,a[i].name);end. Замечание.На первый взгляд может показаться, что достаточно хранить только три записи, содержащие учеников с наименьшим количеством баллов. Но, например, если все ученики имеют одинаковый балл нужно вывести имена всех учеников, то есть в ходе программы, так или иначе, нужно запомнить все введённые имена.",
            "parsed": "2019-04-29 21:14:10.548078",
            "question": "На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат:  <Фамилия> <Имя> <оценки>,  где <Фамилия> – строка, состоящая не более чем из 20 символов, <Имя> – строка, состоящая не более чем из 15 символов, <оценки> – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. <Фамилия> и <Имя>, а также <Имя> и <оценки> разделены одним пробелом. Пример входной строки:  Иванов Петр 4 5 3  Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942802\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о сдаче экзаменов учениками 9-х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;оценки&gt;, <p> </p><p>где &lt;Фамилия&gt; – строка, состоящая не более чем из 20 символов, &lt;Имя&gt; – строка, состоящая не более чем из 15 символов, &lt;оценки&gt; – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. &lt;Фамилия&gt; и &lt;Имя&gt;, а также &lt;Имя&gt; и &lt;оценки&gt; разделены одним пробелом. Пример входной строки: <p> </p><p class=\"left_margin\">Иванов Петр 4 5 3 <p> </p><p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.</p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Заметим, что вместо сравнения средних баллов можно сравнивать суммы баллов. Будем считывать имена, фамилии и суммы оценок в массив из 100 записей. Найдём три наименьших суммы баллов, затем, сравнивая все полученные ыллы с наибольшим из трёх полученных минимумов найдём нужных учеников. var a:array[1..100]of record                      name:string;                      point:integer;                      end;n,i,m,e,min,j,min1,min2:integer;c:char;beginmin:=20;min1:=20;min2:=20;read(n);for i:=1 to n dobegin    repeat{считываем имена фамилии}    read(c);    a[i].name:=a[i].name+c;    until c=' ';    a[i].name:=a[i].name+' ';    repeat    read(c);    a[i].name:=a[i].name+c;    until c=' ';    for j:=1 to 3 do   {считаем баллы}        begin             read(e);             m:=m+e;        end;    if m < min then   {сразу находим троих минимальных}       begin            min2:=min1;            min1:=min;            min:=m;       end    else    if m < min1 then       begin            min2:=min1;            min1:=m;       end    else    if m < min2 then    min2:=m;    a[i].point:=m;    m:=0;end;for i:=1 to n doif a[i].point<=min2       {все те кто меньше min2 будут равны или мин1 или min}then write(2,a[i].name);end. Замечание.На первый взгляд может показаться, что достаточно хранить только три записи, содержащие учеников с наименьшим количеством баллов. Но, например, если все ученики имеют одинаковый балл нужно вывести имена всех учеников, то есть в ходе программы, так или иначе, нужно запомнить все введённые имена.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3118\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Заметим, что вместо сравнения средних баллов можно сравнивать суммы баллов. Будем считывать имена, фамилии и суммы оценок в массив из 100 записей. Найдём три наименьших суммы баллов, затем, сравнивая все полученные ыллы с наибольшим из трёх полученных минимумов найдём нужных учеников.<p> </p><p>var a:array[1..100]of record<p>                      name:string;<p>                      point:integer;<p>                      end;<p>n,i,m,e,min,j,min1,min2:integer;<p>c:char;<p>begin<p>min:=20;<p>min1:=20;<p>min2:=20;<p>read(n);<p>for i:=1 to n do<p>begin<p>    repeat{считываем имена фамилии}<p>    read(c);<p>    a[i].name:=a[i].name+c;<p>    until c=' ';<p>    a[i].name:=a[i].name+' ';<p>    repeat<p>    read(c);<p>    a[i].name:=a[i].name+c;<p>    until c=' ';<p>    for j:=1 to 3 do   {считаем баллы}<p>        begin<p>             read(e);<p>             m:=m+e;<p>        end;<p>    if m &lt; min then   {сразу находим троих минимальных}<p>       begin<p>            min2:=min1;<p>            min1:=min;<p>            min:=m;<p>       end<p>    else<p>    if m &lt; min1 then<p>       begin<p>            min2:=min1;<p>            min1:=m;<p>       end<p>    else<p>    if m &lt; min2 then<p>    min2:=m;<p>    a[i].point:=m;<p>    m:=0;<p>end;<p>for i:=1 to n do<p>if a[i].point&lt;=min2       {все те кто меньше min2 будут равны или мин1 или min}<p>then write(2,a[i].name);<p>end.<p> </p><p><b>Замечание.</b><p class=\"left_margin\">На первый взгляд может показаться, что достаточно хранить только три записи, содержащие учеников с наименьшим количеством баллов. Но, например, если все ученики имеют одинаковый балл нужно вывести имена всех учеников, то есть в ходе программы, так или иначе, нужно запомнить все введённые имена.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3118"
        },
        {
            "answer": "Решение.program C4;uses crt;var a:array['a'..'z'] of integer;i:integer;ch:char;Begin repeat      read(ch);      if ch in ['a'..'z'] then a[ch]:=a[ch]+1;Until ch='.'; for i:=1 to 255 dobegin     if (chr(i) in ['a'..'z']) and (a[chr(i)]>0) then     writeln(chr(i),a[chr(i)]);end;End.",
            "parsed": "2019-04-29 21:13:51.123441",
            "question": "На вход программы подаются произвольные алфавитно-цифровые символы. Ввод этих символов заканчивается точкой. Требуется написать программу, которая будет печатать последовательность строчных английских букв ('a' 'b'... 'z') из входной последовательности и частот их повторения. Печать должна происходить в алфавитном порядке. Например, пусть на вход подаются следующие символы: fhb5kbfыshfm. В этом случае программа должна вывести b2 f3 h2 k1 m1 s1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942803\" width=\"100%\"><p class=\"left_margin\">На вход программы подаются произвольные алфавитно-цифровые символы. Ввод этих символов заканчивается точкой. Требуется написать программу, которая будет печатать последовательность строчных английских букв ('a' 'b'... 'z') из входной последовательности и частот их повторения. Печать должна происходить в алфавитном порядке. Например, пусть на вход подаются следующие символы: <p>fhb5kbfыshfm. <p class=\"left_margin\">В этом случае программа должна вывести <p>b2 <p>f3 <p>h2 <p>k1 <p>m1 <p>s1</p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.program C4;uses crt;var a:array['a'..'z'] of integer;i:integer;ch:char;Begin repeat      read(ch);      if ch in ['a'..'z'] then a[ch]:=a[ch]+1;Until ch='.'; for i:=1 to 255 dobegin     if (chr(i) in ['a'..'z']) and (a[chr(i)]>0) then     writeln(chr(i),a[chr(i)]);end;End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3119\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>program C4;<p>uses crt;<p>var a:array['a'..'z'] of integer;<p>i:integer;<p>ch:char;<p class=\"left_margin\">Begin<p> </p><p>repeat<p>      read(ch);<p>      if ch in ['a'..'z'] then a[ch]:=a[ch]+1;<p class=\"left_margin\">Until ch='.';<p> </p><p>for i:=1 to 255 do<p>begin<p>     if (chr(i) in ['a'..'z']) and (a[chr(i)]&gt;0) then<p>     writeln(chr(i),a[chr(i)]);<p>end;<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3119"
        },
        {
            "answer": "Решение.program C4;uses crt;vara:array[0..25] of integer;m:array[0..25] of 'a'..'z';ch:char;i,j,k:integer; Beginfor i:=0 to 25 dobegina[i]:=0;m[i]:=chr(ord('a')+i);end; read(ch);while ch<>'.' dobegina[ord(ch)-ord('a')]:=a[ord(ch)-ord('a')]+1;read(ch);end; for i:=1 to 25 do    for j:=0 to 24 do        if a[j]>a[j+1] then           begin                k:=a[j];                ch:=m[j];                 a[j]:=a[j+1];                m[j]:=m[j+1];                 a[j+1]:=k;                m[j+1]:=ch;           end;i:=0; while a[i]=0 do inc(i);for j:=i to 25 do write(m[j]); End.",
            "parsed": "2019-04-29 21:13:50.232501",
            "question": "На вход программы подаются строчные английские буквы. Ввод этих букв заканчивается точкой (другие символы, отличные от «.» и букв «a».. «z» во входных данных отсутствуют. Требуется написать программу на одном из языков программирования, которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выдаются в алфавитном порядке. Например, пусть на вход подаются следующие символы:colaclc В данном случае программа должна вывести:аolc",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942796\" width=\"100%\"><p class=\"left_margin\">На вход программы подаются строчные английские буквы. Ввод этих букв заканчивается точкой (другие символы, отличные от «.» и букв «a».. «z» во входных данных отсутствуют. Требуется написать программу на одном из языков программирования, которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выдаются в алфавитном порядке. Например, пусть на вход подаются следующие символы:<p>colaclc<p> </p><p class=\"left_margin\">В данном случае программа должна вывести:<p>аolc</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.program C4;uses crt;vara:array[0..25] of integer;m:array[0..25] of 'a'..'z';ch:char;i,j,k:integer; Beginfor i:=0 to 25 dobegina[i]:=0;m[i]:=chr(ord('a')+i);end; read(ch);while ch<>'.' dobegina[ord(ch)-ord('a')]:=a[ord(ch)-ord('a')]+1;read(ch);end; for i:=1 to 25 do    for j:=0 to 24 do        if a[j]>a[j+1] then           begin                k:=a[j];                ch:=m[j];                 a[j]:=a[j+1];                m[j]:=m[j+1];                 a[j+1]:=k;                m[j+1]:=ch;           end;i:=0; while a[i]=0 do inc(i);for j:=i to 25 do write(m[j]); End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3120\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>program C4;<p>uses crt;<p>var<p>a:array[0..25] of integer;<p>m:array[0..25] of 'a'..'z';<p>ch:char;<p>i,j,k:integer;<p> </p><p class=\"left_margin\">Begin<p>for i:=0 to 25 do<p>begin<p>a[i]:=0;<p>m[i]:=chr(ord('a')+i);<p>end;<p> </p><p>read(ch);<p>while ch&lt;&gt;'.' do<p>begin<p>a[ord(ch)-ord('a')]:=a[ord(ch)-ord('a')]+1;<p>read(ch);<p>end;<p> </p><p>for i:=1 to 25 do<p>    for j:=0 to 24 do<p>        if a[j]&gt;a[j+1] then<p>           begin<p>                k:=a[j];<p>                ch:=m[j];<p> </p><p>                a[j]:=a[j+1];<p>                m[j]:=m[j+1];<p> </p><p>                a[j+1]:=k;<p>                m[j+1]:=ch;<p>           end;<p>i:=0;<p> </p><p>while a[i]=0 do inc(i);<p>for j:=i to 25 do write(m[j]);<p> </p><p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3120"
        },
        {
            "answer": "Решение.program letters;var A: array ['A'..'Z'] of integer;var B: array ['А'..'Я'] of integer;s: char;beginread(s);while s <> '.' do beginif s in ['A'..'Z'] then a[s]:=a[s]+1;if s in ['А'..'Я'] then b[s]:=b[s]+1;read(s)end;for s:= 'A' to 'Z' do if a[s]>0 then writeln (s,' ',a[s]);for s:= 'А' to 'Я' do if b[s]>0 then writeln (s,' ',b[s])end.",
            "parsed": "2019-04-29 21:14:05.817675",
            "question": "На вход в программу подается текст, состоящий из прописных букв русского и английского алфавита. между словами ставится один пробел, ввод текста заканчивается точкой. (Другие символы, отличные от \".\" и букв \"А\"...\"Я\" и \"А\"...\"Z\", на вход программы не поступают.)Требуется написать программу, которая будет проводить частотный анализ текста и последовательно выводить на экран только букву и число, равное количеству повторений этой буквы. Вначале необходимо вывести данные об английском, затем о русском алфавите. Буквы, не встречающиеся в тексте ни разу, выводиться не должны.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942799\" width=\"100%\"><p class=\"left_margin\">На вход в программу подается текст, состоящий из прописных букв русского и английского алфавита. между словами ставится один пробел, ввод текста заканчивается точкой. (Другие символы, отличные от \".\" и букв \"А\"...\"Я\" и \"А\"...\"Z\", на вход программы не поступают.)<p class=\"left_margin\">Требуется написать программу, которая будет проводить частотный анализ текста и последовательно выводить на экран только букву и число, равное количеству повторений этой буквы. Вначале необходимо вывести данные об английском, затем о русском алфавите. Буквы, не встречающиеся в тексте ни разу, выводиться не должны.</p></p></div>",
            "reference": "27 ",
            "solution": "Решение.program letters;var A: array ['A'..'Z'] of integer;var B: array ['А'..'Я'] of integer;s: char;beginread(s);while s <> '.' do beginif s in ['A'..'Z'] then a[s]:=a[s]+1;if s in ['А'..'Я'] then b[s]:=b[s]+1;read(s)end;for s:= 'A' to 'Z' do if a[s]>0 then writeln (s,' ',a[s]);for s:= 'А' to 'Я' do if b[s]>0 then writeln (s,' ',b[s])end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3123\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>program letters;<p>var A: array ['A'..'Z'] of integer;<p>var B: array ['А'..'Я'] of integer;<p>s: char;<p>begin<p>read(s);<p>while s &lt;&gt; '.' do <p>begin<p>if s in ['A'..'Z'] then a[s]:=a[s]+1;<p>if s in ['А'..'Я'] then b[s]:=b[s]+1;<p>read(s)<p>end;<p>for s:= 'A' to 'Z' do if a[s]&gt;0 then writeln (s,' ',a[s]);<p>for s:= 'А' to 'Я' do if b[s]&gt;0 then writeln (s,' ',b[s])<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3123"
        },
        {
            "answer": "Решение.varmin, ans: array[92..98] of integer;c: char;i, k, N, b: integer;beginfor i:=92 to 98 dobeginmin[i]:=3001;{допустимо и другое число, >3000}ans[i]:=0;end;readln(N);for i:=1 to N dobeginrepeatread(c);until c=' '; {считана компания}repeatread(c);until c=' '; {считана улица}readln(k,b);if min[k] > b thenbeginmin[k]:=b;ans[k]:=1end elseif min[k] = b then ans[k]:=ans[k]+1;end;{если бензина какой─то марки не было,ans[i] осталось равным 0}writeln(ans[92],' ', ans[95],' ', ans[98])end.",
            "parsed": "2019-04-29 21:13:54.686122",
            "question": "На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида бензина, сколько АЗС продают его дешевле всего. На вход программе в первой строке подается число данных о стоимости бензина. В каждой из последующих N строк находится информация в следующем формате:<Компания> <Улица> <Марка> <Цена> где <Компания> – строка, состоящая не более, чем из 20 символов без пробелов, <Улица> – строка, состоящая не более, чем из 20 символов без пробелов, <Марка> – одно из чисел – 92, 95 или 98, <Цена> – целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. <Компания> и <Улица>, <Улица> и <Марка>, а также <Марка> и <цена> разделены ровно одним пробелом. Пример входной строки: Синойл Цветочная 95 2250 Программа должна выводить через пробел 3 числа — количество АЗС, продающих дешевле всего 92-й, 95-й и 98-й бензин соответственно. Если бензин какой-то марки нигде не продавался, то следует вывести 0.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942792\" width=\"100%\"><p class=\"left_margin\">На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.<p class=\"left_margin\">Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида бензина, сколько АЗС продают его дешевле всего. На вход программе в первой строке подается число данных о стоимости бензина. В каждой из последующих N строк находится информация в следующем формате:<p>&lt;Компания&gt; &lt;Улица&gt; &lt;Марка&gt; &lt;Цена&gt; где &lt;Компания&gt; – строка, состоящая не более, чем из 20 символов без пробелов, &lt;Улица&gt; – строка, состоящая не более, чем из 20 символов без пробелов, &lt;Марка&gt; – одно из чисел – 92, 95 или 98, &lt;Цена&gt; – целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. &lt;Компания&gt; и &lt;Улица&gt;, &lt;Улица&gt; и &lt;Марка&gt;, а также &lt;Марка&gt; и &lt;цена&gt; разделены ровно одним пробелом. Пример входной строки: Синойл Цветочная 95 2250 Программа должна выводить через пробел 3 числа — количество АЗС, продающих дешевле всего 92-й, 95-й и 98-й бензин соответственно. Если бензин какой-то марки нигде не продавался, то следует вывести 0.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.varmin, ans: array[92..98] of integer;c: char;i, k, N, b: integer;beginfor i:=92 to 98 dobeginmin[i]:=3001;{допустимо и другое число, >3000}ans[i]:=0;end;readln(N);for i:=1 to N dobeginrepeatread(c);until c=' '; {считана компания}repeatread(c);until c=' '; {считана улица}readln(k,b);if min[k] > b thenbeginmin[k]:=b;ans[k]:=1end elseif min[k] = b then ans[k]:=ans[k]+1;end;{если бензина какой─то марки не было,ans[i] осталось равным 0}writeln(ans[92],' ', ans[95],' ', ans[98])end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3124\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var<p>min, ans: array[92..98] of integer;<p>c: char;<p>i, k, N, b: integer;<p>begin<p>for i:=92 to 98 do<p>begin<p>min[i]:=3001;{допустимо и другое число, &gt;3000}<p>ans[i]:=0;<p>end;<p>readln(N);<p>for i:=1 to N do<p>begin<p>repeat<p>read(c);<p>until c=' '; {считана компания}<p>repeat<p>read(c);<p>until c=' '; {считана улица}<p>readln(k,b);<p>if min[k] &gt; b then<p>begin<p>min[k]:=b;<p>ans[k]:=1<p>end else<p>if min[k] = b then ans[k]:=ans[k]+1;<p>end;<p>{если бензина какой─то марки не было,<p>ans[i] осталось равным 0}<p>writeln(ans[92],' ', ans[95],' ', ans[98])<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3124"
        },
        {
            "answer": "Решение.type uchenik =recordFam:string[20];name:string[15];b1,b2,b3:integer;end;varsrB:array [1..100] of real;i,k,l,p,N,m1,m2,m3:integer;max1,max2,max3,sr:real;c:char;a:array[1..100] of uchenik;beginread(n); //считали количество учениковif n>=10 then beginfor I:=1 to n dobegina[i].fam:='';repeat read(c);a[i].fam:= a[i].fam+c;until c=' '; //считали фамилиюrepeat read(c);a[i].name:= a[i].name+c;until c=' '; //считали имяread(m1); a[i].b1:=m1;read(m2); a[i].b2:=m2;read(m3); a[i].b3:=m3;end; //считали балыfor i:= 1 to n dosrB[i]:= a[i].b1+a[i].b2+a[i].b3; //создали массив, содержащий средние балы max1:=srB[1]; max2:=0;max3:=0;for i:= 2 to n do begin //нашли три максимумаif srB[i]>max1 then begin max3:=max2; max2:=max1; max1:=srB[i]; k:=i; endelse if srB[i]>max2 then begin max3:=max2; max2:=srB[i]; l:=i; endelse if srB[i]>max3 then begin max3:=srB[i]; p:=i; end;end;for i:=1 to n doif srB[i]>= max3 then writeln(a[i].fam, a[i].name);endelse writeln('учеников не может быть меньше 10');end. Приведём решение Ильи Муратова, Python. n=int(input())marks = []for i in range(n):    fname, lname, mark1, mark2, mark3 = input().split(\" \")    name = fname + \" \" + lname    mark_sum = int(mark1) + int(mark2) + int(mark3)    marks.append((mark_sum, name))marks.sort(reverse=True) # сортировка проходит по первому значению в tuplefor i in range(3):    print(marks[i][1])",
            "parsed": "2019-04-29 21:14:17.107053",
            "question": "На вход в программе подаются сведения о сдаче экзаменов учениками 9─х классов, некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, не превосходит 100. Каждая из N строк имеет следующий формат: <Фамилия><Имя><оценки>где<Фамилия>─строка, состоящая не более чем из 20 символов <Имя>─строка, состоящая не более чем из 15 символов <оценки>─через пробел три целых числа, соответствующие оценкам по пятибалльной системе. <Фамилия>, <Имя> и <оценки> разделены одним пробелом.требуется написать программу, которая будет выводить на экран имена 3─х лучших по среднему баллу учеников.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942788\" width=\"100%\"><p class=\"left_margin\">На вход в программе подаются сведения о сдаче экзаменов учениками 9─х классов, некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, не превосходит 100. Каждая из N строк имеет следующий формат: &lt;Фамилия&gt;&lt;Имя&gt;&lt;оценки&gt;<p>где&lt;Фамилия&gt;─строка, состоящая не более чем из 20 символов &lt;Имя&gt;─строка, состоящая не более чем из 15 символов &lt;оценки&gt;─через пробел три целых числа, соответствующие оценкам по пятибалльной системе. &lt;Фамилия&gt;, &lt;Имя&gt; и &lt;оценки&gt; разделены одним пробелом.<p>требуется написать программу, которая будет выводить на экран имена 3─х лучших по среднему баллу учеников.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.type uchenik =recordFam:string[20];name:string[15];b1,b2,b3:integer;end;varsrB:array [1..100] of real;i,k,l,p,N,m1,m2,m3:integer;max1,max2,max3,sr:real;c:char;a:array[1..100] of uchenik;beginread(n); //считали количество учениковif n>=10 then beginfor I:=1 to n dobegina[i].fam:='';repeat read(c);a[i].fam:= a[i].fam+c;until c=' '; //считали фамилиюrepeat read(c);a[i].name:= a[i].name+c;until c=' '; //считали имяread(m1); a[i].b1:=m1;read(m2); a[i].b2:=m2;read(m3); a[i].b3:=m3;end; //считали балыfor i:= 1 to n dosrB[i]:= a[i].b1+a[i].b2+a[i].b3; //создали массив, содержащий средние балы max1:=srB[1]; max2:=0;max3:=0;for i:= 2 to n do begin //нашли три максимумаif srB[i]>max1 then begin max3:=max2; max2:=max1; max1:=srB[i]; k:=i; endelse if srB[i]>max2 then begin max3:=max2; max2:=srB[i]; l:=i; endelse if srB[i]>max3 then begin max3:=srB[i]; p:=i; end;end;for i:=1 to n doif srB[i]>= max3 then writeln(a[i].fam, a[i].name);endelse writeln('учеников не может быть меньше 10');end. Приведём решение Ильи Муратова, Python. n=int(input())marks = []for i in range(n):    fname, lname, mark1, mark2, mark3 = input().split(\" \")    name = fname + \" \" + lname    mark_sum = int(mark1) + int(mark2) + int(mark3)    marks.append((mark_sum, name))marks.sort(reverse=True) # сортировка проходит по первому значению в tuplefor i in range(3):    print(marks[i][1])",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3128\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>type uchenik =record<p class=\"left_margin\">Fam:string[20];<p>name:string[15];<p>b1,b2,b3:integer;<p>end;<p>var<p>srB:array [1..100] of real;<p>i,k,l,p,N,m1,m2,m3:integer;<p>max1,max2,max3,sr:real;<p>c:char;<p>a:array[1..100] of uchenik;<p>begin<p>read(n); //считали количество учеников<p>if n&gt;=10 then begin<p>for I:=1 to n do<p>begin<p>a[i].fam:='';<p>repeat read(c);<p>a[i].fam:= a[i].fam+c;<p>until c=' '; //считали фамилию<p>repeat read(c);<p>a[i].name:= a[i].name+c;<p>until c=' '; //считали имя<p>read(m1); a[i].b1:=m1;<p>read(m2); a[i].b2:=m2;<p>read(m3); a[i].b3:=m3;<p>end; //считали балы<p>for i:= 1 to n do<p>srB[i]:= a[i].b1+a[i].b2+a[i].b3; //создали массив, содержащий средние балы<p> </p><p>max1:=srB[1]; max2:=0;max3:=0;<p>for i:= 2 to n do begin //нашли три максимума<p>if srB[i]&gt;max1 then begin max3:=max2; max2:=max1; max1:=srB[i]; k:=i; end<p>else if srB[i]&gt;max2 then begin max3:=max2; max2:=srB[i]; l:=i; end<p>else if srB[i]&gt;max3 then begin max3:=srB[i]; p:=i; end;<p>end;<p>for i:=1 to n do<p>if srB[i]&gt;= max3 then writeln(a[i].fam, a[i].name);<p>end<p>else writeln('учеников не может быть меньше 10');<p>end.<p> </p><p><b>Приведём решение Ильи Муратова, Python.</b><p> </p><p>n=int(input())<p>marks = []<p>for i in range(n):<p>    fname, lname, mark1, mark2, mark3 = input().split(\" \")<p>    name = fname + \" \" + lname<p>    mark_sum = int(mark1) + int(mark2) + int(mark3)<p>    marks.append((mark_sum, name))<p>marks.sort(reverse=True) # сортировка проходит по первому значению в tuple<p>for i in range(3):<p>    print(marks[i][1])</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3128"
        },
        {
            "answer": "Решение.var neg:array [1..100] of integer;pos:array [1..100] of integer;c,i,k,n,j:integer; beginwriteln('введите количество чисел, затем введите массив');readln(n);i:=1;k:=1;while n>0 dobeginread (c);if c<0 thenbegin neg[k]:= c; k:=k+1;endelseif (not(c=0)) thenbeginpos[i]:=c;i:=i+1;end;n:=n-1;end;for j:= 1 to k-1 dowrite (neg[j],' ');for j:= 1 to i-1 dowrite (pos[j],' ');end.  Пример 2. Решение задачи А на языке Паскаль.var  a: array[1..20] of integer; {исходные данные}  i: integer;begin  for i := 1 to 20 do read(a[i]);  for i := 1 to 20 do    if a[i]<0 then writeln(a[i]);  for i := 1 to 20 do    if a[i]>0 then writeln(a[i]);end.",
            "parsed": "2019-04-29 21:13:29.120747",
            "question": "На вход программе подается последовательность целых чисел. В первой строке сообщается количество чисел N, во второй строке идут сами числа.Требуется написать программу, которая будет выводить на экран числа в следующем порядке:сначала отрицательные числа, потом положительные. При этом должно сохраняться исходное взаимное положение, как среди отрицательных, так и среди положительных чисел Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется набор данных, состоящий из N = 20 пар целых чисел. Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных, состоящий из почти произвольного количества N целых чисел, чисел не может быть больше ста, N < 100. Напишите программу для решения такой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942790\" width=\"100%\"><p class=\"left_margin\">На вход программе подается последовательность целых чисел. В первой строке сообщается количество чисел N, во второй строке идут сами числа.<p class=\"left_margin\">Требуется написать программу, которая будет выводить на экран числа в следующем порядке:<p>сначала отрицательные числа, потом положительные. При этом должно сохраняться исходное взаимное положение, как среди отрицательных, так и среди положительных чисел<p> </p><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется набор данных, состоящий из N = 20 пар целых чисел. <p class=\"left_margin\">Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных, состоящий из почти произвольного количества N целых чисел, чисел не может быть больше ста, N &lt; 100. Напишите программу для решения такой задачи.<p class=\"left_margin\">Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var neg:array [1..100] of integer;pos:array [1..100] of integer;c,i,k,n,j:integer; beginwriteln('введите количество чисел, затем введите массив');readln(n);i:=1;k:=1;while n>0 dobeginread (c);if c<0 thenbegin neg[k]:= c; k:=k+1;endelseif (not(c=0)) thenbeginpos[i]:=c;i:=i+1;end;n:=n-1;end;for j:= 1 to k-1 dowrite (neg[j],' ');for j:= 1 to i-1 dowrite (pos[j],' ');end.  Пример 2. Решение задачи А на языке Паскаль.var  a: array[1..20] of integer; {исходные данные}  i: integer;begin  for i := 1 to 20 do read(a[i]);  for i := 1 to 20 do    if a[i]<0 then writeln(a[i]);  for i := 1 to 20 do    if a[i]>0 then writeln(a[i]);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3130\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p><div class=\"source_code lang_pascal\">var neg:array [1..100] of integer;<p>pos:array [1..100] of integer;<p>c,i,k,n,j:integer;<p> </p><p>begin<p>writeln('введите количество чисел, затем введите массив');<p>readln(n);<p>i:=1;<p>k:=1;<p>while n&gt;0 do<p>begin<p>read (c);<p>if c&lt;0 then<p>begin neg[k]:= c; k:=k+1;<p>end<p>else<p>if (not(c=0)) then<p>begin<p>pos[i]:=c;<p>i:=i+1;<p>end;<p>n:=n-1;<p>end;<p>for j:= 1 to k-1 do<p>write (neg[j],' ');<p>for j:= 1 to i-1 do<p>write (pos[j],' ');<p>end. </p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\">Пример 2. Решение задачи А на языке Паскаль.<p><div class=\"source_code lang_pascal\"><pre>var<p>  a: array[1..20] of integer; {исходные данные}<p>  i: integer;<p>begin<p>  for i := 1 to 20 do read(a[i]);<p>  for i := 1 to 20 do<p>    if a[i]&lt;0 then writeln(a[i]);<p>  for i := 1 to 20 do<p>    if a[i]&gt;0 then writeln(a[i]);<p>end.</p></p></p></p></p></p></p></p></p></pre></div></p></p></p></div>",
            "source": "",
            "task_id": "3130"
        },
        {
            "answer": "Решение.const LIM = 100;var Info: array[1..LIM] of record name: string; sum: integer; end; i, k, N, mark, min1, min2, min3: integer; c: char;beginreadln(N); { ввод исходных данных }for i:=1 to N do begin Info[i].name := '';  for k:=1 to 2 do repeat read(c); Info[i].name := Info[i].name + c; until c = ' '; Info[i].sum := 0;  for k:=1 to 3 do begin read(mark); Info[i].sum := Info[i].sum + mark; end; readln;end; { поиск трех минимальных }min1 := 20; min2 := 20; min3 := 20;for i:=1 to N do begin if Info[i].sum < min1 then begin  min3 := min2; min2 := min1;  min1 := Info[i].sum;  end else if Info[i].sum < min2 then begin  min3 := min2; min2 := Info[i].sum;  end else if Info[i].sum < min3 then  min3 := Info[i].sum;end; { вывод результата }for i:=1 to N do if Info[i].sum <= min3 then writeln(Info[i].name); end.",
            "parsed": "2019-04-29 21:14:11.004420",
            "question": "На вход программе подаются сведения о сдаче экзаменов учениками 9─х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат:<Фамилия> <Имя> <оценки>, где <Фамилия> – строка, состоящая не более чем из 20 символов, <Имя> – строка, состоящая не более чем из 15 символов, <оценки> – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. <Фамилия> и <Имя>, а также <Имя> и <оценки> разделены одним пробелом. Пример входной строки:Иванов Петр 4 5 3Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942791\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о сдаче экзаменов учениками 9─х классов некоторой средней школы. В первой строке сообщается количество учеников N, которое не меньше 10, но не превосходит 100, каждая из следующих N строк имеет следующий формат:<p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;оценки&gt;, где &lt;Фамилия&gt; – строка, состоящая не более чем из 20 символов, &lt;Имя&gt; – строка, состоящая не более чем из 15 символов, &lt;оценки&gt; – через пробел три целых числа, соответствующие оценкам по пятибалльной системе. &lt;Фамилия&gt; и &lt;Имя&gt;, а также &lt;Имя&gt; и &lt;оценки&gt; разделены одним пробелом. Пример входной строки:<p class=\"left_margin\">Иванов Петр 4 5 3<p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и имена трех худших по среднему баллу учеников. Если среди остальных есть ученики, набравшие тот же средний балл, что и один из трех худших, то следует вывести и их фамилии и имена.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.const LIM = 100;var Info: array[1..LIM] of record name: string; sum: integer; end; i, k, N, mark, min1, min2, min3: integer; c: char;beginreadln(N); { ввод исходных данных }for i:=1 to N do begin Info[i].name := '';  for k:=1 to 2 do repeat read(c); Info[i].name := Info[i].name + c; until c = ' '; Info[i].sum := 0;  for k:=1 to 3 do begin read(mark); Info[i].sum := Info[i].sum + mark; end; readln;end; { поиск трех минимальных }min1 := 20; min2 := 20; min3 := 20;for i:=1 to N do begin if Info[i].sum < min1 then begin  min3 := min2; min2 := min1;  min1 := Info[i].sum;  end else if Info[i].sum < min2 then begin  min3 := min2; min2 := Info[i].sum;  end else if Info[i].sum < min3 then  min3 := Info[i].sum;end; { вывод результата }for i:=1 to N do if Info[i].sum <= min3 then writeln(Info[i].name); end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3131\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>const LIM = 100;<p>var Info: array[1..LIM] of record<p> name: string;<p> sum: integer;<p> end;<p> i, k, N, mark, min1, min2, min3: integer;<p> c: char;<p>begin<p>readln(N);<p> { ввод исходных данных }<p>for i:=1 to N do begin<p> Info[i].name := ''; <p> for k:=1 to 2 do<p> repeat<p> read(c);<p> Info[i].name := Info[i].name + c;<p> until c = ' ';<p> Info[i].sum := 0; <p> for k:=1 to 3 do begin<p> read(mark);<p> Info[i].sum := Info[i].sum + mark;<p> end;<p> readln;<p>end;<p> { поиск трех минимальных }<p>min1 := 20; min2 := 20; min3 := 20;<p>for i:=1 to N do begin<p> if Info[i].sum &lt; min1 then begin <p> min3 := min2; min2 := min1; <p> min1 := Info[i].sum; <p> end<p> else if Info[i].sum &lt; min2 then begin <p> min3 := min2;<p> min2 := Info[i].sum; <p> end<p> else if Info[i].sum &lt; min3 then <p> min3 := Info[i].sum;<p>end;<p> { вывод результата }<p>for i:=1 to N do<p> if Info[i].sum &lt;= min3 then<p> writeln(Info[i].name); <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3131"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, сразу подсчитывая в массиве с индексами от 1 до 20 количество камней, принадлежащих определённой ценовой категории. Путём просмотра этого массива с конца (от 20-й ценовой категории) определяется число камней, заведомо попадающих в число 5% самых дорогих (добавление всех камней, следующей ценовой категории приводит к выходу за 5%). Последняя ценовая категория, в которую попало не менее одного драгоценного камня, запоминается. Если хотя чбы один из камней следующей ценовой категории также попадает в 5%, то проверяется имеют ли он и другие камни, набравшие столько же баллов, ценовую категорию не менее 15-й. В этом случае они все добавляются к числу драгоценных камней, которые необходимо поместить в сейф повышенной надёжности и ценовая категория которых является искомой.Паскальvar kcenkat : array[1..20] of integer;с : char;i,N,b,S,minckat : integer;beginfor i:=0 to 20 do kcenkat[i]:=0;readln(N);for i:=l to N dobeginrepeatread(c);until c=' '; {считано название драгоценного камня}repeatread(c);until c=' '; {считан код}readln(b);kcenkat[b]:-kcenkat[b]+1;end;S:=0; b:=20;while S+kcenkat[b] < N*0.05 dobeginif kcenkat[b]>0 thenbeginS:=S+kcenkat[b];minckat:=b;end;b:=b-l;end;{определены те камни, которые наверняка попадаютв сейф и пропущены ценовые категории, в которыене попал ни один камень}if S+1<=N*0.05 then{если ещё хотя бы один драгоценный камень попадётв 5%,то проверяется: ценовая категория этого итаких же камней — не менее 15-й}if b>=15 then minckat:=bwriteln(minckat);end. БейсикDIM kcenkatU ТО 20) AS INTEGERDIM ss AS STRINGINPUT NFOR TO NLINE INPUT ssi=lDOc$sMID$(ss,i,l)i-i+i;LOOP WHILE c$<>\" \"'Считываем название драгоценного камняDOc$-MID$(ss,i,l)i-i+1LOOP WHILE c$<>\" \"'Считываем кодb=VAL(MID$(ss,i))kcenkat(b)-kcenkat(b)+1NEXT jb-20WHILE s+kcenkat(b)<=N*0.05IF kcenkat(b)>0 THENs=s+kcenkat(b)minckat-bEND IFb=b-lWENDIF s+l<N*0.05 THENIF b>-15 THENminckat-bEND IFEND IFPRINT minckatEND",
            "parsed": "2019-04-29 21:13:57.186330",
            "question": "Завод по огранке драгоценных камней приобрёл сейф повышенной надёжности. Для определения драгоценных камней, которые необходимо положить в сейф, сначала отбираются 5% самых дорогих камней.Если у самого дешёвого камня из вошедших в группу 5% самых дорогих оказывается ценовая категория такая же, как и у нескольких других, то эти камни тоже включаются в группу камней для размещения в сейфе повышенной надёжности в том случае, если их ценовая категория не менее 15.Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая по результатам входных данных будет определять, какую минимальную цену должен иметь драгоценный камень, чтобы его поместили в сейф повышенной надёжности.На вход программе сначала подаётся общее количество камней на складе N. В каждой из следующих N строк находится информация по каждому камню отдельно в следующем формате:< Название драгоценного камня > < Код > < Ценовая категория >, где < Название драгоценного камня > — строка, состоящая не более чем из 20 символов, <Код> — строка, состоящая не более чем из 15 символов, < Ценовая категория > — целое число от 1 до 20.< Название драгоценного камня >, < Код > и < Ценовая категория > разделены одним пробелом. Пример входной строки: Рубин Р 123413.Программа должна выводить минимальную Ценовую категорию драгоценного камня, который необходимо положить в сейф повышенной надёжности.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942776\" width=\"100%\"><p class=\"left_margin\">Завод по огранке драгоценных камней приобрёл сейф повышенной надёжности. Для определения драгоценных камней, которые необходимо положить в сейф, сначала отбираются 5% самых дорогих камней.<p class=\"left_margin\">Если у самого дешёвого камня из вошедших в группу 5% самых дорогих оказывается ценовая категория такая же, как и у нескольких других, то эти камни тоже включаются в группу камней для размещения в сейфе повышенной надёжности в том случае, если их ценовая категория не менее 15.<p class=\"left_margin\">Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая по результатам входных данных будет определять, какую минимальную цену должен иметь драгоценный камень, чтобы его поместили в сейф повышенной надёжности.<p class=\"left_margin\">На вход программе сначала подаётся общее количество камней на складе N. В каждой из следующих N строк находится информация по каждому камню отдельно в следующем формате:<p>&lt; Название драгоценного камня &gt; &lt; Код &gt; &lt; Ценовая категория &gt;, где &lt; Название драгоценного камня &gt; — строка, состоящая не более чем из 20 символов, &lt;Код&gt; — строка, состоящая не более чем из 15 символов, &lt; Ценовая категория &gt; — целое число от 1 до 20.<p>&lt; Название драгоценного камня &gt;, &lt; Код &gt; и &lt; Ценовая категория &gt; разделены одним пробелом. Пример входной строки: Рубин Р 123413.<p class=\"left_margin\">Программа должна выводить минимальную Ценовую категорию драгоценного камня, который необходимо положить в сейф повышенной надёжности.</p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, сразу подсчитывая в массиве с индексами от 1 до 20 количество камней, принадлежащих определённой ценовой категории. Путём просмотра этого массива с конца (от 20-й ценовой категории) определяется число камней, заведомо попадающих в число 5% самых дорогих (добавление всех камней, следующей ценовой категории приводит к выходу за 5%). Последняя ценовая категория, в которую попало не менее одного драгоценного камня, запоминается. Если хотя чбы один из камней следующей ценовой категории также попадает в 5%, то проверяется имеют ли он и другие камни, набравшие столько же баллов, ценовую категорию не менее 15-й. В этом случае они все добавляются к числу драгоценных камней, которые необходимо поместить в сейф повышенной надёжности и ценовая категория которых является искомой.Паскальvar kcenkat : array[1..20] of integer;с : char;i,N,b,S,minckat : integer;beginfor i:=0 to 20 do kcenkat[i]:=0;readln(N);for i:=l to N dobeginrepeatread(c);until c=' '; {считано название драгоценного камня}repeatread(c);until c=' '; {считан код}readln(b);kcenkat[b]:-kcenkat[b]+1;end;S:=0; b:=20;while S+kcenkat[b] < N*0.05 dobeginif kcenkat[b]>0 thenbeginS:=S+kcenkat[b];minckat:=b;end;b:=b-l;end;{определены те камни, которые наверняка попадаютв сейф и пропущены ценовые категории, в которыене попал ни один камень}if S+1<=N*0.05 then{если ещё хотя бы один драгоценный камень попадётв 5%,то проверяется: ценовая категория этого итаких же камней — не менее 15-й}if b>=15 then minckat:=bwriteln(minckat);end. БейсикDIM kcenkatU ТО 20) AS INTEGERDIM ss AS STRINGINPUT NFOR TO NLINE INPUT ssi=lDOc$sMID$(ss,i,l)i-i+i;LOOP WHILE c$<>\" \"'Считываем название драгоценного камняDOc$-MID$(ss,i,l)i-i+1LOOP WHILE c$<>\" \"'Считываем кодb=VAL(MID$(ss,i))kcenkat(b)-kcenkat(b)+1NEXT jb-20WHILE s+kcenkat(b)<=N*0.05IF kcenkat(b)>0 THENs=s+kcenkat(b)minckat-bEND IFb=b-lWENDIF s+l<N*0.05 THENIF b>-15 THENminckat-bEND IFEND IFPRINT minckatEND",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3140\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, сразу подсчитывая в массиве с индексами от 1 до 20 количество камней, принадлежащих определённой ценовой категории. Путём просмотра этого массива с конца (от 20-й ценовой категории) определяется число камней, заведомо попадающих в число 5% самых дорогих (добавление всех камней, следующей ценовой категории приводит к выходу за 5%). Последняя ценовая категория, в которую попало не менее одного драгоценного камня, запоминается. Если хотя чбы один из камней следующей ценовой категории также попадает в 5%, то проверяется имеют ли он и другие камни, набравшие столько же баллов, ценовую категорию не менее 15-й. В этом случае они все добавляются к числу драгоценных камней, которые необходимо поместить в сейф повышенной надёжности и ценовая категория которых является искомой.<p class=\"left_margin\">Паскаль<p>var kcenkat : array[1..20] of integer;<p>с : char;<p>i,N,b,S,minckat : integer;<p>begin<p>for i:=0 to 20 do kcenkat[i]:=0;<p>readln(N);<p>for i:=l to N do<p>begin<p>repeat<p>read(c);<p>until c=' '; {считано название драгоценного камня}<p>repeat<p>read(c);<p>until c=' '; {считан код}<p>readln(b);<p>kcenkat[b]:-kcenkat[b]+1;<p>end;<p class=\"left_margin\">S:=0; b:=20;<p>while S+kcenkat[b] &lt; N*0.05 do<p>begin<p>if kcenkat[b]&gt;0 then<p>begin<p class=\"left_margin\">S:=S+kcenkat[b];<p>minckat:=b;<p>end;<p>b:=b-l;<p>end;{определены те камни, которые наверняка попадают<p>в сейф и пропущены ценовые категории, в которые<p>не попал ни один камень}<p>if S+1&lt;=N*0.05 then<p>{если ещё хотя бы один драгоценный камень попадёт<p>в 5%,то проверяется: ценовая категория этого и<p>таких же камней — не менее 15-й}<p>if b&gt;=15 then minckat:=b<p>writeln(minckat);<p>end.<p> </p><p class=\"left_margin\">Бейсик<p class=\"left_margin\">DIM kcenkatU ТО 20) AS INTEGER<p class=\"left_margin\">DIM ss AS STRING<p class=\"left_margin\">INPUT N<p class=\"left_margin\">FOR TO N<p class=\"left_margin\">LINE INPUT ss<p>i=l<p class=\"left_margin\">DO<p>c$sMID$(ss,i,l)<p>i-i+i;<p class=\"left_margin\">LOOP WHILE c$&lt;&gt;\" \"<p>'Считываем название драгоценного камня<p class=\"left_margin\">DO<p>c$-MID$(ss,i,l)<p>i-i+1<p class=\"left_margin\">LOOP WHILE c$&lt;&gt;\" \"<p>'Считываем код<p>b=VAL(MID$(ss,i))<p>kcenkat(b)-kcenkat(b)+1<p class=\"left_margin\">NEXT j<p>b-20<p class=\"left_margin\">WHILE s+kcenkat(b)&lt;=N*0.05<p class=\"left_margin\">IF kcenkat(b)&gt;0 THEN<p>s=s+kcenkat(b)<p>minckat-b<p class=\"left_margin\">END IF<p>b=b-l<p class=\"left_margin\">WEND<p class=\"left_margin\">IF s+l&lt;N*0.05 THEN<p class=\"left_margin\">IF b&gt;-15 THEN<p>minckat-b<p class=\"left_margin\">END IF<p class=\"left_margin\">END IF<p class=\"left_margin\">PRINT minckat<p class=\"left_margin\">END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3140"
        },
        {
            "answer": "Решение.var fio : array[1..100] of string;bs : array[1..100] of integer;max,N,i,k,b : integer; с : char;beginreadln(N);max:=0;for i:=1 to N do begin fio[i]:=' ';for k:=1 to 2 do \trepeat read(c);\tfio[i]:=fio[i]+c;until c=' ';read(bs[i]);\tfor k:=1 to 3 do \tbegin \tread(b);\tbs[i]:=bs[i]+b;\tend;readln;if bs[i]>max then max:=bs[i];end;for i:=1 to N doif bs[i]=mах then writeln(fio[i] ,max); end.",
            "parsed": "2019-04-29 21:14:17.569328",
            "question": "На вход программы подаются сведения о набранных на ЕГЭ баллах учениками данной школы по трём предметам. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат: < Фамилия > < Инициалы > < БаллыПоРусскомуЯзыку > <БаллыПоМа- тематике> <БаллыПоИнформатике>, где < Фамилия > — строка, состоящая не более чем из 20 символов, < Инициалы > — строка, состоящая из 4-х символов (буква, точка, буква, точка), <БаплыПоРусскому Языку^ <БаллыПоМатематике>, <БаллыПоИнформатике> — целые числа в диапазоне от 0 до 100. Все элементы одной строки отделены друг от друга пробелом. Пример входной строки: Петров С.Н. 78 82 70Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и инициалы учеников, набравших максимальную сумму баллов по трём предметам (таких учеников может быть несколько), а также набранную ими сумму баллов.Следует учитывать, что N < 100.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942778\" width=\"100%\"><p class=\"left_margin\">На вход программы подаются сведения о набранных на ЕГЭ баллах учениками данной школы по трём предметам. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат: &lt; Фамилия &gt; &lt; Инициалы &gt; &lt; БаллыПоРусскомуЯзыку &gt; &lt;БаллыПоМа- тематике&gt; &lt;БаллыПоИнформатике&gt;, где &lt; Фамилия &gt; — строка, состоящая не более чем из 20 символов, &lt; Инициалы &gt; — строка, состоящая из 4-х символов (буква, точка, буква, точка), &lt;БаплыПоРусскому Языку^ &lt;БаллыПоМатематике&gt;, &lt;БаллыПоИнформатике&gt; — целые числа в диапазоне от 0 до 100. Все элементы одной строки отделены друг от друга пробелом. Пример входной строки: Петров С.Н. 78 82 70<p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и инициалы учеников, набравших максимальную сумму баллов по трём предметам (таких учеников может быть несколько), а также набранную ими сумму баллов.<p class=\"left_margin\">Следует учитывать, что N &lt; 100.</p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var fio : array[1..100] of string;bs : array[1..100] of integer;max,N,i,k,b : integer; с : char;beginreadln(N);max:=0;for i:=1 to N do begin fio[i]:=' ';for k:=1 to 2 do \trepeat read(c);\tfio[i]:=fio[i]+c;until c=' ';read(bs[i]);\tfor k:=1 to 3 do \tbegin \tread(b);\tbs[i]:=bs[i]+b;\tend;readln;if bs[i]>max then max:=bs[i];end;for i:=1 to N doif bs[i]=mах then writeln(fio[i] ,max); end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3142\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var fio : array[1..100] of string;<p>bs : array[1..100] of integer;<p>max,N,i,k,b : integer; с : char;<p>begin<p>readln(N);<p>max:=0;<p>for i:=1 to N do begin fio[i]:=' ';<p>for k:=1 to 2 do <p>\trepeat read(c);<p>\tfio[i]:=fio[i]+c;<p>until c=' ';<p>read(bs[i]);<p>\tfor k:=1 to 3 do <p>\tbegin <p>\tread(b);<p>\tbs[i]:=bs[i]+b;<p>\tend;<p>readln;<p>if bs[i]&gt;max then max:=bs[i];<p>end;<p>for i:=1 to N do<p>if bs[i]=mах then writeln(fio[i] ,max); <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3142"
        },
        {
            "answer": "Решение.var fio:array[1..100] of string;var fioMin:array[1..100] of string;var sumMin:array[1..100] of integer;bRus:array[1..100] of integer; bMath:array[1..100] of integer; bInf:array[1..100] of integer;min,N,i,k,b,sum,iMin: integer; с: char;iMin: = 1;begin readln(N);min:=300; for i:=1 to N do begin fio[i]:=''; for k:=1 to 2 do repeat read(c);fio[i]:=fio[i]+c; until c=' '; read(bRus[i]);read(bMath[i]);read(bInf[i]);sum = (bRus[i] + bMath[i] + bInf[i]); if sum = min thenbeginfioMin[iMin] = fio[iMin];sumMin[iMin] = sum;iMin = iMin + 1;end; if sum < min thenbeginmin: = sum;for i:=1 to 100 dobeginfioMin[i]: =  '';end;fioMin[1]: = fio[i];sumMin[1] = sum;iMin := 1;end;end;for (i:=iMin downto 1) writeln(fioMin[i], sumMin[i]); end. Приведём решение Ильи Муратова, Python. n = int(input())pupils = []min_sum = 301for i in range(n):    lname, name_io, r_mark, m_mark, i_mark = input().split(' ')    mark_sum = int(r_mark) + int(m_mark) + int(i_mark)    if mark_sum < min_sum and mark_sum != 0:        pupils = []        pupils.append(lname + ' ' + name_io)        min_sum = mark_sum    elif mark_sum == min_sum and mark_sum != 0:        pupils.append(lname + ' ' + name_io)for pupil in pupils:    print pupil, min_sum / 3. # точка важна, иначе будет целочисленное деление",
            "parsed": "2019-04-29 21:14:17.883952",
            "question": "На вход программы подаются сведения о набранных на ЕГЭ баллах учениками данной школы по трём предметам. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат: < Фамилия > < Инициалы > <БаллыПоРусскомуЯзыку> <БаллыПоМатематике> <БаллыПоИнформатике>, где <Фамилия> — строка, состоящая не более чем из 20 символов, < Инициалы > — строка, состоящая из 4-х символов (буква, точка, буква, точка), <БаллыПоРусскомуЯзыку>, <БаллыПоМатематике>, <БаллыПоИнформатике> — целые числа в диапазоне от 0 до 100. Все элементы одной строки отделены друг от друга пробелом. Пример входной строки: Петров С.Н. 78 82 70Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и инициалы учеников, набравших минимальное среднее арифметическое баллов по трём предметам, отличное от 0 (таких учеников может быть несколько), а также среднее арифметическое набранных ими баллов.Следует учитывать, что N ^ 100.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942779\" width=\"100%\"><p class=\"left_margin\">На вход программы подаются сведения о набранных на ЕГЭ баллах учениками данной школы по трём предметам. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат: &lt; Фамилия &gt; &lt; Инициалы &gt; &lt;БаллыПоРусскомуЯзыку&gt; &lt;БаллыПоМатематике&gt; &lt;БаллыПоИнформатике&gt;, где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 символов, &lt; Инициалы &gt; — строка, состоящая из 4-х символов (буква, точка, буква, точка), &lt;БаллыПоРусскомуЯзыку&gt;, &lt;БаллыПоМатематике&gt;, &lt;БаллыПоИнформатике&gt; — целые числа в диапазоне от 0 до 100. Все элементы одной строки отделены друг от друга пробелом. <p class=\"left_margin\">Пример входной строки: Петров С.Н. 78 82 70<p class=\"left_margin\">Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран фамилии и инициалы учеников, набравших минимальное среднее арифметическое баллов по трём предметам, отличное от 0 (таких учеников может быть несколько), а также среднее арифметическое набранных ими баллов.<p class=\"left_margin\">Следует учитывать, что N ^ 100.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var fio:array[1..100] of string;var fioMin:array[1..100] of string;var sumMin:array[1..100] of integer;bRus:array[1..100] of integer; bMath:array[1..100] of integer; bInf:array[1..100] of integer;min,N,i,k,b,sum,iMin: integer; с: char;iMin: = 1;begin readln(N);min:=300; for i:=1 to N do begin fio[i]:=''; for k:=1 to 2 do repeat read(c);fio[i]:=fio[i]+c; until c=' '; read(bRus[i]);read(bMath[i]);read(bInf[i]);sum = (bRus[i] + bMath[i] + bInf[i]); if sum = min thenbeginfioMin[iMin] = fio[iMin];sumMin[iMin] = sum;iMin = iMin + 1;end; if sum < min thenbeginmin: = sum;for i:=1 to 100 dobeginfioMin[i]: =  '';end;fioMin[1]: = fio[i];sumMin[1] = sum;iMin := 1;end;end;for (i:=iMin downto 1) writeln(fioMin[i], sumMin[i]); end. Приведём решение Ильи Муратова, Python. n = int(input())pupils = []min_sum = 301for i in range(n):    lname, name_io, r_mark, m_mark, i_mark = input().split(' ')    mark_sum = int(r_mark) + int(m_mark) + int(i_mark)    if mark_sum < min_sum and mark_sum != 0:        pupils = []        pupils.append(lname + ' ' + name_io)        min_sum = mark_sum    elif mark_sum == min_sum and mark_sum != 0:        pupils.append(lname + ' ' + name_io)for pupil in pupils:    print pupil, min_sum / 3. # точка важна, иначе будет целочисленное деление",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3143\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var fio:array[1..100] of string;<p>var fioMin:array[1..100] of string;<p>var sumMin:array[1..100] of integer;<p>bRus:array[1..100] of integer; <p>bMath:array[1..100] of integer; <p>bInf:array[1..100] of integer;<p>min,N,i,k,b,sum,iMin: integer; <p>с: char;<p>iMin: = 1;<p>begin readln(N);<p>min:=300; <p>for i:=1 to N do <p>begin <p>fio[i]:=''; <p>for k:=1 to 2 do <p>repeat read(c);<p>fio[i]:=fio[i]+c; <p>until c=' '; <p>read(bRus[i]);<p>read(bMath[i]);<p>read(bInf[i]);<p>sum = (bRus[i] + bMath[i] + bInf[i]);<p> </p><p>if sum = min then<p>begin<p>fioMin[iMin] = fio[iMin];<p>sumMin[iMin] = sum;<p>iMin = iMin + 1;<p>end;<p> </p><p>if sum &lt; min then<p>begin<p>min: = sum;<p>for i:=1 to 100 do<p>begin<p>fioMin[i]: =  '';<p>end;<p>fioMin[1]: = fio[i];<p>sumMin[1] = sum;<p>iMin := 1;<p>end;<p>end;<p>for (i:=iMin downto 1) writeln(fioMin[i], sumMin[i]); <p>end.<p> </p><p><b>Приведём решение Ильи Муратова, Python.</b><p> </p><p>n = int(input())<p>pupils = []<p>min_sum = 301<p>for i in range(n):<p>    lname, name_io, r_mark, m_mark, i_mark = input().split(' ')<p>    mark_sum = int(r_mark) + int(m_mark) + int(i_mark)<p>    if mark_sum &lt; min_sum and mark_sum != 0:<p>        pupils = []<p>        pupils.append(lname + ' ' + name_io)<p>        min_sum = mark_sum<p>    elif mark_sum == min_sum and mark_sum != 0:<p>        pupils.append(lname + ' ' + name_io)<p>for pupil in pupils:<p>    print pupil, min_sum / 3. # точка важна, иначе будет целочисленное деление</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3143"
        },
        {
            "answer": "Решение.const N=31;type day = recordd : integer;s : real;end;var days : array[1..N] of day;tl,t2,s : real;i,k : integer;beginfor i:=l to N dobeginreadln(days[i].d,tl,t2);days[i].s:=(tl+t2)/2;end;i:=l;while i < N dobeginif days[i].s<days[i+1].s thenbegins:=days [i].s;k:=i;repeati:=i+l;s:=s+days[i].s;if i=N then break;until days[i].s>=days[i+1].s;writeln (k,'-',i,s/(i-k+1));end;i:=i+l;end;end.",
            "parsed": "2019-04-29 21:13:57.581032",
            "question": "На вход программе подаётся 31 строка. Строки содержат информацию о дневных и ночных температурах декабря 2008 года. Формат каждой из строк следующий: сначала записана дата в виде dd (на запись номера дня в числовом формате отводится строго два символа), затем через пробел записаны значения дневной и ночной температур — числа со знаком плюс или минус. Даты вводятся в порядке возрастания. Требуется написать программу, которая будет выводить на экран информацию о периодах непрерывного повышения среднесуточной температуры. Найденные значения для каждого из периодов следует выводить в отдельной строке в виде: номер первого дня периода, номер последнего дня периода, значение среднесуточной температуры за период.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942769\" width=\"100%\"><p class=\"left_margin\">На вход программе подаётся 31 строка. Строки содержат информацию о дневных и ночных температурах декабря 2008 года. Формат каждой из строк следующий: сначала записана дата в виде dd (на запись номера дня в числовом формате отводится строго два символа), затем через пробел записаны значения дневной и ночной температур — числа со знаком плюс или минус. Даты вводятся в порядке возрастания. Требуется написать программу, которая будет выводить на экран информацию о периодах непрерывного повышения среднесуточной температуры. Найденные значения для каждого из периодов следует выводить в отдельной строке в виде: номер первого дня периода, номер последнего дня периода, значение среднесуточной температуры за период.</p></div>",
            "reference": "27 ",
            "solution": "Решение.const N=31;type day = recordd : integer;s : real;end;var days : array[1..N] of day;tl,t2,s : real;i,k : integer;beginfor i:=l to N dobeginreadln(days[i].d,tl,t2);days[i].s:=(tl+t2)/2;end;i:=l;while i < N dobeginif days[i].s<days[i+1].s thenbegins:=days [i].s;k:=i;repeati:=i+l;s:=s+days[i].s;if i=N then break;until days[i].s>=days[i+1].s;writeln (k,'-',i,s/(i-k+1));end;i:=i+l;end;end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3149\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>const N=31;<p>type day = record<p>d : integer;<p>s : real;<p>end;<p>var days : array[1..N] of day;<p>tl,t2,s : real;<p>i,k : integer;<p>begin<p>for i:=l to N do<p>begin<p>readln(days[i].d,tl,t2);<p>days[i].s:=(tl+t2)/2;<p>end;<p>i:=l;<p>while i &lt; N do<p>begin<p>if days[i].s&lt;days[i+1].s then<p>begin<p>s:=days [i].s;<p>k:=i;<p>repeat<p>i:=i+l;<p>s:=s+days[i].s;<p>if i=N then break;<p>until days[i].s&gt;=days[i+1].s;<p>writeln (k,'-',i,s/(i-k+1));<p>end;<p>i:=i+l;<p>end;<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3149"
        },
        {
            "answer": "Решение. Ответ: ПАСКАЛЬvar S,Smax,Smax2:string[52]; ch:char;i, N, sh,ball, max, nmax, max2, nmax2 : integer;beginmax:=-1; Smax:=''; nmax:=0; max2:=-1;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin s : = \" ; repeatread(ch); s:=s+chuntil ch=' ';{считана фамилия и запомнена в переменной s}repeatread(ch); s : = s+chuntil ch=' ' ; {считано имя и добавленак переменной s} readln(sh,ball); {считали номер школы и балл ученика}if sh=50 then {обрабатываем только учеников 50-й школы} if ball>max then {текущий балл - лучший} beginmax2:=max;\tSmax2:=Smax; nmax2:=nmax;max : =bal 1; Smax : = s;\tnmax : = 1end elseif ball=max then {текущий балл - такой же, как лучший}beginnmax:=nmax+1; max2:=max; Smax2:=S end elseif ball>max2 then {текущий балл - лучше второго}beginmax2:=ball; Smax2:=S; nmax2:=1 end elseif ba1l=max2 then {текущий балл такой же, как второй}nmax2 : =nmax2 + lend;if (nmax=2) or (nmax= 1) and (nmax2 = 1) then {два лучших ученика}beginwriteln (Smax) ; writeln(Smax2) end elseif (nmax=l) and (nmax2>l) then {один лучший ученик}writeln(Smax) elsewriteln(nmax) {лучших учеников больше двух}end.",
            "parsed": "2019-04-29 21:14:14.483356",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал. Эта информация в том же виде была разослана в школы. Завуч школы № 50 решила наградить двух учащихся, которые лучше всех в школе сдали информатику. Программа должна вывести на экран фамилии и имена этих учеников.Если наибольший балл набрало больше двух человек — вывести количество таких учеников.Если наибольший балл набрал один человек, а следующий балл набрало несколько человек — нужно вывести только фамилию и имя лучшего.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников школы № 50. На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более, чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).  Пример входной строки: Иванов Иван 50 87 Пример выходных данных: Круглов Василий Тарасова ДарьяДругой вариант выходных данных: 7Третий вариант выходных данных: Гусарский Илья",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942316\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал. Эта информация в том же виде была разослана в школы. Завуч школы № 50 решила наградить двух учащихся, которые лучше всех в школе сдали информатику. Программа должна вывести на экран фамилии и имена этих учеников.<p class=\"left_margin\">Если наибольший балл набрало больше двух человек — вывести количество таких учеников.<p class=\"left_margin\">Если наибольший балл набрал один человек, а следующий балл набрало несколько человек — нужно вывести только фамилию и имя лучшего.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников школы № 50. <p class=\"left_margin\">На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt; где &lt;Фамилия&gt; — строка, состоящая не более, чем из 30 символов без пробелов, &lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, &lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, &lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке). <p> </p><p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">Круглов Василий Тарасова Дарья<p><i>Другой вариант выходных данных: </i><p class=\"left_margin\">7<p><i>Третий вариант выходных данных: </i><p class=\"left_margin\">Гусарский Илья</p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение. Ответ: ПАСКАЛЬvar S,Smax,Smax2:string[52]; ch:char;i, N, sh,ball, max, nmax, max2, nmax2 : integer;beginmax:=-1; Smax:=''; nmax:=0; max2:=-1;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin s : = \" ; repeatread(ch); s:=s+chuntil ch=' ';{считана фамилия и запомнена в переменной s}repeatread(ch); s : = s+chuntil ch=' ' ; {считано имя и добавленак переменной s} readln(sh,ball); {считали номер школы и балл ученика}if sh=50 then {обрабатываем только учеников 50-й школы} if ball>max then {текущий балл - лучший} beginmax2:=max;\tSmax2:=Smax; nmax2:=nmax;max : =bal 1; Smax : = s;\tnmax : = 1end elseif ball=max then {текущий балл - такой же, как лучший}beginnmax:=nmax+1; max2:=max; Smax2:=S end elseif ball>max2 then {текущий балл - лучше второго}beginmax2:=ball; Smax2:=S; nmax2:=1 end elseif ba1l=max2 then {текущий балл такой же, как второй}nmax2 : =nmax2 + lend;if (nmax=2) or (nmax= 1) and (nmax2 = 1) then {два лучших ученика}beginwriteln (Smax) ; writeln(Smax2) end elseif (nmax=l) and (nmax2>l) then {один лучший ученик}writeln(Smax) elsewriteln(nmax) {лучших учеников больше двух}end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3600\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p> </p><p><span style=\"letter-spacing:2px \">Ответ</span>:<p> </p><p class=\"left_margin\">ПАСКАЛЬ<p>var S,Smax,Smax2:string[52]; <p>ch:char;<p>i, N, sh,ball, max, nmax, max2, nmax2 : integer;<p>begin<p>max:=-1; Smax:=''; nmax:=0; <p>max2:=-1;<p>readln(N); {считали количество строк} <p>for i:=1 to N do {перебираем все входные строки} <p>begin s : = \" ; repeat<p>read(ch); <p>s:=s+ch<p>until ch=' ';{считана фамилия и запомнена в переменной s}<p>repeat<p>read(ch); <p>s : = s+ch<p>until ch=' ' ; {считано имя и добавленак переменной s} <p>readln(sh,ball); {считали номер школы и балл ученика}<p>if sh=50 then {обрабатываем только учеников 50-й школы} <p>if ball&gt;max then {текущий балл - лучший} <p>begin<p>max2:=max;\tSmax2:=Smax; nmax2:=nmax;<p>max : =bal 1; Smax : = s;\tnmax : = 1<p>end <p>else<p>if ball=max then {текущий балл - такой же, как лучший}<p>begin<p>nmax:=nmax+1; max2:=max; Smax2:=S end <p>else<p>if ball&gt;max2 then {текущий балл - лучше второго}<p>begin<p>max2:=ball; Smax2:=S; nmax2:=1 <p>end <p>else<p>if ba1l=max2 then {текущий балл такой же, как второй}<p>nmax2 : =nmax2 + l<p>end;<p>if (nmax=2) or (nmax= 1) and (nmax2 = 1) then {два лучших ученика}<p>begin<p>writeln (Smax) ; <p>writeln(Smax2) <p>end <p>else<p>if (nmax=l) and (nmax2&gt;l) then {один лучший ученик}<p>writeln(Smax) <p>else<p>writeln(nmax) {лучших учеников больше двух}<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3600"
        },
        {
            "answer": "Решение.ПАСКАЛЬ var s,k:array[1..99] of integer; ch:char;i,N,sh,ball,max,nmax:integer;beginfor i:=1 to 99 do {обнуляем массивы} begins[i]:=0; k[i]:=0 end;readln(N) ; {считали количество строк} for i:=1 to N do {перебираем все входные строки}begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';{считано имя}readln(sh,ball); {считали номер школы и балл ученика}s[sh]:=s[sh]+ball; {считаем сумму баллов по школе}k[sh]:=k[sh]+1  {считаем количество учеников из школы}end;for i:=1 to 99 doif k[i]>0 thens[i]:=s[i] div k[i]; {считаем средний балл по каждой школе}max:=1; nmax:=1;for i:=2 to 99 do {ищем максимум среди средних баллов}if s[i]>s[max] then beginmax:=i; nmax:=1 end elseif s[i]=s[max] then {считаем количество максимумов}nmax:=nmax+1; if nmax=1 thenwriteln(max, 1, ' ', s[max]) elsewriteln(nmax)end.",
            "parsed": "2019-04-29 21:14:14.800077",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.Программа должна вывести на экран номер такой школы и её средний балл.Если наибольший средний балл набрало больше одной школы — вывести количество таких школ.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:  <Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).Пример входной строки: Иванов Иван 50 87 Пример выходных данных: 50 74Другой вариант выходных данных: 7",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942312\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.<p class=\"left_margin\">Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.<p class=\"left_margin\">Программа должна вывести на экран номер такой школы и её средний балл.<p class=\"left_margin\">Если наибольший средний балл набрало больше одной школы — вывести количество таких школ.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. <p class=\"left_margin\">На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt;<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. <p class=\"left_margin\">Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">50 74<p><i>Другой вариант выходных данных:</i> <p class=\"left_margin\">7</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬ var s,k:array[1..99] of integer; ch:char;i,N,sh,ball,max,nmax:integer;beginfor i:=1 to 99 do {обнуляем массивы} begins[i]:=0; k[i]:=0 end;readln(N) ; {считали количество строк} for i:=1 to N do {перебираем все входные строки}begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';{считано имя}readln(sh,ball); {считали номер школы и балл ученика}s[sh]:=s[sh]+ball; {считаем сумму баллов по школе}k[sh]:=k[sh]+1  {считаем количество учеников из школы}end;for i:=1 to 99 doif k[i]>0 thens[i]:=s[i] div k[i]; {считаем средний балл по каждой школе}max:=1; nmax:=1;for i:=2 to 99 do {ищем максимум среди средних баллов}if s[i]>s[max] then beginmax:=i; nmax:=1 end elseif s[i]=s[max] then {считаем количество максимумов}nmax:=nmax+1; if nmax=1 thenwriteln(max, 1, ' ', s[max]) elsewriteln(nmax)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3604\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p> </p><p>var s,k:array[1..99] of integer; <p>ch:char;<p>i,N,sh,ball,max,nmax:integer;<p>begin<p>for i:=1 to 99 do {обнуляем массивы} <p>begin<p>s[i]:=0; <p>k[i]:=0 end;<p>readln(N) ; {считали количество строк} <p>for i:=1 to N do {перебираем все входные строки}<p>begin <p>repeat<p>read(ch)<p>until ch=' ';{считана фамилия} <p>repeat<p>read(ch) until ch=' ';{считано имя}<p>readln(sh,ball); {считали номер школы и балл ученика}<p>s[sh]:=s[sh]+ball; {считаем сумму баллов по школе}<p>k[sh]:=k[sh]+1  {считаем количество учеников из школы}<p>end;<p>for i:=1 to 99 do<p>if k[i]&gt;0 then<p>s[i]:=s[i] div k[i]; {считаем средний балл по каждой школе}<p>max:=1; <p>nmax:=1;<p>for i:=2 to 99 do {ищем максимум среди средних баллов}<p>if s[i]&gt;s[max] then <p>begin<p>max:=i; <p>nmax:=1 <p>end <p>else<p>if s[i]=s[max] then {считаем количество максимумов}<p>nmax:=nmax+1; <p>if nmax=1 then<p>writeln(max, 1, ' ', s[max]) <p>else<p>writeln(nmax)<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3604"
        },
        {
            "answer": "Решение.ПАСКАЛЬvar s,k:array[1..99] of integer; ch:char;i,N,sh,ball,avg,m:integer; beginfor i: =1 to 99 do {обнуляем массивы} begins [ i ] : = 0 ; k[i]:=0 end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ' ;{считано имя}readln(sh,ball); {считали номер школы и балл ученика}s [sh] : =s[sh]+ball; {считаем сумму баллов по школе}k[sh]:=k[sh]+l\t{считаем количество учеников из школы} end; avg:=0;for i: =1 to 99 do if к[i]>0 then beginavg:=avg+s[i]; {считаем сумму баллов по району}s [i] : = s [ i] div к [i] {считаем средний балл по каждой школе}end;avg:=avg div N;m: = 0 ; for i:=1 to 99 doif s [i]>avg then {отбираем школы, где средний балл выше районного}beginm:=m+1; {подсчитываем количество таких школ}ball:=s[i];  {запоминаем средний балл какой-нибудь из них}write(i, 1 ') end; writeln; if m=1 thenwriteln('Средний балл = ',ball) end.",
            "parsed": "2019-04-29 21:14:15.182336",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.Программа должна вывести на экран номер такой школы и её средний балл.Если наибольший средний балл набрало больше одной школы — вывести количество таких школ.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:  <Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).Пример входной строки: Иванов Иван 50 87 Пример выходных данных: 5 50 74 87Другой вариант выходных данных: 7Средний балл = 74",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942308\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.<p class=\"left_margin\">Районный методист решила выяснить номер школы, ученики которой набрали наибольший средний балл, с точностью до целых.<p class=\"left_margin\">Программа должна вывести на экран номер такой школы и её средний балл.<p class=\"left_margin\">Если наибольший средний балл набрало больше одной школы — вывести количество таких школ.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. <p class=\"left_margin\">На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt;<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. <p class=\"left_margin\">Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">5 50 74 87<p><i>Другой вариант выходных данных:</i> <p class=\"left_margin\">7<p class=\"left_margin\">Средний балл = 74</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬvar s,k:array[1..99] of integer; ch:char;i,N,sh,ball,avg,m:integer; beginfor i: =1 to 99 do {обнуляем массивы} begins [ i ] : = 0 ; k[i]:=0 end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ' ;{считано имя}readln(sh,ball); {считали номер школы и балл ученика}s [sh] : =s[sh]+ball; {считаем сумму баллов по школе}k[sh]:=k[sh]+l\t{считаем количество учеников из школы} end; avg:=0;for i: =1 to 99 do if к[i]>0 then beginavg:=avg+s[i]; {считаем сумму баллов по району}s [i] : = s [ i] div к [i] {считаем средний балл по каждой школе}end;avg:=avg div N;m: = 0 ; for i:=1 to 99 doif s [i]>avg then {отбираем школы, где средний балл выше районного}beginm:=m+1; {подсчитываем количество таких школ}ball:=s[i];  {запоминаем средний балл какой-нибудь из них}write(i, 1 ') end; writeln; if m=1 thenwriteln('Средний балл = ',ball) end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3608\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p>var s,k:array[1..99] of integer; <p>ch:char;<p>i,N,sh,ball,avg,m:integer; <p>begin<p>for i: =1 to 99 do {обнуляем массивы} <p>begin<p>s [ i ] : = 0 ; <p>k[i]:=0 <p>end;<p>readln(N); {считали количество строк} <p>for i:=1 to N do {перебираем все входные строки} <p>begin <p>repeat<p>read(ch)<p>until ch=' ';{считана фамилия} <p>repeat<p>read(ch) until ch=' ' ;{считано имя}<p>readln(sh,ball); {считали номер школы и балл ученика}<p>s [sh] : =s[sh]+ball; {считаем сумму баллов по школе}<p>k[sh]:=k[sh]+l\t{считаем количество учеников из школы} <p>end; <p>avg:=0;<p>for i: =1 to 99 do if к[i]&gt;0 then <p>begin<p>avg:=avg+s[i]; {считаем сумму баллов по району}<p>s [i] : = s [ i] div к [i] {считаем средний балл по каждой школе}<p>end;<p>avg:=avg div N;<p>m: = 0 ; <p>for i:=1 to 99 do<p>if s [i]&gt;avg then {отбираем школы, где средний балл выше районного}<p>begin<p>m:=m+1; {подсчитываем количество таких школ}<p>ball:=s[i];  {запоминаем средний балл какой-нибудь из них}<p>write(i, 1 ') <p>end; <p>writeln; <p>if m=1 then<p>writeln('Средний балл = ',ball) <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3608"
        },
        {
            "answer": "Решение.ПАСКАЛЬvar num,bal: array[1..99] of integer;name:\tarray[1..99] of string[52];s:string[52]; ch:char;i,N,sh,ball:integer; beginfor i: =1 to 99 do {обнуляем массивы} beginnum[i]:=0; bal[i]:=-1 end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin s : =' ';repeatread(ch); s : =s+ch;until ch=' ';{считана фамилия и записана в переменную s}repeatread(ch) until ch= ' '; {считано имя} readln(sh,ball); {считали номер школы и балл ученика}if ball > bal[sh] then {если текущий балл лучше} beginbal[sh]:=ball; {запоминаем текущий балл по школе}name[sh]:=s;\t{и фамилию ученика}end;num[sh]:=num[sh]+1;\t{считаем количество учеников из школы}end;for i:=1 to 99 doif num[i] > = 3 then {выбираем только школы,из которых сдавало больше трех учеников} writeln{i,' ',name[i]);end.",
            "parsed": "2019-04-29 21:14:15.665924",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.Районный методист решила выяснить фамилии учеников, которые набрали наибольший балл, по каждой школе в отдельности, но только если из школы информатику сдавало не меньше 3 человек. Если в школе информатику сдавало меньше 3 человек, информацию по этой школе выводить не нужно.Программа должна вывести на экран информацию в виде: <Номер школы> <Фамилия ученика>в отдельной строке для каждой школы.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют.На вход программе сначала подаётся число учеников, сда-вавших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 0 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке). Пример входной строки: Иванов Иван 50 87 Пример выходных данных: 5 Иванов50 Петров74 Сидоров",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942304\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.<p class=\"left_margin\">Районный методист решила выяснить фамилии учеников, которые набрали наибольший балл, по каждой школе в отдельности, но только если из школы информатику сдавало не меньше 3 человек. Если в школе информатику сдавало меньше 3 человек, информацию по этой школе выводить не нужно.<p class=\"left_margin\">Программа должна вывести на экран информацию в виде: <p>&lt;Номер школы&gt; &lt;Фамилия ученика&gt;<p>в отдельной строке для каждой школы.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют.<p class=\"left_margin\">На вход программе сначала подаётся число учеников, сда-вавших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt; <p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 0 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p> </p><p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">5 Иванов<p class=\"left_margin\">50 Петров<p class=\"left_margin\">74 Сидоров</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬvar num,bal: array[1..99] of integer;name:\tarray[1..99] of string[52];s:string[52]; ch:char;i,N,sh,ball:integer; beginfor i: =1 to 99 do {обнуляем массивы} beginnum[i]:=0; bal[i]:=-1 end;readln(N); {считали количество строк} for i:=1 to N do {перебираем все входные строки} begin s : =' ';repeatread(ch); s : =s+ch;until ch=' ';{считана фамилия и записана в переменную s}repeatread(ch) until ch= ' '; {считано имя} readln(sh,ball); {считали номер школы и балл ученика}if ball > bal[sh] then {если текущий балл лучше} beginbal[sh]:=ball; {запоминаем текущий балл по школе}name[sh]:=s;\t{и фамилию ученика}end;num[sh]:=num[sh]+1;\t{считаем количество учеников из школы}end;for i:=1 to 99 doif num[i] > = 3 then {выбираем только школы,из которых сдавало больше трех учеников} writeln{i,' ',name[i]);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3612\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p>var num,bal: array[1..99] of integer;<p>name:\tarray[1..99] of string[52];<p>s:string[52]; <p>ch:char;<p>i,N,sh,ball:integer; <p>begin<p>for i: =1 to 99 do {обнуляем массивы} <p>begin<p>num[i]:=0; <p>bal[i]:=-1 end;<p>readln(N); {считали количество строк} <p>for i:=1 to N do {перебираем все входные строки} <p>begin <p>s : =' ';<p>repeat<p>read(ch); <p>s : =s+ch;<p>until ch=' ';{считана фамилия и записана в переменную s}<p>repeat<p>read(ch) <p>until ch= ' '; {считано имя} <p>readln(sh,ball); {считали номер школы и балл ученика}<p>if ball &gt; bal[sh] then {если текущий балл лучше} <p>begin<p>bal[sh]:=ball; {запоминаем текущий балл по школе}<p>name[sh]:=s;\t{и фамилию ученика}<p>end;<p>num[sh]:=num[sh]+1;\t{считаем количество учеников из школы}<p>end;<p>for i:=1 to 99 do<p>if num[i] &gt; = 3 then {выбираем только школы,из которых сдавало больше трех учеников} <p>writeln{i,' ',name[i]);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3612"
        },
        {
            "answer": "Решение.var nmax,mах:array[1. .99] of integer;ch:char;i,N, sh,ball,k:integer;beginfor i: =1 to 99 do {обнуляем массивы}beginnmax[i] := 0;max[i]:=-1end;readln(N); {считали количество строк}for i:=1 to N do {перебираем все входные строки}beginrepeatread(ch)until ch=' ';{считана фамилия}repeatread(ch) until ch=' ';{считано имя}readln(sh,ball); {считали номер школы и балл ученика}if ball>max[sh] then {сравниваем текущий балл с лучшим баллом по школе}beginmax[sh]:=ball; {меняем лучший балл по школе}nmax[sh]:=1; {число людей в школе с таким баллом устанавливаем =1}endelseif ball=max[sh] then {в школе есть еще такой лучший балл}nmax[sh] : =nmax[sh] +1; {увеличиваем число людей в школе с таким баллом}end;k: =0;for i:=1 to 99 doif nmax[i]>2 then {отбираем только школы, у которых лучший балл}begin {набрало более 2-х учеников}k:=k+1; {считаем количество таких школ}ball:=max[i]; {запоминаем балл в какой-нибудь из них}write(i,' ')  {выводим номер такой школы}end;if k=0 thenwriteln('Нет таких школ')elsebeginwriteln;if k=1 thenwriteln('Наибольший балл = ',ball)endend.",
            "parsed": "2019-04-29 21:14:16.141087",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.Районный методист решила выяснить номера школ, в которых один и тот же максимальный балл набрало более двух учеников. Например, если в школах 3, 5 и 7 по три ученика набрало баллы соответственно 70, 80 и 90 нужно вывести номера эти школ.Если таких школ несколько нужно вывести номера этих школ. Если такая школа одна нужно вывести её номер и максимальный балл.Если таких школ нет, то нужно вывести \"Нет таких школ\"Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате:  <Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).Пример входной строки: Иванов Иван 50 87 Пример выходных данных: 5 50 74 87Другой вариант выходных данных: 7Наибольший балл = 74 Третий вариант выходных данных:Нет таких школ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942300\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал.<p class=\"left_margin\">Районный методист решила выяснить номера школ, в которых один и тот же максимальный балл набрало более двух учеников. Например, если в школах 3, 5 и 7 по три ученика набрало баллы соответственно 70, 80 и 90 нужно вывести номера эти школ.<p class=\"left_margin\">Если таких школ несколько нужно вывести номера этих школ. Если такая школа одна нужно вывести её номер и максимальный балл.<p class=\"left_margin\">Если таких школ нет, то нужно вывести \"Нет таких школ\"<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран требуемую информацию. Известно, что информатику сдавало больше 5-ти учеников района. Также известно, что в районе школы с некоторыми номерами не существуют. <p class=\"left_margin\">На вход программе сначала подаётся число учеников, сдававших экзамен. В каждой из следующих N строк находится информация об учениках в формате: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt;<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. <p class=\"left_margin\">Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">5 50 74 87<p><i>Другой вариант выходных данных:</i> <p class=\"left_margin\">7<p class=\"left_margin\">Наибольший балл = 74 <p><i>Третий вариант выходных данных:</i><p class=\"left_margin\">Нет таких школ</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.var nmax,mах:array[1. .99] of integer;ch:char;i,N, sh,ball,k:integer;beginfor i: =1 to 99 do {обнуляем массивы}beginnmax[i] := 0;max[i]:=-1end;readln(N); {считали количество строк}for i:=1 to N do {перебираем все входные строки}beginrepeatread(ch)until ch=' ';{считана фамилия}repeatread(ch) until ch=' ';{считано имя}readln(sh,ball); {считали номер школы и балл ученика}if ball>max[sh] then {сравниваем текущий балл с лучшим баллом по школе}beginmax[sh]:=ball; {меняем лучший балл по школе}nmax[sh]:=1; {число людей в школе с таким баллом устанавливаем =1}endelseif ball=max[sh] then {в школе есть еще такой лучший балл}nmax[sh] : =nmax[sh] +1; {увеличиваем число людей в школе с таким баллом}end;k: =0;for i:=1 to 99 doif nmax[i]>2 then {отбираем только школы, у которых лучший балл}begin {набрало более 2-х учеников}k:=k+1; {считаем количество таких школ}ball:=max[i]; {запоминаем балл в какой-нибудь из них}write(i,' ')  {выводим номер такой школы}end;if k=0 thenwriteln('Нет таких школ')elsebeginwriteln;if k=1 thenwriteln('Наибольший балл = ',ball)endend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3616\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p>var nmax,mах:array[1. .99] of integer;<p>ch:char;<p>i,N, sh,ball,k:integer;<p>begin<p>for i: =1 to 99 do {обнуляем массивы}<p>begin<p>nmax[i] := 0;<p>max[i]:=-1<p>end;<p>readln(N); {считали количество строк}<p>for i:=1 to N do {перебираем все входные строки}<p>begin<p>repeat<p>read(ch)<p>until ch=' ';{считана фамилия}<p>repeat<p>read(ch) until ch=' ';{считано имя}<p>readln(sh,ball); {считали номер школы и балл ученика}<p>if ball&gt;max[sh] then {сравниваем текущий балл с лучшим баллом по школе}<p>begin<p>max[sh]:=ball; {меняем лучший балл по школе}<p>nmax[sh]:=1; {число людей в школе с таким баллом устанавливаем =1}<p>end<p>else<p>if ball=max[sh] then {в школе есть еще такой лучший балл}<p>nmax[sh] : =nmax[sh] +1; {увеличиваем число людей в школе с таким баллом}<p>end;<p>k: =0;<p>for i:=1 to 99 do<p>if nmax[i]&gt;2 then {отбираем только школы, у которых лучший балл}<p>begin {набрало более 2-х учеников}<p>k:=k+1; {считаем количество таких школ}<p>ball:=max[i]; {запоминаем балл в какой-нибудь из них}<p>write(i,' ')  {выводим номер такой школы}<p>end;<p>if k=0 then<p>writeln('Нет таких школ')<p>else<p>begin<p>writeln;<p>if k=1 then<p>writeln('Наибольший балл = ',ball)<p>end<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3616"
        },
        {
            "answer": "Решение.ПАСКАЛЬvar.s:string; flag:boolean; i, k,len:integer; beginreadln(s); {считали всю входную строку} flag:=false; {признак середины слова} for i : =1 to length (s) do begin{если текущий символ - буква} if (upcase(s[i])>='A' ) and (upcase(s[i])<= 'Z') thenif flag then {не первая буква слова}  len:=len+1 {текущая длина слова увеличилась на 1} else\t{первая буква слова}beginflag:=true;len:=1\t{текущая длина слова = 1}endelse\t{текущий символ — не буква}if flag then {слово только что закончилось} beginflag:=false; for k:=1 to len do {перебираем все символы слова}beginif ((s[i-k]>='a') and (s[i-k]<='z'))thens[i-k]:=chr((ord(s[i-k])+len-ord('a')) mod 26 + ord('a'))elses[i-k]:=chr((ord(s[i-k])+len-ord('A')) mod 26 + ord('A'));end endend;writeln(s) end.",
            "parsed": "2019-04-29 21:14:04.908539",
            "question": "При программировании школьной тестирующей системы по английскому языку выяснилось, что файлы с вопросами к тестам легко доступны, и каждый может перед тестом открыть их и заранее узнать вопросы. Было решено закодировать файлы. Для этого придумали следующий алгоритм.Каждая строка файла кодируется отдельно.В каждой строке ищутся отдельные слова, и все символы слова сдвигаются по алфавиту циклически вправо на длину слова.Словом считается любая последовательность подряд идущих символов латинского алфавита, строчных и прописных.Циклический сдвиг символа по алфавиту вправо на X — замена символа на символ, стоящий в алфавите на X позиций дальше. Если при этом происходит выход за пределы алфавита, счёт начинается с начала алфавита.Пример циклического сдвига символов на 3 позиции: буква «Е» превращается в букву «Н», буква «t» — в букву «w» буква «Y» — в букву «В».Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна закодировать строку по указанному алгоритму.На вход программе подается строка, состоящая из не более чем 250 символов латинского алфавита, пробелов, знаков препинания, разного рода скобок, кавычек и других символов. Строка заканчивается символом «#». Других символов «#» в строке нет.Программа должна вывести закодированную по указанному алгоритму строку. Пример входных данных: Day, mice. \"Year\" - a mistake# Пример выходных данных: Gdb, qmgi. \"Ciev\" - b tpzahrl#",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942296\" width=\"100%\"><p class=\"left_margin\">При программировании школьной тестирующей системы по английскому языку выяснилось, что файлы с вопросами к тестам легко доступны, и каждый может перед тестом открыть их и заранее узнать вопросы. Было решено закодировать файлы. Для этого придумали следующий алгоритм.<p class=\"left_margin\">Каждая строка файла кодируется отдельно.<p class=\"left_margin\">В каждой строке ищутся отдельные слова, и все символы слова сдвигаются по алфавиту циклически вправо на длину слова.<p class=\"left_margin\">Словом считается любая последовательность подряд идущих символов латинского алфавита, строчных и прописных.<p class=\"left_margin\">Циклический сдвиг символа по алфавиту вправо на X — замена символа на символ, стоящий в алфавите на X позиций дальше. Если при этом происходит выход за пределы алфавита, счёт начинается с начала алфавита.<p class=\"left_margin\">Пример циклического сдвига символов на 3 позиции: буква «Е» превращается в букву «Н», буква «t» — в букву «w» буква «Y» — в букву «В».<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна закодировать строку по указанному алгоритму.<p class=\"left_margin\">На вход программе подается строка, состоящая из не более чем 250 символов латинского алфавита, пробелов, знаков препинания, разного рода скобок, кавычек и других символов. Строка заканчивается символом «#». Других символов «#» в строке нет.<p class=\"left_margin\">Программа должна вывести закодированную по указанному алгоритму строку.<p> </p><p><i>Пример входных данных: </i><p class=\"left_margin\">Day, mice. \"Year\" - a mistake# <p><i>Пример выходных данных: </i><p class=\"left_margin\">Gdb, qmgi. \"Ciev\" - b tpzahrl#<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬvar.s:string; flag:boolean; i, k,len:integer; beginreadln(s); {считали всю входную строку} flag:=false; {признак середины слова} for i : =1 to length (s) do begin{если текущий символ - буква} if (upcase(s[i])>='A' ) and (upcase(s[i])<= 'Z') thenif flag then {не первая буква слова}  len:=len+1 {текущая длина слова увеличилась на 1} else\t{первая буква слова}beginflag:=true;len:=1\t{текущая длина слова = 1}endelse\t{текущий символ — не буква}if flag then {слово только что закончилось} beginflag:=false; for k:=1 to len do {перебираем все символы слова}beginif ((s[i-k]>='a') and (s[i-k]<='z'))thens[i-k]:=chr((ord(s[i-k])+len-ord('a')) mod 26 + ord('a'))elses[i-k]:=chr((ord(s[i-k])+len-ord('A')) mod 26 + ord('A'));end endend;writeln(s) end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3620\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p>var.s:string; <p>flag:boolean; <p>i, k,len:integer; begin<p>readln(s); {считали всю входную строку} <p>flag:=false; {признак середины слова} <p>for i : =1 to length (s) do <p>begin<p>{если текущий символ - буква} <p>if (upcase(s[i])&gt;='A' ) and (upcase(s[i])&lt;= 'Z') <p>then<p>if flag then {не первая буква слова}  <p>len:=len+1 {текущая длина слова увеличилась на 1} <p>else\t{первая буква слова}<p>begin<p>flag:=true;<p>len:=1\t{текущая длина слова = 1}<p>end<p>else\t{текущий символ — не буква}<p>if flag then {слово только что закончилось} <p>begin<p>flag:=false; for k:=1 to len do {перебираем все символы слова}<p>begin<p>if ((s[i-k]&gt;='a') and (s[i-k]&lt;='z'))<p>then<p>s[i-k]:=chr((ord(s[i-k])+len-ord('a')) mod 26 + ord('a'))<p>else<p>s[i-k]:=chr((ord(s[i-k])+len-ord('A')) mod 26 + ord('A'));<p>end <p>end<p>end;<p>writeln(s) <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3620"
        },
        {
            "answer": "Решение.ПАСКАЛЬvar k:array[0..100] of integer; (число учеников, набравших такой балл)ch:char;i,N,sh,ball,num,s:integer; beginfor i: =0 to 100 do {обнуляем массив} k[i]:=0;readln(N); (считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';(считано имя}readln(sh,ball); {считали номер школы и балл ученика}k[ball]:=k[ball]+l {считаем количество учеников, набравших такой балл}end;num:=N div 5; {вычисляем 20% от количества учеников}S : = 0 ; i : = 101 ;whilе s < num do begini:=i-l; s:=s+k[i] end;if s=num then {\"отлично\" можно поставить ровно 20% участников}writeln(i) elseif k[i]=s then {наибольший балл набрало более 20% участников}writeln(i)else\t{ученики, набравшие \"i\" баллов, не получат \"отлично\"}begini:=i+l;while k[i]=0 do {ищем участников с большим баллом}i:=i+l; writeln(i) endend.",
            "parsed": "2019-04-29 21:14:16.612106",
            "question": "После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал. По положению об экзамене каж¬дый район сам определяет, за какой балл нужно поставить какую оценку.Районный методист решила, что оценку «отлично» должны получить 20% участников (целое число, с отбрасыванием дробной части).Для этого она должна определить, какой балл должен был набрать ученик, чтобы получить «отлично».Если невозможно определить такой балл, чтобы «отлично» получили ровно 20% участников, «отлично» должно получить меньше участников, чем 20%.Если таких участников не окажется (наибольший балл набрали больше 20% участников) — эти и только эти ученики должны получить «отлично».Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран наименьший балл, который набра¬ли участники, получившие «отлично». Известно, что информатику сдавало больше 5-ти учеников. Также известно, что есть такое количество баллов, которое не получил ни один участник.На вход программе сначала подаётся число учеников, сда-вавших экзамен. В каждой из следующих N строк находится информация об учениках в формате: <Фамилия> <Имя> <Номер школы> <Количество баллов> где <Фамилия> — строка, состоящая не более чем из 30 символов без пробелов, <Имя> — строка, состоящая не более чем из 20 символов без пробелов, <Номер школы> — целое число в диапазоне от 1 до 99, <Количество баллов> — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке). Пример входной строки: Иванов Иван 50 87 Пример выходных данных: 78",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942292\" width=\"100%\"><p class=\"left_margin\">После единых выпускных экзаменов по информатике в район пришла информация о том, какой ученик какой школы сколько баллов набрал. По положению об экзамене каж¬дый район сам определяет, за какой балл нужно поставить какую оценку.<p class=\"left_margin\">Районный методист решила, что оценку «отлично» должны получить 20% участников (целое число, с отбрасыванием дробной части).<p class=\"left_margin\">Для этого она должна определить, какой балл должен был набрать ученик, чтобы получить «отлично».<p class=\"left_margin\">Если невозможно определить такой балл, чтобы «отлично» получили ровно 20% участников, «отлично» должно получить меньше участников, чем 20%.<p class=\"left_margin\">Если таких участников не окажется (наибольший балл набрали больше 20% участников) — эти и только эти ученики должны получить «отлично».<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая должна вывести на экран наименьший балл, который набра¬ли участники, получившие «отлично». Известно, что информатику сдавало больше 5-ти учеников. Также известно, что есть такое количество баллов, которое не получил ни один участник.<p class=\"left_margin\">На вход программе сначала подаётся число учеников, сда-вавших экзамен. В каждой из следующих N строк находится информация об учениках в формате:<p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;Номер школы&gt; &lt;Количество баллов&gt;<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 30 символов без пробелов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Номер школы&gt; — целое число в диапазоне от 1 до 99, <p>&lt;Количество баллов&gt; — целое число в диапазоне от 1 до 100. Эти данные записаны через пробел, причём ровно один между каждой парой (то есть всего по три пробела в каждой строке).<p> </p><p><i>Пример входной строки: </i><p class=\"left_margin\">Иванов Иван 50 87 <p><i>Пример выходных данных:</i> <p class=\"left_margin\">78<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.ПАСКАЛЬvar k:array[0..100] of integer; (число учеников, набравших такой балл)ch:char;i,N,sh,ball,num,s:integer; beginfor i: =0 to 100 do {обнуляем массив} k[i]:=0;readln(N); (считали количество строк} for i:=1 to N do {перебираем все входные строки} begin repeatread(ch)until ch=' ';{считана фамилия} repeatread(ch) until ch=' ';(считано имя}readln(sh,ball); {считали номер школы и балл ученика}k[ball]:=k[ball]+l {считаем количество учеников, набравших такой балл}end;num:=N div 5; {вычисляем 20% от количества учеников}S : = 0 ; i : = 101 ;whilе s < num do begini:=i-l; s:=s+k[i] end;if s=num then {\"отлично\" можно поставить ровно 20% участников}writeln(i) elseif k[i]=s then {наибольший балл набрало более 20% участников}writeln(i)else\t{ученики, набравшие \"i\" баллов, не получат \"отлично\"}begini:=i+l;while k[i]=0 do {ищем участников с большим баллом}i:=i+l; writeln(i) endend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3624\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">ПАСКАЛЬ<p>var k:array[0..100] of integer; (число учеников, набравших такой балл)<p>ch:char;<p>i,N,sh,ball,num,s:integer; <p>begin<p>for i: =0 to 100 do {обнуляем массив} <p>k[i]:=0;<p>readln(N); (считали количество строк} <p>for i:=1 to N do {перебираем все входные строки} <p>begin <p>repeat<p>read(ch)<p>until ch=' ';{считана фамилия} <p>repeat<p>read(ch) until ch=' ';(считано имя}<p>readln(sh,ball); {считали номер школы и балл ученика}<p>k[ball]:=k[ball]+l {считаем количество учеников, набравших такой балл}<p>end;<p>num:=N div 5; {вычисляем 20% от количества учеников}<p class=\"left_margin\">S : = 0 ; <p>i : = 101 ;<p>whilе s &lt; num do <p>begin<p>i:=i-l; <p>s:=s+k[i] <p>end;<p>if s=num then {\"отлично\" можно поставить ровно 20% участников}<p>writeln(i) <p>else<p>if k[i]=s then {наибольший балл набрало более 20% участников}<p>writeln(i)<p>else\t{ученики, набравшие \"i\" баллов, не получат \"отлично\"}<p>begin<p>i:=i+l;<p>while k[i]=0 do {ищем участников с большим баллом}<p>i:=i+l; <p>writeln(i) <p>end<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3624"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве. Во время чтения программа помнит число LMax — высоту самого высокого из уже закончившихся подъемов, а также необходимые сведения о текущем подъеме, например, число L — высоту текущего подъема (то есть разность между последним и первым числом участка) и последнее прочитанное число T (это число — наибольшее из чисел текущего подъема). Прочитав очередное число R, программа сравнивает его с числом T. Если R > T, то значение L увеличивается на R-T. В противном случае фиксируется конец подъема и начало нового участка. То есть, во-первых, значение L сравнивается с LMax и, при необходимости, LMax полагается равным L. Во-вторых, полагаем L = 0. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик:program c4_1; varR, T, N, L, LMax : Integer;begin N:=0; L:=0; LMax:=0; T:=1001; repeatReadLn(R); if R<>0 then N:=N+1; if R>T then L:=L+R-T else beginif L>LMax then LMax:=L; L:=0; end; T:=R; until R=0;WriteLn('Получено ', N, ' чисел'); WriteLn('Наибольшая высота подъема ', LMax); end.DIM R, T, N, L, LMax AS INTEGERN = 0L = 0LMax = 0T = 1001;DOINPUT RIF R <> 0 THEN N = N + 1IF R > T THEN L = L + R-TELSEIF L > LMax THEN LMax = L L = 0END IFT = R LOOP UNTIL R = 0 PRINT \"Получено \"; N; \" чисел\" PRINT \"Наибольшая высота подъема \"; Lmax Пример правильной и эффективной программы на языке Алгоритмическом языке:алг C4_1 начцел R, T, N, L, LMaxN:=0L:=0LMax:=0T:=1001;нцввод Rесли R<>0 то N:=N+1 всеесли R>T тоL:=L+R-T иначеесли L>LMax то LMax:=L все L:=0 все T:=R кц при R=0вывод \"Получено \", N, \" чисел\", нс вывод \"Наибольшая высота подъема \", LMax, нс кон",
            "parsed": "2019-04-29 21:13:12.837496",
            "question": "По каналу связи передается последовательность положительных целых   чисел   , …   все   числа   не   превышают   1000,   их количество заранее неизвестно. Каждое число передается в виде отдельной текстовой строки, содержащей десятичную запись числа. Признаком конца передаваемой последовательности является число 0. Участок последовательности от элемента  до элемента  называется подъемом, если на этом участке каждое следующее число больше предыдущего. Высотой подъема называется разность . Напишите эффективную программу, которая вычисляет наибольшую высоту среди всех подъемов последовательности. Если в последовательности нет ни одного подъема, программа выдает 0. Программа должна напечатать отчет по следующей форме:Получено ... чисел Наибольшая высота подъема: … Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б. Перед   текстом   программы   кратко   опишите   используемый   вами алгоритм решения задачи.Пример входных данных:144172737911100Пример выходных данных для приведенного выше примера входных данных:Получено 8 чиселНаибольшая высота подъема: 10 ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942288\" width=\"100%\"><p class=\"left_margin\">По каналу связи передается последовательность положительных целых   чисел   <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/ee/ee9eccf40707b43259036204bf4e43e3.svg\" style=\"vertical-align:-3pt\"/>, …   все   числа   не   превышают   1000,   их количество заранее неизвестно. Каждое число передается в виде отдельной текстовой строки, содержащей десятичную запись числа. Признаком конца передаваемой последовательности является число 0. Участок последовательности от элемента <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/fe/fec5686df909391ff18c49731646c790.svg\" style=\"vertical-align:-2pt\"/> до элемента <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/55/55bcd3e4d5b510daf8caf5b72527ba18.svg\" style=\"vertical-align:-3pt\"/> называется подъемом, если на этом участке каждое следующее число больше предыдущего. Высотой подъема называется разность <img class=\"tex\" src=\"https://ege.sdamgia.ru/formula/svg/fb/fb3600dc29a7a9aac88bcba3e25e93fd.svg\" style=\"vertical-align:-3pt\"/>. Напишите эффективную программу, которая вычисляет наибольшую высоту среди всех подъемов последовательности. Если в последовательности нет ни одного подъема, программа выдает 0. Программа должна напечатать отчет по следующей форме:<p class=\"left_margin\">Получено ... чисел Наибольшая высота подъема: …<p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p class=\"left_margin\">Перед   текстом   программы   кратко   опишите   используемый   вами алгоритм решения задачи.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">144<p class=\"left_margin\">17<p class=\"left_margin\">27<p class=\"left_margin\">3<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">11<p class=\"left_margin\">10<p class=\"left_margin\">0<p><i>Пример выходных данных для приведенного выше примера входных данных</i>:<p class=\"left_margin\">Получено 8 чисел<p class=\"left_margin\">Наибольшая высота подъема: 10<p> </p><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве. Во время чтения программа помнит число LMax — высоту самого высокого из уже закончившихся подъемов, а также необходимые сведения о текущем подъеме, например, число L — высоту текущего подъема (то есть разность между последним и первым числом участка) и последнее прочитанное число T (это число — наибольшее из чисел текущего подъема). Прочитав очередное число R, программа сравнивает его с числом T. Если R > T, то значение L увеличивается на R-T. В противном случае фиксируется конец подъема и начало нового участка. То есть, во-первых, значение L сравнивается с LMax и, при необходимости, LMax полагается равным L. Во-вторых, полагаем L = 0. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик:program c4_1; varR, T, N, L, LMax : Integer;begin N:=0; L:=0; LMax:=0; T:=1001; repeatReadLn(R); if R<>0 then N:=N+1; if R>T then L:=L+R-T else beginif L>LMax then LMax:=L; L:=0; end; T:=R; until R=0;WriteLn('Получено ', N, ' чисел'); WriteLn('Наибольшая высота подъема ', LMax); end.DIM R, T, N, L, LMax AS INTEGERN = 0L = 0LMax = 0T = 1001;DOINPUT RIF R <> 0 THEN N = N + 1IF R > T THEN L = L + R-TELSEIF L > LMax THEN LMax = L L = 0END IFT = R LOOP UNTIL R = 0 PRINT \"Получено \"; N; \" чисел\" PRINT \"Наибольшая высота подъема \"; Lmax Пример правильной и эффективной программы на языке Алгоритмическом языке:алг C4_1 начцел R, T, N, L, LMaxN:=0L:=0LMax:=0T:=1001;нцввод Rесли R<>0 то N:=N+1 всеесли R>T тоL:=L+R-T иначеесли L>LMax то LMax:=L все L:=0 все T:=R кц при R=0вывод \"Получено \", N, \" чисел\", нс вывод \"Наибольшая высота подъема \", LMax, нс кон",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3628\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве. Во время чтения программа помнит число LMax — высоту самого высокого из уже закончившихся подъемов, а также необходимые сведения о текущем подъеме, например, число L — высоту текущего подъема (то есть разность между последним и первым числом участка) и последнее прочитанное число T (это число — наибольшее из чисел текущего подъема). Прочитав очередное число R, программа сравнивает его с числом T. Если R &gt; T, то значение L увеличивается на R-T. В противном случае фиксируется конец подъема и начало нового участка. То есть, во-первых, значение L сравнивается с LMax и, при необходимости, LMax полагается равным L. Во-вторых, полагаем L = 0.<p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Пример правильной и эффективной<p> программы на языке Паскаль:</p></td><td>Пример правильной и эффективной<p> программы на языке Бейсик:</p></td></tr><tr><td><div class=\"source_code lang_pascal\"><p>program c4_1;<p> </p><p>var<p class=\"left_margin\">R, T, N, L, LMax : Integer;<p>begin <p class=\"left_margin\">N:=0; <p class=\"left_margin\">L:=0; <p class=\"left_margin\">LMax:=0; <p class=\"left_margin\">T:=1001; <p>repeat<p class=\"left_margin\">ReadLn(R); <p>if R&lt;&gt;0 then N:=N+1; <p>if R&gt;T then L:=L+R-T <p>else begin<p>if L&gt;LMax then LMax:=L; <p class=\"left_margin\">L:=0; <p>end; <p class=\"left_margin\">T:=R; <p>until R=0;<p class=\"left_margin\">WriteLn('Получено ', N, ' чисел'); <p class=\"left_margin\">WriteLn('Наибольшая высота подъема ', LMax); <p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p class=\"left_margin\">DIM R, T, N, L, LMax AS INTEGER<p class=\"left_margin\">N = 0<p class=\"left_margin\">L = 0<p class=\"left_margin\">LMax = 0<p class=\"left_margin\">T = 1001;<p class=\"left_margin\">DO<p class=\"left_margin\">INPUT R<p class=\"left_margin\">IF R &lt;&gt; 0 THEN N = N + 1<p class=\"left_margin\">IF R &gt; T THEN <p class=\"left_margin\">L = L + R-T<p class=\"left_margin\">ELSE<p class=\"left_margin\">IF L &gt; LMax THEN LMax = L <p class=\"left_margin\">L = 0<p class=\"left_margin\">END IF<p class=\"left_margin\">T = R <p class=\"left_margin\">LOOP UNTIL R = 0 <p class=\"left_margin\">PRINT \"Получено \"; N; \" чисел\" <p class=\"left_margin\">PRINT \"Наибольшая высота подъема \"; Lmax </p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table></p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Пример правильной и эффективной<p> программы на языке Алгоритмическом языке:</p></td></tr><tr><td>алг C4_1 <p>нач<p>цел R, T, N, L, LMax<p class=\"left_margin\">N:=0<p class=\"left_margin\">L:=0<p class=\"left_margin\">LMax:=0<p class=\"left_margin\">T:=1001;<p>нц<p>ввод R<p>если R&lt;&gt;0 то N:=N+1 все<p>если R&gt;T то<p class=\"left_margin\">L:=L+R-T <p>иначе<p>если L&gt;LMax то LMax:=L все <p class=\"left_margin\">L:=0 <p>все T:=R <p>кц при R=0<p>вывод \"Получено \", N, \" чисел\", нс <p>вывод \"Наибольшая высота подъема \", LMax, нс <p>кон</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p></p></div>",
            "source": "",
            "task_id": "3628"
        },
        {
            "answer": "Решение.Вариант 1. Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале реализовано построение полного \"словаря\".Затем программа читает входные строки, не запоминая их в массиве. Если построен полный \"словарь\", прочитанная строка ищется в этом словаре как единое целое. Числовое значение введённой строки равно сумме значений составляющих слов. Если вся строка при поиске в полном \"словаре\" отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается. Паскальprogram c4;program c4;varw: array[1..99] of string;N: integer;s: integer;line: string;i, j: integer;begin{читаем обучающий блок}for i := 1 to 9 do readln(w[i]);for i := 11 to 19 do readln(w[i]);for i := 1 to 9 do readln(w[10*i]);{строим полный словарь}for i := 2 to 9 do beginfor j := 1 to 9 do beginw[10*i + j] := w[10*i]+ ' ' + w[j];end;end;{читаем и обрабатываем основной набор данных}readln(N);s:= 0 ;for i:=1 to N do beginreadln(line);j:=1;while (j<100) and (w[j]<>line) do j:=j+1;if j<100 then s:=s+j; end;writeln(s);end.  Вариант 2.Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале — хранение исходного обучающего блока. Если полный \"словарь\" отсутствует, строка разбивается на слова (в подходящей строке их может быть не более двух). Числовое значение введённой строки равно сумме значений составляющих слов. Если какое-то слово отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается. Паскальprogram c4;const nw=27; varwords: array[1..nw] of string;values: array[1..nw] of integer;{поиск слова в словаре, возврат числового значения}function word2value (w: string) : integer;vari: integer;begini:=1;while (i<=nw) and (words[i]<>w) do i:=i+1;if i<=nw then word2value:=values[i]else word2value:=0;end; varN: integer;s: integer;v1, v2: integer;line: string;i, j: integer;begin{читаем обучающий блок}for i := 1 to 9 do beginreadln(words[i] ) ;values[i] :=i ;end;for i := 10 to 18 do beginreadln(words[i]);values[i]:=i+1;end;for i := 19 to 27 do beginreadln(words[i]);values[i] :=10*(i-18) ;end;{читаем и обрабатываем основной набор данных}readln(N);s:= 0 ;for i:=1 to N do beginreadln(line);j:=pos(line, ' ') ;if j>0 then beginv1:= word2value(copy(line,1,j-1));v2:= word2value(copy(line,j+1,length(line)-j));if (v1>0) and (v2>0) then s:=s+v1+v2;endelse beginv1:= word2value(line);if v1>0 then s:=s+v1;end;end;writeln(s);end.  БейсикDIM w$(99)FOR i = 1 TO 9LINE INPUT w$(i) NEXT i FOR i = 11 TO 19LINE INPUT w$(i) NEXT i FOR i = 10 TO 90 STEP 10LINE INPUT w$(i)NEXT iFOR i = 20 TO 9 0FOR j = 1 TO 9w$(i + j) = w$(i) + \" \" + w$(j)NEXT j NEXT i INPUT N s = 0 FOR i = 1 TO NLINE INPUT line$j = 1WHILE j < 100 AND w$(j) <> line$ j = j + 1WENDIF j < 10 0 THEN s = s + j NEXT i PRINT s END Алгоритмический языкалг   c4 начлиттаб   слова[1:99]лит трокацел Nцел суммацел i, jнц для i от 1 до 9 ввод слова[i]кцнц для i от 11 до 19ввод слова[i]кцнц для i от 10 до 90 шаг 10ввод слова[i]кцнц для i от 20 до 90 шаг 10 нц для j от 1 до 9кцкцввод N сумма:= 0 нц для i от 1 до Nввод строкаj : =1нц пока j < 10 0 и слова [j] <>строка j:=j +1кцесли j <10 0 то сумма:=сумма+j все кц выводкон Перлfor $v (1..9, 11..19, 20, 30, 40, 50, 60, 70, 80, 90) {chomp ($w = <>) ;$value{$w} = $v; }$n = <>;$s = 0;while ($ n--) {chomp ($line = <>);$num = 0;$value{$w}}for $w (split / /,$line) { if ($value{$w}) {$num += $value{$w}} else {$num=0; last}}$s += $num; } print $s;",
            "parsed": "2019-04-29 21:13:58.101228",
            "question": "Вам необходимо написать программу распознавания чисел, записанных прописью. Сначала на вход программе подаётся обучающий блок, состоящий из 27 строк. Первые 9 строк содержат слова \"один\", \"два\", ...., \"десять\", следующие 9 строк — слова \"одиннадцать\", \"двенадцать\", ... \"девятнадцать\", следующие 9 строк — слова \"десять\", \"двадцать\", ..., \"девяносто\". Все слова записаны меленькими русскими буквами без лишних пробелов в начале и в конце строки.Затем на вход программе подаётся значение N — количество записей, которые необходимо обработать. Следующие N строк содержат записанные словами числа. Каждое число записано по-русски, маленькими буквами, без ошибок. Если число состоит из нескольких слов, между словами находится ровно один пробел, лишних пробелов в начале и в конце строк нет.Напишите эффективную программу, которая определит сумму тех входных чисел, которые находятся в интервале то 1 до 99.Размер памяти, которую использует Ваша программа, не должен зависеть от длины исходного списка.Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. Пример входных данных (обучающий блок показан в примере с сокращениями):одиндва...девяноста5двадцать восемьдва миллионачетырнадцатьсто двадцать тритысяча девятьсот восемьдесят четыреПример выходных данных для приведённого выше примера входных данных:42 ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942284\" width=\"100%\"><p class=\"left_margin\">Вам необходимо написать программу распознавания чисел, записанных прописью. Сначала на вход программе подаётся обучающий блок, состоящий из 27 строк. Первые 9 строк содержат слова \"один\", \"два\", ...., \"десять\", следующие 9 строк — слова \"одиннадцать\", \"двенадцать\", ... \"девятнадцать\", следующие 9 строк — слова \"десять\", \"двадцать\", ..., \"девяносто\". Все слова записаны меленькими русскими буквами без лишних пробелов в начале и в конце строки.<p class=\"left_margin\">Затем на вход программе подаётся значение N — количество записей, которые необходимо обработать. Следующие N строк содержат записанные словами числа. Каждое число записано по-русски, маленькими буквами, без ошибок. Если число состоит из нескольких слов, между словами находится ровно один пробел, лишних пробелов в начале и в конце строк нет.<p class=\"left_margin\">Напишите эффективную программу, которая определит сумму тех входных чисел, которые находятся в интервале то 1 до 99.<p class=\"left_margin\">Размер памяти, которую использует Ваша программа, не должен зависеть от длины исходного списка.<p class=\"left_margin\">Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи.<p> </p><p><i>Пример входных данных (обучающий блок показан в примере с сокращениями):</i><p>один<p>два<p>...<p>девяноста<p class=\"left_margin\">5<p>двадцать восемь<p>два миллиона<p>четырнадцать<p>сто двадцать три<p>тысяча девятьсот восемьдесят четыре<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">42 </p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Вариант 1. Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале реализовано построение полного \"словаря\".Затем программа читает входные строки, не запоминая их в массиве. Если построен полный \"словарь\", прочитанная строка ищется в этом словаре как единое целое. Числовое значение введённой строки равно сумме значений составляющих слов. Если вся строка при поиске в полном \"словаре\" отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается. Паскальprogram c4;program c4;varw: array[1..99] of string;N: integer;s: integer;line: string;i, j: integer;begin{читаем обучающий блок}for i := 1 to 9 do readln(w[i]);for i := 11 to 19 do readln(w[i]);for i := 1 to 9 do readln(w[10*i]);{строим полный словарь}for i := 2 to 9 do beginfor j := 1 to 9 do beginw[10*i + j] := w[10*i]+ ' ' + w[j];end;end;{читаем и обрабатываем основной набор данных}readln(N);s:= 0 ;for i:=1 to N do beginreadln(line);j:=1;while (j<100) and (w[j]<>line) do j:=j+1;if j<100 then s:=s+j; end;writeln(s);end.  Вариант 2.Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале — хранение исходного обучающего блока. Если полный \"словарь\" отсутствует, строка разбивается на слова (в подходящей строке их может быть не более двух). Числовое значение введённой строки равно сумме значений составляющих слов. Если какое-то слово отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается. Паскальprogram c4;const nw=27; varwords: array[1..nw] of string;values: array[1..nw] of integer;{поиск слова в словаре, возврат числового значения}function word2value (w: string) : integer;vari: integer;begini:=1;while (i<=nw) and (words[i]<>w) do i:=i+1;if i<=nw then word2value:=values[i]else word2value:=0;end; varN: integer;s: integer;v1, v2: integer;line: string;i, j: integer;begin{читаем обучающий блок}for i := 1 to 9 do beginreadln(words[i] ) ;values[i] :=i ;end;for i := 10 to 18 do beginreadln(words[i]);values[i]:=i+1;end;for i := 19 to 27 do beginreadln(words[i]);values[i] :=10*(i-18) ;end;{читаем и обрабатываем основной набор данных}readln(N);s:= 0 ;for i:=1 to N do beginreadln(line);j:=pos(line, ' ') ;if j>0 then beginv1:= word2value(copy(line,1,j-1));v2:= word2value(copy(line,j+1,length(line)-j));if (v1>0) and (v2>0) then s:=s+v1+v2;endelse beginv1:= word2value(line);if v1>0 then s:=s+v1;end;end;writeln(s);end.  БейсикDIM w$(99)FOR i = 1 TO 9LINE INPUT w$(i) NEXT i FOR i = 11 TO 19LINE INPUT w$(i) NEXT i FOR i = 10 TO 90 STEP 10LINE INPUT w$(i)NEXT iFOR i = 20 TO 9 0FOR j = 1 TO 9w$(i + j) = w$(i) + \" \" + w$(j)NEXT j NEXT i INPUT N s = 0 FOR i = 1 TO NLINE INPUT line$j = 1WHILE j < 100 AND w$(j) <> line$ j = j + 1WENDIF j < 10 0 THEN s = s + j NEXT i PRINT s END Алгоритмический языкалг   c4 начлиттаб   слова[1:99]лит трокацел Nцел суммацел i, jнц для i от 1 до 9 ввод слова[i]кцнц для i от 11 до 19ввод слова[i]кцнц для i от 10 до 90 шаг 10ввод слова[i]кцнц для i от 20 до 90 шаг 10 нц для j от 1 до 9кцкцввод N сумма:= 0 нц для i от 1 до Nввод строкаj : =1нц пока j < 10 0 и слова [j] <>строка j:=j +1кцесли j <10 0 то сумма:=сумма+j все кц выводкон Перлfor $v (1..9, 11..19, 20, 30, 40, 50, 60, 70, 80, 90) {chomp ($w = <>) ;$value{$w} = $v; }$n = <>;$s = 0;while ($ n--) {chomp ($line = <>);$num = 0;$value{$w}}for $w (split / /,$line) { if ($value{$w}) {$num += $value{$w}} else {$num=0; last}}$s += $num; } print $s;",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3632\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Вариант 1.<p> </p><p class=\"left_margin\">Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале реализовано построение полного \"словаря\".<p class=\"left_margin\">Затем программа читает входные строки, не запоминая их в массиве. Если построен полный \"словарь\", прочитанная строка ищется в этом словаре как единое целое. Числовое значение введённой строки равно сумме значений составляющих слов. Если вся строка при поиске в полном \"словаре\" отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается.<p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Паскаль</td></tr><tr><td>program c4;<p>program c4;<p>var<p>w: array[1..99] of string;<p class=\"left_margin\">N: integer;<p>s: integer;<p>line: string;<p>i, j: integer;<p>begin<p>{читаем обучающий блок}<p>for i := 1 to 9 do readln(w[i]);<p>for i := 11 to 19 do readln(w[i]);<p>for i := 1 to 9 do readln(w[10*i]);<p>{строим полный словарь}<p>for i := 2 to 9 do begin<p>for j := 1 to 9 do begin<p>w[10*i + j] := w[10*i]+ ' ' + w[j];<p>end;<p>end;<p>{читаем и обрабатываем основной набор данных}<p>readln(N);<p>s:= 0 ;<p>for i:=1 to N do begin<p>readln(line);<p>j:=1;<p>while (j&lt;100) and (w[j]&lt;&gt;line) do j:=j+1;<p>if j&lt;100 then s:=s+j; end;<p>writeln(s);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p> <p> </p><p class=\"left_margin\">Вариант 2.<p class=\"left_margin\">Программа читает обучающий блок и запоминает написание чисел и их значения. Допускается построение полного \"словаря\" всех чисел от 1 до 99 или хранение только исходного обучающего блока. В приведённом примере на Паскале — хранение исходного обучающего блока. Если полный \"словарь\" отсутствует, строка разбивается на слова (в подходящей строке их может быть не более двух). Числовое значение введённой строки равно сумме значений составляющих слов. Если какое-то слово отсутствует в обучающих данных, введённое число не попадает в интервал от 1 до 99 и не должно учитываться. Дополнительная проверка вхождения числа в заданный интервал не требуется, т. к. все числа, которые удаётся распознать с помощью приведённого обучающего блока, автоматически в него попадают, но за наличие такой дополнительной проверки в программе оценка снижается.<p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Паскаль</td></tr><tr><td>program c4;<p>const nw=27;<p> <p>var<p>words: array[1..nw] of string;<p>values: array[1..nw] of integer;<p>{поиск слова в словаре, возврат числового значения}<p>function word2value (w: string) : integer;<p>var<p>i: integer;<p>begin<p>i:=1;<p>while (i&lt;=nw) and (words[i]&lt;&gt;w) do i:=i+1;<p>if i&lt;=nw then word2value:=values[i]<p>else word2value:=0;<p>end;<p> <p>var<p class=\"left_margin\">N: integer;<p>s: integer;<p>v1, v2: integer;<p>line: string;<p>i, j: integer;<p>begin<p>{читаем обучающий блок}<p>for i := 1 to 9 do begin<p>readln(words[i] ) ;<p>values[i] :=i ;<p>end;<p>for i := 10 to 18 do begin<p>readln(words[i]);<p>values[i]:=i+1;<p>end;<p>for i := 19 to 27 do begin<p>readln(words[i]);<p>values[i] :=10*(i-18) ;<p>end;<p>{читаем и обрабатываем основной набор данных}<p>readln(N);<p>s:= 0 ;<p>for i:=1 to N do begin<p>readln(line);<p>j:=pos(line, ' ') ;<p>if j&gt;0 then begin<p>v1:= word2value(copy(line,1,j-1));<p>v2:= word2value(copy(line,j+1,length(line)-j));<p>if (v1&gt;0) and (v2&gt;0) then s:=s+v1+v2;<p>end<p>else begin<p>v1:= word2value(line);<p>if v1&gt;0 then s:=s+v1;<p>end;<p>end;<p>writeln(s);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p> <p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Бейсик</td></tr><tr><td>DIM w$(99)<p class=\"left_margin\">FOR i = 1 TO 9<p class=\"left_margin\">LINE INPUT w$(i) <p class=\"left_margin\">NEXT i <p class=\"left_margin\">FOR i = 11 TO 19<p class=\"left_margin\">LINE INPUT w$(i) <p class=\"left_margin\">NEXT i <p class=\"left_margin\">FOR i = 10 TO 90 STEP 10<p class=\"left_margin\">LINE INPUT w$(i)<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR i = 20 TO 9 0<p class=\"left_margin\">FOR j = 1 TO 9<p>w$(i + j) = w$(i) + \" \" + w$(j)<p class=\"left_margin\">NEXT j <p class=\"left_margin\">NEXT i <p class=\"left_margin\">INPUT N s = 0 FOR i = 1 TO N<p class=\"left_margin\">LINE INPUT line$<p>j = 1<p class=\"left_margin\">WHILE j &lt; 100 AND w$(j) &lt;&gt; line$ <p>j = j + 1<p class=\"left_margin\">WEND<p class=\"left_margin\">IF j &lt; 10 0 THEN s = s + j <p class=\"left_margin\">NEXT i <p class=\"left_margin\">PRINT s <p class=\"left_margin\">END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p><p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Алгоритмический язык</td></tr><tr><td>алг   c4 нач<p>литтаб   слова[1:99]<p>лит трока<p>цел N<p>цел сумма<p>цел i, j<p>нц для i от 1 до 9 <p>ввод слова[i]<p>кц<p>нц для i от 11 до 19<p>ввод слова[i]<p>кц<p>нц для i от 10 до 90 шаг 10<p>ввод слова[i]<p>кц<p>нц для i от 20 до 90 шаг 10 <p>нц для j от 1 до 9<p>кц<p>кц<p>ввод N <p>сумма:= 0 <p>нц для i от 1 до N<p>ввод строка<p>j : =1<p>нц пока j &lt; 10 0 и слова [j] &lt;&gt;строка <p>j:=j +1<p>кц<p>если j &lt;10 0 то сумма:=сумма+j все <p>кц вывод<p>кон</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p><p> </p><p align=\"center\"><table border=\"1\" rules=\"all\"><tr align=\"center\" p=\"\"><td>Перл</td></tr><tr><td>for $v (1..9, 11..19, 20, 30, 40, 50, 60, 70, 80, 90) {<p>chomp ($w = &lt;&gt;) ;<p>$value{$w} = $v; }<p>$n = &lt;&gt;;<p>$s = 0;<p>while ($ n--) {<p>chomp ($line = &lt;&gt;);<p>$num = 0;<p>$value{$w}}<p>for $w (split / /,$line) { <p>if ($value{$w}) {$num += $value{$w}} <p>else {$num=0; last}<p>}<p>$s += $num; <p>} <p>print $s;</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></td></tr></table></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3632"
        },
        {
            "answer": "Решение.Программа верно читает входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 99 целых чисел согласно номерам школ, количество участников олимпиады из каждой школы. Затем подсчитывается количество школ, приславших хотя бы одного участника, и вычисляется среднее количество участников от одной школы. var nc:array[1..99] of integer; р:1..99; с:char;i, k, N: integer; begin readln(N) ;for i:=1 to 99 do nc[i]:=0;for i:=1 to N dobeginrepeatread(с)until c=' '; {считана фамилия}repeatread(c)until c=' '; repeatread(c)until c=' '; {считаны инициалы} readln(p); nc[p]:=nc[p]+1 ; end; k: = 0 ;for i:=1 to 99 do if nc[i]>0 then k:=k+1;writeln('Среднее количество участников из одной школы', N/k) end.",
            "parsed": "2019-04-29 21:14:12.167066",
            "question": "На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат:  <Фамилия> <Инициалы> <номер школы>, где <Фамилия> — строка, состоящая не более чем из 20 символов, <Инициалы> — строка, состоящая из 4-х символов (буква, точка, буква, точка), <номер школы> — не более чем двузначный номер. <Фамилия> и <Инициалы>, а также <Инициалы> и <номер школы> разделены одним пробелом. Пример входной строки: Иванов П.С. 57Требуется написать как можно более эффективную программу на Паскале, которая определяет среднее количество участников олимпиады из одной школы. Следует учитывать, что N > 1000.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942285\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о номерах школ учащихся, участвовавших в олимпиаде. В первой строке сообщается количество учащихся N, каждая из следующих N строк имеет формат: <p> </p><p>&lt;Фамилия&gt; &lt;Инициалы&gt; &lt;номер школы&gt;,<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 символов, <p>&lt;Инициалы&gt; — строка, состоящая из 4-х символов (буква, точка, буква, точка), <p>&lt;номер школы&gt; — не более чем двузначный номер. <p>&lt;Фамилия&gt; и &lt;Инициалы&gt;, а также &lt;Инициалы&gt; и &lt;номер школы&gt; разделены одним пробелом. <p class=\"left_margin\">Пример входной строки: <p class=\"left_margin\">Иванов П.С. 57<p class=\"left_margin\">Требуется написать как можно более эффективную программу на Паскале, которая определяет среднее количество участников олимпиады из одной школы. Следует учитывать, что N &gt; 1000.<p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа верно читает входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 99 целых чисел согласно номерам школ, количество участников олимпиады из каждой школы. Затем подсчитывается количество школ, приславших хотя бы одного участника, и вычисляется среднее количество участников от одной школы. var nc:array[1..99] of integer; р:1..99; с:char;i, k, N: integer; begin readln(N) ;for i:=1 to 99 do nc[i]:=0;for i:=1 to N dobeginrepeatread(с)until c=' '; {считана фамилия}repeatread(c)until c=' '; repeatread(c)until c=' '; {считаны инициалы} readln(p); nc[p]:=nc[p]+1 ; end; k: = 0 ;for i:=1 to 99 do if nc[i]>0 then k:=k+1;writeln('Среднее количество участников из одной школы', N/k) end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3633\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа верно читает входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 99 целых чисел согласно номерам школ, количество участников олимпиады из каждой школы. Затем подсчитывается количество школ, приславших хотя бы одного участника, и вычисляется среднее количество участников от одной школы.<p> </p><p>var nc:array[1..99] of integer; <p>р:1..99; <p>с:char;<p>i, k, N: integer; <p>begin <p>readln(N) ;<p>for i:=1 to 99 do nc[i]:=0;<p>for i:=1 to N do<p>begin<p>repeat<p>read(с)<p>until c=' '; {считана фамилия}<p>repeat<p>read(c)<p>until c=' '; <p>repeat<p>read(c)<p>until c=' '; {считаны инициалы} <p>readln(p); <p>nc[p]:=nc[p]+1 ; <p>end; <p>k: = 0 ;<p>for i:=1 to 99 do <p>if nc[i]&gt;0 then k:=k+1;<p>writeln('Среднее количество участников из одной школы', N/k) <p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3633"
        },
        {
            "answer": "Решение.Программа считывает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев. Затем с использованием этого массива ищется максимальная среднемесячная температура. За дополнительный просмотр среднемесячных температур (их можно как запомнить в массиве, так и вычислить заново) распечатывается информация об искомых месяцах. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, месяц с максимальной температурой единственен). Пример правильной и эффективной программы на языке Паскаль: const d:array[1..12] of integer =(31,28,31,30,31,30,31,31,30,31,30,31); var m:array[1..12] of real; max, t:real; i,j:integer; cl,c2:char; begin for j:=1 to 12 do m[j ] : =0;for i:=l to 365 do beginreadln(cl,cl,cl,cl,c2,t); j:= (ord(cl)-ord('0') ) *10 + ord(c2)-ord('01); m [ j] :=m[j]+t end;max:=m[1]/d[1]; for j:=2 to 12 do if m[j]/d[j] > max then max:=m[j]/d[j]; for j:=1 to 12 do if abs(m[j]/d[j]-max) < 0.0001 then writeln(j,1 ',m[j]/d[jj:0:1) end. Пример правильной программы на языке Бейсик: DATA 31,28,31,30,31,30,31,31,30,31,30,31 DIM i, j, d (12) AS INTEGER DIM m(12)DIM dat AS STRING * 5 FOR i = 1 TO 12 m (i) = 0 READ d(i)NEXT iFOR i = 1 TO 3 65INPUT dat, tj = (ASC(MID$(dat, 4, 1)) - ASC(\"0\")> * 10 + ASC (MID5 (dat, 5, 1)) -ASCCO\") m(j) = m (j ) + t NEXT imax = m(l) / d(1) FOR j = 2 TO 12IF m(j ) / d(j) > max THEN max = m(j) / d(j)NEXT jFOR j = 1 TO 12 IF ABS(m(j) / d(j) - max) < .0001 THEN PRINT j; \" \" ;PRINT USING \"##.#\"; m(j) / d(j) ENDIF NEXT j END",
            "parsed": "2019-04-29 21:13:58.739330",
            "question": "На вход программе подаются 365 строк, которые содержат информацию о среднесуточной темпе-ратуре всех дней 2007 года. Формат каждой из строк следующий: сначала записана дата в виде dd.mm (на запись номера дня и номера месяца в числовом формате отводится строго два символа, день от месяца отделен точкой), затем через пробел (для Бейсика — через запятую) записано значение температуры — число со знаком плюс или минус, с точностью до 1 цифры после десятичной точки. Данная информация отсортирована по значению температуры, т. е. хронологический порядок нарушен. Требуется написать эффективную программу на языке Паскаль или Бейсик, которая будет выводить на экран информацию о месяцах с максимальной среднеме¬сячной температурой. Найденные максимальные значения следует выводить в отдельной строке для каждого месяца в виде: номер месяца, значение среднемесячной температуры, округленное до одной цифры после десятичной точки. ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942283\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются 365 строк, которые содержат информацию о среднесуточной темпе-ратуре всех дней 2007 года. Формат каждой из строк следующий: сначала записана дата в виде dd.mm (на запись номера дня и номера месяца в числовом формате отводится строго два символа, день от месяца отделен точкой), затем через пробел (для Бейсика — через запятую) записано значение температуры — число со знаком плюс или минус, с точностью до 1 цифры после десятичной точки. Данная информация отсортирована по значению температуры, т. е. хронологический порядок нарушен. Требуется написать эффективную программу на языке Паскаль или Бейсик, которая будет выводить на экран информацию о месяцах с максимальной среднеме¬сячной температурой. Найденные максимальные значения следует выводить в отдельной строке для каждого месяца в виде: номер месяца, значение среднемесячной температуры, округленное до одной цифры после десятичной точки. </p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа считывает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев. Затем с использованием этого массива ищется максимальная среднемесячная температура. За дополнительный просмотр среднемесячных температур (их можно как запомнить в массиве, так и вычислить заново) распечатывается информация об искомых месяцах. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, месяц с максимальной температурой единственен). Пример правильной и эффективной программы на языке Паскаль: const d:array[1..12] of integer =(31,28,31,30,31,30,31,31,30,31,30,31); var m:array[1..12] of real; max, t:real; i,j:integer; cl,c2:char; begin for j:=1 to 12 do m[j ] : =0;for i:=l to 365 do beginreadln(cl,cl,cl,cl,c2,t); j:= (ord(cl)-ord('0') ) *10 + ord(c2)-ord('01); m [ j] :=m[j]+t end;max:=m[1]/d[1]; for j:=2 to 12 do if m[j]/d[j] > max then max:=m[j]/d[j]; for j:=1 to 12 do if abs(m[j]/d[j]-max) < 0.0001 then writeln(j,1 ',m[j]/d[jj:0:1) end. Пример правильной программы на языке Бейсик: DATA 31,28,31,30,31,30,31,31,30,31,30,31 DIM i, j, d (12) AS INTEGER DIM m(12)DIM dat AS STRING * 5 FOR i = 1 TO 12 m (i) = 0 READ d(i)NEXT iFOR i = 1 TO 3 65INPUT dat, tj = (ASC(MID$(dat, 4, 1)) - ASC(\"0\")> * 10 + ASC (MID5 (dat, 5, 1)) -ASCCO\") m(j) = m (j ) + t NEXT imax = m(l) / d(1) FOR j = 2 TO 12IF m(j ) / d(j) > max THEN max = m(j) / d(j)NEXT jFOR j = 1 TO 12 IF ABS(m(j) / d(j) - max) < .0001 THEN PRINT j; \" \" ;PRINT USING \"##.#\"; m(j) / d(j) ENDIF NEXT j END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3639\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа считывает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев. Затем с использованием этого массива ищется максимальная среднемесячная температура. За дополнительный просмотр среднемесячных температур (их можно как запомнить в массиве, так и вычислить заново) распечатывается информация об искомых месяцах. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, месяц с максимальной температурой единственен).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p> </p><p>const d:array[1..12] of integer =<p class=\"left_margin\">(31,28,31,30,31,30,31,31,30,31,30,31); <p>var m:array[1..12] of real; <p>max, t:real; <p>i,j:integer; <p>cl,c2:char; <p>begin <p>for j:=1 to 12 do <p>m[j ] : =0;<p>for i:=l to 365 do <p>begin<p>readln(cl,cl,cl,cl,c2,t); <p>j:= (ord(cl)-ord('0') ) *10 + <p>ord(c2)-ord('01); <p>m [ j] :=m[j]+t <p>end;<p>max:=m[1]/d[1]; <p>for j:=2 to 12 do <p>if m[j]/d[j] &gt; max then <p>max:=m[j]/d[j]; <p>for j:=1 to 12 do <p>if abs(m[j]/d[j]-max) &lt; 0.0001 <p>then writeln(j,1 ',m[j]/d[jj:0:1) <p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p> </p><p class=\"left_margin\">DATA 31,28,31,30,31,30,31,31,30,31,30,31 <p class=\"left_margin\">DIM i, j, d (12) AS INTEGER <p class=\"left_margin\">DIM m(12)<p class=\"left_margin\">DIM dat AS STRING * 5 <p class=\"left_margin\">FOR i = 1 TO 12 <p>m (i) = 0 <p class=\"left_margin\">READ d(i)<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR i = 1 TO 3 65<p class=\"left_margin\">INPUT dat, t<p>j = (ASC(MID$(dat, 4, 1)) - ASC(\"0\")&gt; * 10 + <p class=\"left_margin\">ASC (MID5 (dat, 5, 1)) -ASCCO\") <p>m(j) = m (j ) + t <p class=\"left_margin\">NEXT i<p>max = m(l) / d(1) <p class=\"left_margin\">FOR j = 2 TO 12<p class=\"left_margin\">IF m(j ) / d(j) &gt; max THEN max = m(j) / d(j)<p class=\"left_margin\">NEXT j<p class=\"left_margin\">FOR j = 1 TO 12 IF ABS(m(j) / d(j) - max) &lt; .0001 THEN <p class=\"left_margin\">PRINT j; \" \" ;<p class=\"left_margin\">PRINT USING \"##.#\"; m(j) / d(j) <p class=\"left_margin\">ENDIF <p class=\"left_margin\">NEXT j <p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3639"
        },
        {
            "answer": "Решение.Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения. Пример правильной и эффективной программы на языке Паскаль:var f:boolean; i, k, min: integer; c,cnew:char; s : string;begin s : = \" ;min:=250; k:=0; f:=false; repeat read(c); s:=s+c;if f then {слово началось} if с in ['a' . . 'z', 'A' . . ' Z ' ]then k:=k+l else beginif k < min then min:=k;f:=false endelse {f=false} if с in [ 'a'. . ' z ' , 'A'.. ' Z']then begin f:=true; k:=l end until c='. ';for i:=l to length(s) do begincnew:=chr(ord(s[i])+min); case s[i] of'a'..'z':if cnew>'z' then write(chr(ord(cnew)-26)) else write(cnew);'A'..'Z':if cnew>'Z' then write(chr(ord(cnew)-26)) else write(cnew); else write(s[i]) end; end; readln end. Пример правильной программы на языке Бейсик:DIM i, j, min, к, f, a (26) AS INTEGER DIM s AS STRING INPUT s i = 1 k = 0 min = 250 f = 0WHILE NOT (MID$(s, i, 1) = \".\")c$ = MID$(s, i, 1) IF f = 1 THENIF (c$ >= \"A\") AND (c$ <= \"Z\") OR (c$ >= \"a\") AND (c$ <= \"z\") THEN k = k + 1 ELSE IF k < min THEN min = k f = 0 ENDIFELSF.IF (с $ >= \"A\") AND (c$ <= \"Z\") OR (cS >= \"a\") AND (с $ <= \"z\") THEN f = 1 : к = i ENDIF ENDIF i = i + 1 WENDIF к < min THEN min = k FOR j = 1 TO i cnew$ = CHR$(ASC(MID$(s, j, 1)) + min) IF (MID$(s, j, 1) >= \"a\") AND (MID$(s, j, 1) <= \"z\") THEN IF cnew$ > \"z\" THEN PRINT (CHRS(ASC(cnew$) - 26)); ELSE PRINT cnew$; ENDIF ELSEIF (MID$ (s, j, 1) >= \"A\") AND (MID$(s, j, 1) <= \"Z\") THEN IF cnew$ > \"Z\" THEN PRINT (CHRS(ASC(cnew$) - 26)); ELSE PRINT cnew$; ENDIFELSE PRINT MID$(s, j, 1); ENDIF ENDIF NEXT j END",
            "parsed": "2019-04-29 21:13:48.896077",
            "question": "На вход программе подается текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано юным волшебником следующим образом. Сначала волшебник определил количество букв в самом коротком слове, обозначив полученное число К (словом называется непрерывная последовательность латинских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую латинскую букву в заклинании на букву, стоящую в алфавите на К букв ранее (алфавит считается циклическим, то есть перед буквой А стоит буква Z), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать программу на языке Паскаль или Бейсик, которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким:Zb Ra Са Dab Ra,то результат расшифровки должен быть следующим:Bd Тс Ее Fed Тс.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942278\" width=\"100%\"><p class=\"left_margin\">На вход программе подается текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано юным волшебником следующим образом. Сначала волшебник определил количество букв в самом коротком слове, обозначив полученное число К (словом называется непрерывная последовательность латинских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую латинскую букву в заклинании на букву, стоящую в алфавите на <i>К</i> букв ранее (алфавит считается циклическим, то есть перед буквой <i>А</i> стоит буква <i>Z</i>), оставив другие символы неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать программу на языке Паскаль или Бейсик, которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким:<p class=\"left_margin\">Zb Ra Са Dab Ra,<p>то результат расшифровки должен быть следующим:<p class=\"left_margin\">Bd Тс Ее Fed Тс.</p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения. Пример правильной и эффективной программы на языке Паскаль:var f:boolean; i, k, min: integer; c,cnew:char; s : string;begin s : = \" ;min:=250; k:=0; f:=false; repeat read(c); s:=s+c;if f then {слово началось} if с in ['a' . . 'z', 'A' . . ' Z ' ]then k:=k+l else beginif k < min then min:=k;f:=false endelse {f=false} if с in [ 'a'. . ' z ' , 'A'.. ' Z']then begin f:=true; k:=l end until c='. ';for i:=l to length(s) do begincnew:=chr(ord(s[i])+min); case s[i] of'a'..'z':if cnew>'z' then write(chr(ord(cnew)-26)) else write(cnew);'A'..'Z':if cnew>'Z' then write(chr(ord(cnew)-26)) else write(cnew); else write(s[i]) end; end; readln end. Пример правильной программы на языке Бейсик:DIM i, j, min, к, f, a (26) AS INTEGER DIM s AS STRING INPUT s i = 1 k = 0 min = 250 f = 0WHILE NOT (MID$(s, i, 1) = \".\")c$ = MID$(s, i, 1) IF f = 1 THENIF (c$ >= \"A\") AND (c$ <= \"Z\") OR (c$ >= \"a\") AND (c$ <= \"z\") THEN k = k + 1 ELSE IF k < min THEN min = k f = 0 ENDIFELSF.IF (с $ >= \"A\") AND (c$ <= \"Z\") OR (cS >= \"a\") AND (с $ <= \"z\") THEN f = 1 : к = i ENDIF ENDIF i = i + 1 WENDIF к < min THEN min = k FOR j = 1 TO i cnew$ = CHR$(ASC(MID$(s, j, 1)) + min) IF (MID$(s, j, 1) >= \"a\") AND (MID$(s, j, 1) <= \"z\") THEN IF cnew$ > \"z\" THEN PRINT (CHRS(ASC(cnew$) - 26)); ELSE PRINT cnew$; ENDIF ELSEIF (MID$ (s, j, 1) >= \"A\") AND (MID$(s, j, 1) <= \"Z\") THEN IF cnew$ > \"Z\" THEN PRINT (CHRS(ASC(cnew$) - 26)); ELSE PRINT cnew$; ENDIFELSE PRINT MID$(s, j, 1); ENDIF ENDIF NEXT j END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3642\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p>var f:boolean; <p>i, k, min: integer; <p>c,cnew:char; <p>s : string;<p>begin <p>s : = \" ;<p>min:=250; k:=0; <p>f:=false; <p>repeat <p>read(c); <p>s:=s+c;<p>if f then {слово началось} <p>if с in ['a' . . 'z', 'A' . . ' Z ' ]<p>then k:=k+l <p>else begin<p>if k &lt; min then min:=k;<p>f:=false end<p>else {f=false} <p>if с in [ 'a'. . ' z ' , 'A'.. ' Z']<p>then begin f:=true; k:=l end <p>until c='. ';<p>for i:=l to length(s) do <p>begin<p>cnew:=chr(ord(s[i])+min); <p>case s[i] of<p>'a'..'z':if cnew&gt;'z' then write(chr(ord(cnew)-26)) <p>else write(cnew);<p>'A'..'Z':if cnew&gt;'Z' then write(chr(ord(cnew)-26)) <p>else write(cnew); <p>else write(s[i]) <p>end; <p>end; <p>readln <p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p class=\"left_margin\">DIM i, j, min, к, f, a (26) AS INTEGER <p class=\"left_margin\">DIM s AS STRING <p class=\"left_margin\">INPUT s <p>i = 1 <p>k = 0 <p>min = 250 <p>f = 0<p class=\"left_margin\">WHILE NOT (MID$(s, i, 1) = \".\")<p>c$ = MID$(s, i, 1) <p class=\"left_margin\">IF f = 1 THEN<p class=\"left_margin\">IF (c$ &gt;= \"A\") AND (c$ &lt;= \"Z\") OR <p class=\"left_margin\">(c$ &gt;= \"a\") AND (c$ &lt;= \"z\") THEN <p>k = k + 1 <p class=\"left_margin\">ELSE IF k &lt; min THEN min = k <p>f = 0 <p class=\"left_margin\">ENDIF<p class=\"left_margin\">ELSF.<p class=\"left_margin\">IF (с $ &gt;= \"A\") AND (c$ &lt;= \"Z\") OR <p class=\"left_margin\">(cS &gt;= \"a\") AND (с $ &lt;= \"z\") THEN <p>f = 1 : к = i <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF i = i + 1 <p class=\"left_margin\">WEND<p class=\"left_margin\">IF к &lt; min THEN min = k <p class=\"left_margin\">FOR j = 1 TO i <p>cnew$ = CHR$(ASC(MID$(s, j, 1)) + min) IF (MID$(s, j, 1) &gt;= \"a\") AND (MID$(s, j, 1) <p>&lt;= \"z\") THEN <p class=\"left_margin\">IF cnew$ &gt; \"z\" THEN <p class=\"left_margin\">PRINT (CHRS(ASC(cnew$) - 26)); <p class=\"left_margin\">ELSE PRINT cnew$; <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF (MID$ (s, j, 1) &gt;= \"A\") AND (MID$(s, j, 1) <p>&lt;= \"Z\") THEN <p class=\"left_margin\">IF cnew$ &gt; \"Z\" THEN <p class=\"left_margin\">PRINT (CHRS(ASC(cnew$) - 26)); <p class=\"left_margin\">ELSE PRINT cnew$; <p class=\"left_margin\">ENDIF<p class=\"left_margin\">ELSE <p class=\"left_margin\">PRINT MID$(s, j, 1); <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p class=\"left_margin\">NEXT j <p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3642"
        },
        {
            "answer": "Решение.Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строчных английских букв и без циклического сдвига). Пример правильной и эффективной программы на языке Паскаль:var f:boolean; i, k, min: integer; c,cnew:char; s:string; begin s : = \" ;min:=250; k:=0; f:=false; repeat read(c); s:=s+c;if f then {слово началось} if с in ['a'..'z','A'..'Z']then k:=k+l else beginif kcmin then min:=k;f:=falseendelse {f=false}if с in [ 'a' ..'z', 'A'..'Z']then begin f:=true; k:=l end until c='. ' ;for i:=l to length(s) do begincnew: = chr (ord (s [i] ) -min) ; case s[i] of' a'..'z1:i f cnew<1 a 1 then write(chr(ord(cnew)+2 6)) else write(cnew); 1A'..' Z 1:if cnewc'A' then write(chr(ord(cnew)+26)) else write(cnew); else write(s[i]) end; end; readln end. Пример правильной программы на языке Бейсик: DIM i, j, min, к, f, a (26) AS. INTEGER DIM s AS STRING INPUT s i = 1 k = 0 min = 250 f = 0WHILE NOT (MID$(s, i, 1) = \".\") c$ = MID$ (s, i, 1) IF f = 1 THENIF (c$ >= \"A\") AND (с $ <= \"Z\") OR (C$ >= \"a\") AND (c$ <= \"z\") THEN k = k + 1ELSE IF k < min THEN min = k f = 0 ENDIF ELSEIF (с $ >= \"A\") AND (c$ <= \"Z\") OR (c$ >= \"a\") AND (c$ <= \"z\") THEN f = 1: k = 1 ENDIF ENDIF i = i + I WENDIF к < min THEN min = k FOR j = 1 TO i cnew$ = CHR$(ASC(MID$(s, j, 1)) - min) IF (MID$(s, j, 1) >= \"a\") AND (MID$(s, j, 1) <= \"z\") THEN IF cnew$ < \"a\" THENPRINT (CHR$(ASC(cnew$) + 26));ELSE PRINT cnew$;ENDIFELSEIF (MIDS (s, j, 1) >= \"A\") AND (MID$ (s, j, 1) <= \"Z\") THEN IF cnew$ < \"A\" THEN PRINT (CHR$(ASC(cnew$) + 26)); ELSE PRINT cnew$; ENDIFELSE PRINT MID$(s, j, 1); ENDIF ENDIF NEXT jEND",
            "parsed": "2019-04-29 21:13:49.751688",
            "question": "На вход программе подается текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано юным волшебником следующим образом. Сначала волшебник определил количество букв в самом коротком слове, обозначив полученное число К (словом называется непрерывная последовательность латинских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую латинскую букву в заклинании на следующую за ней К-ю по счету в алфавите (алфавит считается циклическим, то есть за буквой Z следует буква А), оставив другие символы Неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран текст расшифрованного заклинания. Например, если зашифрованный текст был таким: Bd Тс Ее Fed Тс,то результат расшифровки должен быть следующим:Zb Ra Сc Dcb Ra.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942273\" width=\"100%\"><p class=\"left_margin\">На вход программе подается текст заклинания, состоящего не более чем из 200 символов, заканчивающийся точкой (символ «точка» во входных данных единственный). Оно было зашифровано юным волшебником следующим образом. Сначала волшебник определил количество букв в самом коротком слове, обозначив полученное число <i>К</i> (словом называется непрерывная последовательность латинских букв, слова друг от друга отделяются любыми другими символами, длина слова не превышает 20 символов). Затем он заменил каждую латинскую букву в заклинании на следующую за ней <i>К</i>-ю по счету в алфавите (алфавит считается циклическим, то есть за буквой <i>Z</i> следует буква <i>А</i>), оставив другие символы Неизменными. Строчные буквы при этом остались строчными, а прописные — прописными. Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет выводить на экран текст расшифрованного заклинания. <p class=\"left_margin\">Например, если зашифрованный текст был таким: <p class=\"left_margin\">Bd Тс Ее Fed Тс,<p>то результат расшифровки должен быть следующим:<p class=\"left_margin\">Zb Ra Сc Dcb Ra.</p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строчных английских букв и без циклического сдвига). Пример правильной и эффективной программы на языке Паскаль:var f:boolean; i, k, min: integer; c,cnew:char; s:string; begin s : = \" ;min:=250; k:=0; f:=false; repeat read(c); s:=s+c;if f then {слово началось} if с in ['a'..'z','A'..'Z']then k:=k+l else beginif kcmin then min:=k;f:=falseendelse {f=false}if с in [ 'a' ..'z', 'A'..'Z']then begin f:=true; k:=l end until c='. ' ;for i:=l to length(s) do begincnew: = chr (ord (s [i] ) -min) ; case s[i] of' a'..'z1:i f cnew<1 a 1 then write(chr(ord(cnew)+2 6)) else write(cnew); 1A'..' Z 1:if cnewc'A' then write(chr(ord(cnew)+26)) else write(cnew); else write(s[i]) end; end; readln end. Пример правильной программы на языке Бейсик: DIM i, j, min, к, f, a (26) AS. INTEGER DIM s AS STRING INPUT s i = 1 k = 0 min = 250 f = 0WHILE NOT (MID$(s, i, 1) = \".\") c$ = MID$ (s, i, 1) IF f = 1 THENIF (c$ >= \"A\") AND (с $ <= \"Z\") OR (C$ >= \"a\") AND (c$ <= \"z\") THEN k = k + 1ELSE IF k < min THEN min = k f = 0 ENDIF ELSEIF (с $ >= \"A\") AND (c$ <= \"Z\") OR (c$ >= \"a\") AND (c$ <= \"z\") THEN f = 1: k = 1 ENDIF ENDIF i = i + I WENDIF к < min THEN min = k FOR j = 1 TO i cnew$ = CHR$(ASC(MID$(s, j, 1)) - min) IF (MID$(s, j, 1) >= \"a\") AND (MID$(s, j, 1) <= \"z\") THEN IF cnew$ < \"a\" THENPRINT (CHR$(ASC(cnew$) + 26));ELSE PRINT cnew$;ENDIFELSEIF (MIDS (s, j, 1) >= \"A\") AND (MID$ (s, j, 1) <= \"Z\") THEN IF cnew$ < \"A\" THEN PRINT (CHR$(ASC(cnew$) + 26)); ELSE PRINT cnew$; ENDIFELSE PRINT MID$(s, j, 1); ENDIF ENDIF NEXT jEND",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3645\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает входные данные, сразу подсчитывая минимальную длину встречающихся слов. За второй проход исходных данных производится замена букв латинского алфавита и печать расшифрованного сообщения. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строчных английских букв и без циклического сдвига).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p>var f:boolean; <p>i, k, min: integer; <p>c,cnew:char; <p>s:string; <p>begin <p>s : = \" ;<p>min:=250; <p>k:=0; <p>f:=false; <p>repeat read(c); <p>s:=s+c;<p>if f then {слово началось} <p>if с in ['a'..'z','A'..'Z']<p>then k:=k+l <p>else begin<p>if kcmin then <p>min:=k;<p>f:=false<p>end<p>else {f=false}<p>if с in [ 'a' ..'z', 'A'..'Z']<p>then begin f:=true; k:=l end <p>until c='. ' ;<p>for i:=l to length(s) do <p>begin<p>cnew: = chr (ord (s [i] ) -min) ; <p>case s[i] of<p>' a'..'z1:i f cnew&lt;1 a 1 then <p>write(chr(ord(cnew)+2 6)) <p>else write(cnew); <p class=\"left_margin\">1A'..' Z 1:if cnewc'A' then <p>write(chr(ord(cnew)+26)) <p>else write(cnew); <p>else write(s[i]) <p>end; <p>end; <p>readln end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p> </p><p class=\"left_margin\">DIM i, j, min, к, f, a (26) AS. INTEGER <p class=\"left_margin\">DIM s AS STRING <p class=\"left_margin\">INPUT s <p>i = 1 <p>k = 0 <p>min = 250 <p>f = 0<p class=\"left_margin\">WHILE NOT (MID$(s, i, 1) = \".\") <p>c$ = MID$ (s, i, 1) <p class=\"left_margin\">IF f = 1 THEN<p class=\"left_margin\">IF (c$ &gt;= \"A\") AND (с $ &lt;= \"Z\") OR <p class=\"left_margin\">(C$ &gt;= \"a\") AND (c$ &lt;= \"z\") THEN <p>k = k + 1<p class=\"left_margin\">ELSE IF k &lt; min THEN min = k <p>f = 0 <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF (с $ &gt;= \"A\") AND (c$ &lt;= \"Z\") OR <p class=\"left_margin\">(c$ &gt;= \"a\") AND (c$ &lt;= \"z\") THEN <p>f = 1: k = 1 <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p>i = i + I <p class=\"left_margin\">WEND<p class=\"left_margin\">IF к &lt; min THEN min = k <p class=\"left_margin\">FOR j = 1 TO i <p>cnew$ = CHR$(ASC(MID$(s, j, 1)) - min) <p class=\"left_margin\">IF (MID$(s, j, 1) &gt;= \"a\") AND (MID$(s, j, 1) <p>&lt;= \"z\") THEN <p class=\"left_margin\">IF cnew$ &lt; \"a\" THEN<p class=\"left_margin\">PRINT (CHR$(ASC(cnew$) + 26));<p class=\"left_margin\">ELSE PRINT cnew$;<p class=\"left_margin\">ENDIF<p class=\"left_margin\">ELSE<p class=\"left_margin\">IF (MIDS (s, j, 1) &gt;= \"A\") AND (MID$ (s, j, 1) <p>&lt;= \"Z\") THEN <p class=\"left_margin\">IF cnew$ &lt; \"A\" THEN <p class=\"left_margin\">PRINT (CHR$(ASC(cnew$) + 26)); <p class=\"left_margin\">ELSE PRINT cnew$; <p class=\"left_margin\">ENDIF<p class=\"left_margin\">ELSE PRINT MID$(s, j, 1); <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p class=\"left_margin\">NEXT j<p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3645"
        },
        {
            "answer": "Решение.Программа должна верно читать входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 12 целых чисел, количество учащихся в каждой из параллелей. Затем с использованием этого массива ищется параллель с максимальным числом учеников. За дополнительный просмотр этого массива распечатывается информация об искомых параллелях. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, параллель с максимальным количеством учеников единственна). Пример правильной и эффективной программы на языке Паскаль: var рс:array[1..12] of integer; р : 1. .12;class:string[3]; с:char;max, i, N:integer; begin readln(N) ; for i:=1 to 12 do pc[i]:=0; for i:=l to N do begin repeat read(c)until c=' '; {считана фамилия}repeatread(c)until c=' '; {считано имя} readln(class);{определяем номер параллели} if length(class)=2 then p:=ord(class[1])-ord(10') else p:=(ord(class[1])-ord('0'))*10+ ord(class[2])-ord('0'); pc[p]:=pc[p]+1;{учитываем ученика этой параллели} end; max:=0;for i:=1 to 12 do if pc[i]>max then max:=pc[i];writeln('Максимум учеников в параллели:',max); for i:=1 to 12 do if pc[i]=max then write(i,' '); readln end. Пример правильной программы на языке Бейсик: DIM i, j, р, n, max, pc(12) AS INTEGER DIM m(12) DIM s AS STRING FOR i = 1 TO 12 pc(i) = 0NEXT i INPUT nFOR j = 1 TO n LINE INPUT s c$ = MI D$ (s, 1, 1) i = 1WHILE NOT (с $ = \" \") i = i - 1c$ = MID$ (s, i, 1) WEND i = i + 1с$ = MID$(s, i, 1) WHILE NOT (с $ = \" \") i = i + 1c$ = MID$(s, i, 1) WENDs = MID$ (s, i + 1, 3)IF MID$(s, 2, 1) >= \"0\" AND MID$(s, 2, 1) < = \"2\" THENp = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 10 + ASC(MID$(s, 2, 1)) - ASC(\"0\") ELSEp = ASC(MID$(s, 1, 1)) - ASC(\"0\") ENDIFpc(p) = pc(p) + 1 NEXT j max = 0FOR i = 1 TO 12IF pc (i) > max THEN max = pc(i) NEXT iPRINT \"Max = \"; max FOR i = 1 TO 12IF pc(i) = max THEN PRINT i; \" \"; NEXT i END",
            "parsed": "2019-04-29 21:14:18.297457",
            "question": "На вход программе подаются сведения об учениках некоторой средней школы. В первой строке сообщается количество учеников N, каждая из следующих N строк имеет следующий формат:  <Фамилия> <Имя> <класс>, где <Фамилия> — строка, состоящая не более чем из 20 символов, <Имя> — строка, состоящая не более чем из 15 символов, <класс> — год обучения (от 1 до 12) и заглавная буква (от «А» до «Я») без пробела. <Фамилия> и <Имя>, а также <Имя> <класс> разделены одним пробелом. Пример входной строки:Иванов Петр 10Б Требуется написать программу на языке Паскаль или Бейсик, которая будет выводить на экран информацию о параллелях (годе обучения) с наибольшим числом учеников. Программа должна выводить на экран в первой строке количество учеников в искомых параллелях, а во второй строке — в порядке возрастания номера этих параллелей через пробел. Например: 100 1 7 11",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942268\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения об учениках некоторой средней школы. В первой строке сообщается количество учеников N, каждая из следующих N строк имеет следующий формат: <p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;класс&gt;,<p> <p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 символов, <p>&lt;Имя&gt; — строка, состоящая не более чем из 15 символов, <p>&lt;класс&gt; — год обучения (от 1 до 12) и заглавная буква (от «А» до «Я») без пробела. &lt;Фамилия&gt; и &lt;Имя&gt;, а также &lt;Имя&gt; &lt;класс&gt; разделены одним пробелом. <p><i>Пример входной строки:</i><p class=\"left_margin\">Иванов Петр 10Б<p> </p><p class=\"left_margin\">Требуется написать программу на языке Паскаль или Бейсик, которая будет выводить на экран информацию о параллелях (годе обучения) с наибольшим числом учеников. Программа должна выводить на экран в первой строке количество учеников в искомых параллелях, а во второй строке — в порядке возрастания номера этих параллелей через пробел. <p class=\"left_margin\">Например: <p class=\"left_margin\">100 <p class=\"left_margin\">1 7 11</p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа должна верно читать входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 12 целых чисел, количество учащихся в каждой из параллелей. Затем с использованием этого массива ищется параллель с максимальным числом учеников. За дополнительный просмотр этого массива распечатывается информация об искомых параллелях. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, параллель с максимальным количеством учеников единственна). Пример правильной и эффективной программы на языке Паскаль: var рс:array[1..12] of integer; р : 1. .12;class:string[3]; с:char;max, i, N:integer; begin readln(N) ; for i:=1 to 12 do pc[i]:=0; for i:=l to N do begin repeat read(c)until c=' '; {считана фамилия}repeatread(c)until c=' '; {считано имя} readln(class);{определяем номер параллели} if length(class)=2 then p:=ord(class[1])-ord(10') else p:=(ord(class[1])-ord('0'))*10+ ord(class[2])-ord('0'); pc[p]:=pc[p]+1;{учитываем ученика этой параллели} end; max:=0;for i:=1 to 12 do if pc[i]>max then max:=pc[i];writeln('Максимум учеников в параллели:',max); for i:=1 to 12 do if pc[i]=max then write(i,' '); readln end. Пример правильной программы на языке Бейсик: DIM i, j, р, n, max, pc(12) AS INTEGER DIM m(12) DIM s AS STRING FOR i = 1 TO 12 pc(i) = 0NEXT i INPUT nFOR j = 1 TO n LINE INPUT s c$ = MI D$ (s, 1, 1) i = 1WHILE NOT (с $ = \" \") i = i - 1c$ = MID$ (s, i, 1) WEND i = i + 1с$ = MID$(s, i, 1) WHILE NOT (с $ = \" \") i = i + 1c$ = MID$(s, i, 1) WENDs = MID$ (s, i + 1, 3)IF MID$(s, 2, 1) >= \"0\" AND MID$(s, 2, 1) < = \"2\" THENp = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 10 + ASC(MID$(s, 2, 1)) - ASC(\"0\") ELSEp = ASC(MID$(s, 1, 1)) - ASC(\"0\") ENDIFpc(p) = pc(p) + 1 NEXT j max = 0FOR i = 1 TO 12IF pc (i) > max THEN max = pc(i) NEXT iPRINT \"Max = \"; max FOR i = 1 TO 12IF pc(i) = max THEN PRINT i; \" \"; NEXT i END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3648\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа должна верно читать входные данные, не запоминая их все, а сразу подсчитывая в массиве, хранящем 12 целых чисел, количество учащихся в каждой из параллелей. Затем с использованием этого массива ищется параллель с максимальным числом учеников. За дополнительный просмотр этого массива распечатывается информация об искомых параллелях. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, параллель с максимальным количеством учеников единственна).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p> </p><p>var рс:array[1..12] of integer; <p>р : 1. .12;<p>class:string[3]; <p>с:char;<p>max, i, N:integer; <p>begin readln(N) ; <p>for i:=1 to 12 do <p>pc[i]:=0; <p>for i:=l to N do <p>begin <p>repeat <p>read(c)<p>until c=' '; {считана фамилия}<p>repeat<p>read(c)<p>until c=' '; {считано имя} <p>readln(class);<p>{определяем номер параллели} <p>if length(class)=2 then <p>p:=ord(class[1])-ord(10') else <p>p:=(ord(class[1])-ord('0'))*10+ <p>ord(class[2])-ord('0'); <p>pc[p]:=pc[p]+1;{учитываем ученика этой параллели} <p>end; <p>max:=0;<p>for i:=1 to 12 do <p>if pc[i]&gt;max then max:=pc[i];<p>writeln('Максимум учеников в параллели:',max); <p>for i:=1 to 12 do <p>if pc[i]=max then <p>write(i,' '); <p>readln <p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p> </p><p class=\"left_margin\">DIM i, j, р, n, max, pc(12) AS INTEGER <p class=\"left_margin\">DIM m(12) <p class=\"left_margin\">DIM s AS STRING <p class=\"left_margin\">FOR i = 1 TO 12 <p>pc(i) = 0<p class=\"left_margin\">NEXT i <p class=\"left_margin\">INPUT n<p class=\"left_margin\">FOR j = 1 TO n <p class=\"left_margin\">LINE INPUT s <p>c$ = MI D$ (s, 1, 1) <p>i = 1<p class=\"left_margin\">WHILE NOT (с $ = \" \") <p>i = i - 1<p>c$ = MID$ (s, i, 1) <p class=\"left_margin\">WEND i = i + 1<p>с$ = MID$(s, i, 1) <p class=\"left_margin\">WHILE NOT (с $ = \" \") <p>i = i + 1<p>c$ = MID$(s, i, 1) <p class=\"left_margin\">WEND<p>s = MID$ (s, i + 1, 3)<p class=\"left_margin\">IF MID$(s, 2, 1) &gt;= \"0\" AND MID$(s, 2, 1) &lt; = <p>\"2\" THEN<p>p = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 10 + <p class=\"left_margin\">ASC(MID$(s, 2, 1)) - ASC(\"0\") <p class=\"left_margin\">ELSE<p>p = ASC(MID$(s, 1, 1)) - ASC(\"0\") <p class=\"left_margin\">ENDIF<p>pc(p) = pc(p) + 1 <p class=\"left_margin\">NEXT j <p>max = 0<p class=\"left_margin\">FOR i = 1 TO 12<p class=\"left_margin\">IF pc (i) &gt; max THEN max = pc(i) <p class=\"left_margin\">NEXT i<p class=\"left_margin\">PRINT \"Max = \"; max <p class=\"left_margin\">FOR i = 1 TO 12<p class=\"left_margin\">IF pc(i) = max THEN PRINT i; \" \"; <p class=\"left_margin\">NEXT i <p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3648"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого соответствует числу входных данных N или максимальной цене (3000). Во время чтения данных определяются две минимальных цены и количество АЗС, продающих по 92-й бензин по этим ценам. При печати результата проверяется, что у кого-то цена больше минимальной (вторая по минимальности цена существует), в этом случае искомая (искомые) АЗС — со второй по величине ценой, если это не так, то искомая (искомые) АЗС — все, продающие 92-й бензин. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, когда все АЗС продают бен¬зин по различной цене, и 92-й бензин продают не менее двух АЗС). Пример правильной и эффективной программы на языке Паскаль:var c: char; i, k, N, b, mini, min2, cntl, cnt2: integer; s,si,s2: string; begin mini:=3001; cntl:=0; readln(N); for i:=l to N do begin read(c) ; si := ' ' ; repeat s:=s+c; read(c);until c=' '; {считана компания} repeat s:=s+c; read(c) ;until c=' '; {улица добавлена к компании}readln(k,b);if k = 92 thenif mini > b thenbeginmin2:=minl; cnt2:=cntl; s2:=sl; minl:=b; cntl:=l; sl:=s end elseif mini = b then cntl:=cntl+l elseif min2 > b thenbeginmin2:=b; cnt2:=l; s2:=s end elseif min2 = b then cnt2:=cnt2+l end;if cnt2>0 thenif cnt2=l then writeln(s2) else writeln(cnt2) else {все АЗС продают 92-й бензин по одной цене} if cntl=l then writeln(sl) else writeln(cntl) ; writeln; end. Пример правильной программы на языке Бейсик:DIM s AS STRINGDIM si AS STRING, s2 AS STRINGmini = 3001 cntl = 0 INPUT nFOR j = 1 TO n LINE INPUT s i = 0 DOi = i + 1c$ - MID$(s, i, 1) LOOP WHILE c$ <> \" \" DOi = i + 1c$ = MID$ (s, i, 1) LOOP WHILE c$ 0> \" \" DOi = i + Iс $ - MID$ (s, i, 1) LOOP WHILE c$ <> \" \" m = VAL(MID$(S, i + 1, 2) ) b = VAL(MID$(s, i + 4)) k = i - 1 s = LEFTS(s, k) IF m = 92 THEN IF mini > b THEN min2 = mini: cnt2 = cntl: s2 = si mini = b: cntl = 1: s1 = s ELSEIF mini = b THEN cntl = cntl + 1 ELSEIF min2 > b THENmin2 = b: cnt2 =1: s2 = sELSEIF min2 = b THEN cnt2 = cnt2 + i ENDIF ENDIF ENDIF ENDIF NEXT jIF cnt2 > 0 THEN IF cnt2 = 1 THEN PRINT s2 'ELSE PRINT cnt2 ELSEIF cntl = 1 THEN PRINT si ELSE PRINT cntl ENDIF END",
            "parsed": "2019-04-29 21:13:55.167194",
            "question": "На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для бензина с маркировкой 92, на какой АЗС его продают по второй по минимальности цене (считается, что самой низкой цене потребители не доверяют), а если таких АЗС несколько, то выдается только количество таких АЗС. Если все АЗС, у которых 92-й бензин есть, продают его по одной и той же цене, то эта цена считается искомой и выдается либо число таких АЗС, когда их несколько, либо конкретная АЗС, если она одна. Гарантируется, что хотя бы одна АЗС 92-й бензин продает.На вход программе сначала подается число данных о стоимости бензина N. В каждой из сле¬дующих N строк находится информация в следующем формате:  <Компания> <Улица> <Марка> <Цена> где <Компания> — строка, состоящая не более чем из 20 символов без пробелов, <Улица> — строка, состоящая не более чем из 20 символов без пробелов, <Марка> — одно из чисел — 92, 95 или 98, <Цена> — целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. <Компания> и <Улица>, <Улица> и <Марка>, а также <Марка> и <цена> разделены ровно одним пробелом.  Пример входной строки:СуперБенз Цветочная 92 1950Программа должна выводить через пробел Компанию и Улицу искомой АЗС или их количество, если искомых вариантов несколько. Пример выходных данных:Бензинчик ПерспективнаяВторой вариант выходных данных:4",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942271\" width=\"100%\"><p class=\"left_margin\">На автозаправочных станциях (АЗС) продается бензин с маркировкой 92, 95 и 98. В городе N был проведен мониторинг цены бензина на различных АЗС.<p class=\"left_margin\">Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для бензина с маркировкой 92, на какой АЗС его продают по второй по минимальности цене (считается, что самой низкой цене потребители не доверяют), а если таких АЗС несколько, то выдается только количество таких АЗС. Если все АЗС, у которых 92-й бензин есть, продают его по одной и той же цене, то эта цена считается искомой и выдается либо число таких АЗС, когда их несколько, либо конкретная АЗС, если она одна. Гарантируется, что хотя бы одна АЗС 92-й бензин продает.<p class=\"left_margin\">На вход программе сначала подается число данных о стоимости бензина N. В каждой из сле¬дующих N строк находится информация в следующем формате: <p> </p><p>&lt;Компания&gt; &lt;Улица&gt; &lt;Марка&gt; &lt;Цена&gt;<p> </p><p>где &lt;Компания&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Улица&gt; — строка, состоящая не более чем из 20 символов без пробелов, <p>&lt;Марка&gt; — одно из чисел — 92, 95 или 98, <p>&lt;Цена&gt; — целое число в диапазоне от 1000 до 3000, обозначающее стоимость одного литра бензина в копейках. <p>&lt;Компания&gt; и &lt;Улица&gt;, &lt;Улица&gt; и &lt;Марка&gt;, а также &lt;Марка&gt; и &lt;цена&gt; разделены ровно одним пробелом. <p> </p><p class=\"left_margin\">Пример входной строки:<p><i>СуперБенз Цветочная 92 1950</i><p class=\"left_margin\">Программа должна выводить через пробел Компанию и Улицу искомой АЗС или их количество, если искомых вариантов несколько. <p class=\"left_margin\">Пример выходных данных:<p><i>Бензинчик Перспективная</i><p class=\"left_margin\">Второй вариант выходных данных:<p><i>4</i><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого соответствует числу входных данных N или максимальной цене (3000). Во время чтения данных определяются две минимальных цены и количество АЗС, продающих по 92-й бензин по этим ценам. При печати результата проверяется, что у кого-то цена больше минимальной (вторая по минимальности цена существует), в этом случае искомая (искомые) АЗС — со второй по величине ценой, если это не так, то искомая (искомые) АЗС — все, продающие 92-й бензин. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, когда все АЗС продают бен¬зин по различной цене, и 92-й бензин продают не менее двух АЗС). Пример правильной и эффективной программы на языке Паскаль:var c: char; i, k, N, b, mini, min2, cntl, cnt2: integer; s,si,s2: string; begin mini:=3001; cntl:=0; readln(N); for i:=l to N do begin read(c) ; si := ' ' ; repeat s:=s+c; read(c);until c=' '; {считана компания} repeat s:=s+c; read(c) ;until c=' '; {улица добавлена к компании}readln(k,b);if k = 92 thenif mini > b thenbeginmin2:=minl; cnt2:=cntl; s2:=sl; minl:=b; cntl:=l; sl:=s end elseif mini = b then cntl:=cntl+l elseif min2 > b thenbeginmin2:=b; cnt2:=l; s2:=s end elseif min2 = b then cnt2:=cnt2+l end;if cnt2>0 thenif cnt2=l then writeln(s2) else writeln(cnt2) else {все АЗС продают 92-й бензин по одной цене} if cntl=l then writeln(sl) else writeln(cntl) ; writeln; end. Пример правильной программы на языке Бейсик:DIM s AS STRINGDIM si AS STRING, s2 AS STRINGmini = 3001 cntl = 0 INPUT nFOR j = 1 TO n LINE INPUT s i = 0 DOi = i + 1c$ - MID$(s, i, 1) LOOP WHILE c$ <> \" \" DOi = i + 1c$ = MID$ (s, i, 1) LOOP WHILE c$ 0> \" \" DOi = i + Iс $ - MID$ (s, i, 1) LOOP WHILE c$ <> \" \" m = VAL(MID$(S, i + 1, 2) ) b = VAL(MID$(s, i + 4)) k = i - 1 s = LEFTS(s, k) IF m = 92 THEN IF mini > b THEN min2 = mini: cnt2 = cntl: s2 = si mini = b: cntl = 1: s1 = s ELSEIF mini = b THEN cntl = cntl + 1 ELSEIF min2 > b THENmin2 = b: cnt2 =1: s2 = sELSEIF min2 = b THEN cnt2 = cnt2 + i ENDIF ENDIF ENDIF ENDIF NEXT jIF cnt2 > 0 THEN IF cnt2 = 1 THEN PRINT s2 'ELSE PRINT cnt2 ELSEIF cntl = 1 THEN PRINT si ELSE PRINT cntl ENDIF END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3651\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая их в массиве, размер которого соответствует числу входных данных N или максимальной цене (3000). Во время чтения данных определяются две минимальных цены и количество АЗС, продающих по 92-й бензин по этим ценам. При печати результата проверяется, что у кого-то цена больше минимальной (вторая по минимальности цена существует), в этом случае искомая (искомые) АЗС — со второй по величине ценой, если это не так, то искомая (искомые) АЗС — все, продающие 92-й бензин. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, когда все АЗС продают бен¬зин по различной цене, и 92-й бензин продают не менее двух АЗС).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p>var c: char; <p>i, k, N, b, mini, min2, cntl, cnt2: integer; <p>s,si,s2: string; <p>begin <p>mini:=3001; <p>cntl:=0; <p>readln(N); <p>for i:=l to N do <p>begin <p>read(c) ; <p>si := ' ' ; <p>repeat <p>s:=s+c; <p>read(c);<p>until c=' '; {считана компания} <p>repeat <p>s:=s+c; <p>read(c) ;<p>until c=' '; {улица добавлена к компании}<p>readln(k,b);<p>if k = 92 then<p>if mini &gt; b then<p>begin<p>min2:=minl; <p>cnt2:=cntl; <p>s2:=sl; <p>minl:=b; <p>cntl:=l; <p>sl:=s <p>end else<p>if mini = b then cntl:=cntl+l else<p>if min2 &gt; b then<p>begin<p>min2:=b; cnt2:=l; s2:=s <p>end else<p>if min2 = b then cnt2:=cnt2+l <p>end;<p>if cnt2&gt;0 then<p>if cnt2=l then <p>writeln(s2) else writeln(cnt2) <p>else {все АЗС продают 92-й бензин по одной цене} <p>if cntl=l then writeln(sl) else writeln(cntl) ; <p>writeln; <p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p class=\"left_margin\">DIM s AS STRING<p class=\"left_margin\">DIM si AS STRING, s2 AS STRING<p>mini = 3001 <p>cntl = 0 <p class=\"left_margin\">INPUT n<p class=\"left_margin\">FOR j = 1 TO n <p class=\"left_margin\">LINE INPUT s <p>i = 0 <p class=\"left_margin\">DO<p>i = i + 1<p>c$ - MID$(s, i, 1) <p class=\"left_margin\">LOOP WHILE c$ &lt;&gt; \" \" <p class=\"left_margin\">DO<p>i = i + 1<p>c$ = MID$ (s, i, 1) <p class=\"left_margin\">LOOP WHILE c$ 0&gt; \" \" <p class=\"left_margin\">DO<p>i = i + I<p>с $ - MID$ (s, i, 1) <p class=\"left_margin\">LOOP WHILE c$ &lt;&gt; \" \" <p>m = VAL(MID$(S, i + 1, 2) ) <p>b = VAL(MID$(s, i + 4)) <p>k = i - 1 <p>s = LEFTS(s, k) <p class=\"left_margin\">IF m = 92 THEN <p class=\"left_margin\">IF mini &gt; b THEN <p>min2 = mini: cnt2 = cntl: s2 = si <p>mini = b: cntl = 1: s1 = s <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF mini = b THEN <p>cntl = cntl + 1 <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF min2 &gt; b THEN<p>min2 = b: cnt2 =1: s2 = s<p class=\"left_margin\">ELSE<p class=\"left_margin\">IF min2 = b THEN cnt2 = cnt2 + i <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p class=\"left_margin\">ENDIF <p class=\"left_margin\">NEXT j<p class=\"left_margin\">IF cnt2 &gt; 0 THEN <p class=\"left_margin\">IF cnt2 = 1 THEN PRINT s2 'ELSE PRINT cnt2 <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF cntl = 1 THEN PRINT si ELSE PRINT cntl <p class=\"left_margin\">ENDIF <p class=\"left_margin\">END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3651"
        },
        {
            "answer": "Решение.Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество каждой из букв. Сами входные символы при этом не запоминаются. В дополнительный массив, состоящий из 26 символов, заносятся буквы от «а» до «z». Затем элементы первого массива сортируются по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы второго массива (возможно использование одного массива записей, состоящих из двух полей). При этом элементы с равным числом вхождений символов местами не меняются. Во втором из отсортированных массивов пропускаются элементы, количество которых равно 0, остальные элементы печатаются подряд.Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов). Пример правильной и эффективной программы на языке Паскаль:var а:array[0..25] of integer; m:array[0..25] of 'a'..'z'; с: char;i, j, k: integer; beginfor i:=0 to 25 do begin a[i]: =0;m[i] :=chr(ord(' a ')+i) end;read(c);while c<> ' . ' dobegina[ord(c)-ord('a')] := a[ord(c)-ord('a')] + 1; read(c); end;for i:=1 to 25 dofor j := 0 to 24 do if a[j1 > a[j +1] then begink:=а[j]; с:=m[j]; а[j]:=а[j+1]; m[j]:=m[j+1]; a[j + 1] :=k; m[j+1] :=c end; i : =0;while a[i]=0 do i:=i+1; for j:=i to 25 do write(m[j]); writeln end. Пример правильной и эффективной программы на языке Бейсик:DIM i, j, k, а (26) AS INTEGER DIM s (26) AS STRING * 1 FOR i = 1 TO 26 a (i) = 0s(i) = CHR$(ASC(\"a\") + i - 1) NEXT i INPUT c$DO WHILE NOT (c$ = \".\")a(ASC (c$) - ASC(\"a\") + 1) = = a(ASC(c$) - ASC(\"a\") + 1) + 1INPUT c$ LOOPFOR j = 1 TO 25 FOR i = 1 TO 25 IF a(i) > a(i + 1) THEN k = a (i) c$ = s(i) a (i) = a (i + 1) s(i) = s (i + 1) a (i + 1) = k s(i + 1) = c$ ENDIF NEXT i NEXT j i = 1DO WHILE a(i) =0 i = i + 1 LOOPFOR j = i TO 26 PRINT s(j ) ; NEXT j END",
            "parsed": "2019-04-29 21:13:50.635636",
            "question": "На вход программе подаются строчные английские буквы. Ввод этих символов заканчивается точкой (другие символы, отличные от «.» и букв «а»..«z», во входных данных отсутствуют; в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выводятся в алфавитном порядке. Например, пусть на вход подаются следующие символы: baobaba.В данном случае программа должна вывестиoab",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942266\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются строчные английские буквы. Ввод этих символов заканчивается точкой (другие символы, отличные от «.» и букв «<i>а</i>»..«<i>z</i>», во входных данных отсутствуют; в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет печатать буквы, встречающиеся во входной последовательности, в порядке увеличения частоты их встречаемости. Каждая буква должна быть распечатана один раз. Точка при этом не учитывается. Если какие-то буквы встречаются одинаковое число раз, то они выводятся в алфавитном порядке. <p class=\"left_margin\">Например, пусть на вход подаются следующие символы: <p><i>baobaba.</i><p class=\"left_margin\">В данном случае программа должна вывести<p><i>oab</i><p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество каждой из букв. Сами входные символы при этом не запоминаются. В дополнительный массив, состоящий из 26 символов, заносятся буквы от «а» до «z». Затем элементы первого массива сортируются по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы второго массива (возможно использование одного массива записей, состоящих из двух полей). При этом элементы с равным числом вхождений символов местами не меняются. Во втором из отсортированных массивов пропускаются элементы, количество которых равно 0, остальные элементы печатаются подряд.Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов). Пример правильной и эффективной программы на языке Паскаль:var а:array[0..25] of integer; m:array[0..25] of 'a'..'z'; с: char;i, j, k: integer; beginfor i:=0 to 25 do begin a[i]: =0;m[i] :=chr(ord(' a ')+i) end;read(c);while c<> ' . ' dobegina[ord(c)-ord('a')] := a[ord(c)-ord('a')] + 1; read(c); end;for i:=1 to 25 dofor j := 0 to 24 do if a[j1 > a[j +1] then begink:=а[j]; с:=m[j]; а[j]:=а[j+1]; m[j]:=m[j+1]; a[j + 1] :=k; m[j+1] :=c end; i : =0;while a[i]=0 do i:=i+1; for j:=i to 25 do write(m[j]); writeln end. Пример правильной и эффективной программы на языке Бейсик:DIM i, j, k, а (26) AS INTEGER DIM s (26) AS STRING * 1 FOR i = 1 TO 26 a (i) = 0s(i) = CHR$(ASC(\"a\") + i - 1) NEXT i INPUT c$DO WHILE NOT (c$ = \".\")a(ASC (c$) - ASC(\"a\") + 1) = = a(ASC(c$) - ASC(\"a\") + 1) + 1INPUT c$ LOOPFOR j = 1 TO 25 FOR i = 1 TO 25 IF a(i) > a(i + 1) THEN k = a (i) c$ = s(i) a (i) = a (i + 1) s(i) = s (i + 1) a (i + 1) = k s(i + 1) = c$ ENDIF NEXT i NEXT j i = 1DO WHILE a(i) =0 i = i + 1 LOOPFOR j = i TO 26 PRINT s(j ) ; NEXT j END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3654\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные символы до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество каждой из букв. <p class=\"left_margin\">Сами входные символы при этом не запоминаются. В дополнительный массив, состоящий из 26 символов, заносятся буквы от «<i>а</i>» до «<i>z</i>». Затем элементы первого массива сортируются по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы второго массива (возможно использование одного массива записей, состоящих из двух полей). При этом элементы с равным числом вхождений символов местами не меняются. Во втором из отсортированных массивов пропускаются элементы, количество которых равно 0, остальные элементы печатаются подряд.<p class=\"left_margin\">Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая (например, для строк, состоящих не более чем из 255 символов).<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p>var а:array[0..25] of integer; <p>m:array[0..25] of 'a'..'z'; <p>с: char;<p>i, j, k: integer; <p>begin<p>for i:=0 to 25 do <p>begin <p>a[i]: =0;<p>m[i] :=chr(ord(' a ')+i) <p>end;<p>read(c);<p>while c&lt;&gt; ' . ' do<p>begin<p>a[ord(c)-ord('a')] := a[ord(c)-ord('a')] + 1; <p>read(c); <p>end;<p>for i:=1 to 25 do<p>for j := 0 to 24 do <p>if a[j1 &gt; a[j +1] then <p>begin<p>k:=а[j]; с:=m[j]; <p>а[j]:=а[j+1]; m[j]:=m[j+1]; <p>a[j + 1] :=k; m[j+1] :=c <p>end; <p>i : =0;<p>while a[i]=0 do i:=i+1; <p>for j:=i to 25 do <p>write(m[j]); <p>writeln <p>end.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Бейсик:<p class=\"left_margin\">DIM i, j, k, а (26) AS INTEGER <p class=\"left_margin\">DIM s (26) AS STRING * 1 <p class=\"left_margin\">FOR i = 1 TO 26 <p>a (i) = 0<p>s(i) = CHR$(ASC(\"a\") + i - 1) <p class=\"left_margin\">NEXT i <p class=\"left_margin\">INPUT c$<p class=\"left_margin\">DO WHILE NOT (c$ = \".\")<p>a(ASC (c$) - ASC(\"a\") + 1) = <p>= a(ASC(c$) - ASC(\"a\") + 1) + 1<p class=\"left_margin\">INPUT c$ <p class=\"left_margin\">LOOP<p class=\"left_margin\">FOR j = 1 TO 25 <p class=\"left_margin\">FOR i = 1 TO 25 <p class=\"left_margin\">IF a(i) &gt; a(i + 1) THEN <p>k = a (i) <p>c$ = s(i) <p>a (i) = a (i + 1) <p>s(i) = s (i + 1) <p>a (i + 1) = k <p>s(i + 1) = c$ <p class=\"left_margin\">ENDIF <p class=\"left_margin\">NEXT i <p class=\"left_margin\">NEXT j i = 1<p class=\"left_margin\">DO WHILE a(i) =0 <p>i = i + 1 LOOP<p class=\"left_margin\">FOR j = i TO 26 <p class=\"left_margin\">PRINT s(j ) ; <p class=\"left_margin\">NEXT j <p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "3654"
        },
        {
            "answer": "Решение.Программа читает текст до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество вхождений каждой из букв. Сам текст при этом не запоминается. Затем в этом массиве шлется первое вхождение максимального элемента. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строк, состоящих не более чем из 255 символов). БейсикПаскальDIM i, imах, с, a(26) AS INTEGEROPEN \"TEXT.DAT\" FOR INPUT AS #1S$ = INPUT$(1,#1)DO WHILE NOT (S$ = \".\")c = ASC(S$)IF(c>=ASC(\"A\")AND c<=ASC(\"Z\")) THENс = с - ASC(\"A\") + 1ENDIFIF(c>=ASC(\"a\")AND c<=ASC(\"z\")) THENс = с - ASC(\"a\") + 1ENDIFIF(c >=1 AND c<=26) THEN a(c)=a(c)+1S$ = INPUT$(1,#1)LOOPimax = 1FOR i = 2 TO 26IF a(i) > a(imax) THEN imax = iNEXT iPRINT CHR$(imax + 64), a(imax)ENDvar a:array['A'..'Z'] of integer;c, cmax: char;beginassign(input'text. dat');reset(input);for c:='A'to'Z' do a[c]:=0;repeatread(input, c);c:=upcase(c);if c in['A'...'Z']thena[c]:=a[c]+1until c='.';cmax := 'A';for c:='B'to'Z'doif a[c] > a[cmax] thencmax := c;writeln(cmax,' ',a[cmax])end.",
            "parsed": "2019-04-29 21:14:05.383028",
            "question": "На вход программе (как вариант, из входного файла text.dat) подаётся текст на английском языке. Ввод этих символов заканчивается точкой (другие символы, отличные от «.» во входных данных отсутствуют; в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять и выводить на экран, какая английская буква встречается во входной последовательности чаще всего и сколько именно раз. Строчные и прописные буквы при этом не различаются. Если таких букв несколько, то программа должна выводить на экран ту из них, которая стоит по алфавиту раньше.Например, пусть файл содержит следующую информацию: It is not a simple task. Yes!Тогда чаще всего встречаются буквы I, S, T. (слово Yes в подсчете не участвует, так как расположено после точки). Следовательно, в данном случае, программа должна вывести I 3.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942125\" width=\"100%\"><p class=\"left_margin\">На вход программе (как вариант, из входного файла text.dat) подаётся текст на английском языке. Ввод этих символов заканчивается точкой (другие символы, отличные от «.» во входных данных отсутствуют; в программе на языке Бейсик символы можно вводить по одному в строке, пока не будет введена точка). Требуется написать как можно более эффективную программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять и выводить на экран, какая английская буква встречается во входной последовательности чаще всего и сколько именно раз. Строчные и прописные буквы при этом не различаются. Если таких букв несколько, то программа должна выводить на экран ту из них, которая стоит по алфавиту раньше.<p class=\"left_margin\">Например, пусть файл содержит следующую информацию: <p class=\"left_margin\"><b>It is not a simple task. Yes!</b><p class=\"left_margin\">Тогда чаще всего встречаются буквы I, S, T. (слово Yes в подсчете не участвует, так как расположено после точки). Следовательно, в данном случае, программа должна вывести <p class=\"left_margin\"><b>I 3.</b></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает текст до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество вхождений каждой из букв. Сам текст при этом не запоминается. Затем в этом массиве шлется первое вхождение максимального элемента. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строк, состоящих не более чем из 255 символов). БейсикПаскальDIM i, imах, с, a(26) AS INTEGEROPEN \"TEXT.DAT\" FOR INPUT AS #1S$ = INPUT$(1,#1)DO WHILE NOT (S$ = \".\")c = ASC(S$)IF(c>=ASC(\"A\")AND c<=ASC(\"Z\")) THENс = с - ASC(\"A\") + 1ENDIFIF(c>=ASC(\"a\")AND c<=ASC(\"z\")) THENс = с - ASC(\"a\") + 1ENDIFIF(c >=1 AND c<=26) THEN a(c)=a(c)+1S$ = INPUT$(1,#1)LOOPimax = 1FOR i = 2 TO 26IF a(i) > a(imax) THEN imax = iNEXT iPRINT CHR$(imax + 64), a(imax)ENDvar a:array['A'..'Z'] of integer;c, cmax: char;beginassign(input'text. dat');reset(input);for c:='A'to'Z' do a[c]:=0;repeatread(input, c);c:=upcase(c);if c in['A'...'Z']thena[c]:=a[c]+1until c='.';cmax := 'A';for c:='B'to'Z'doif a[c] > a[cmax] thencmax := c;writeln(cmax,' ',a[cmax])end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3793\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает текст до точки один раз, подсчитывая в массиве, хранящем 26 целых чисел, количество вхождений каждой из букв. Сам текст при этом не запоминается. Затем в этом массиве шлется первое вхождение максимального элемента. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, для строк, состоящих не более чем из 255 символов).<p> </p><p><table align=\"center\" border=\"\" width=\"540\"><p><tr><p><th><b>Бейсик</b></th><p><th><b>Паскаль</b></th><p></p></p></p></tr><p><tr><p><td valign=\"top\"><div class=\"source_code lang_basic\"><p class=\"left_margin\">DIM i, imах, с, a(26) AS INTEGER<p class=\"left_margin\">OPEN \"TEXT.DAT\" FOR INPUT AS #1<p class=\"left_margin\">S$ = INPUT$(1,#1)<p class=\"left_margin\">DO WHILE NOT (S$ = \".\")<p>c = ASC(S$)<p class=\"left_margin\">IF(c&gt;=ASC(\"A\")AND c&lt;=ASC(\"Z\")) THEN<p>с = с - ASC(\"A\") + 1<p class=\"left_margin\">ENDIF<p class=\"left_margin\">IF(c&gt;=ASC(\"a\")AND c&lt;=ASC(\"z\")) THEN<p>с = с - ASC(\"a\") + 1<p class=\"left_margin\">ENDIF<p class=\"left_margin\">IF(c &gt;=1 AND c&lt;=26) THEN a(c)=a(c)+1<p class=\"left_margin\">S$ = INPUT$(1,#1)<p class=\"left_margin\">LOOP<p>imax = 1<p class=\"left_margin\">FOR i = 2 TO 26<p class=\"left_margin\">IF a(i) &gt; a(imax) THEN imax = i<p class=\"left_margin\">NEXT i<p class=\"left_margin\">PRINT CHR$(imax + 64), a(imax)<p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><p><td valign=\"top\"><div class=\"source_code lang_pascal\"><p>var a:array['A'..'Z'] of integer;<p>c, cmax: char;<p>begin<p>assign(input'text. dat');<p>reset(input);<p>for c:='A'to'Z' do a[c]:=0;<p>repeat<p>read(input, c);<p>c:=upcase(c);<p>if c in['A'...'Z']then<p>a[c]:=a[c]+1<p>until c='.';<p>cmax := 'A';<p>for c:='B'to'Z'do<p>if a[c] &gt; a[cmax] then<p>cmax := c;<p>writeln(cmax,' ',a[cmax])<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><p></p></p></p></tr><p></p></p></p></table></p></p></div>",
            "source": "",
            "task_id": "3793"
        },
        {
            "answer": "Решение.Программа читает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев, одновременно суммируя все температуры в году. Затем с использованием этого массива ищется минимальное отклонение среднемесячной температуры от среднегодовой. За дополнительный просмотр этого массива распечатывается информация об искомых месяцах. БейсикПаскальDATA 31,29,31,30,31,30,31,31,30,31,30,31DIM i, m, d(12) AS INTEGERDIM tm(12)DIM dat AS STRING *5FOR i = 1 TO 12tm(i) = 0READ d(i)NEXTity = 0'ty – среднегодовая температураFOR i = 1 TO 366INPUT dat, t'Вычисляем номер месяцаm=(ASC(MID$(dat,4,1))-ASC(\"0\"))*10+ASC(MID$(dat,5,1))-ASC(\"0\")tm(m) = tm(m) + tty = ty + tNEXT iFOR i = 1 TO 12tm(i) = tm(i) / d(i)NEXT ity = ty / 366min = 100FOR i = 1 TO 12IF ABS(tm(i) - ty) < min THEN min = ABS(tm(i) - ty)NEXT iPRINT \"Среднегодовая температура = \";PRINT USING \"##.##\"; tyFOR i = 1 TO 12IF ABS(ABS(tm(i) - ty) - min) < .0001 THENPRINT i;PRINT USING \"##.## \"; tm(i); ABS(tm(i) - ty)END IFNEXT iENDConst d:array[1..12] of integer =(31,29,31,30,31,30,31,31,30,31,30,31);var tm:array[1..12] of real;m:1..12;data:string[5];min,ty,t:real;i:integer;beginfor i:=1 to 12 dotm[i]:=0;ty:=0;{среднегодовая температура}for i:=1 to 366 dobeginreadln(data,t);{вычисляем номер месяца}m:=(ord(data[4])-ord('0'))*10+ord(data[5])-ord('0');tm[m]:=tm[m]+t;ty:=ty+t;end;for i:=1 to 12 dotm[i]:=tm[i]/d[i];ty:=ty/366;min:=100;for i:=1 to 12 doif abs(tm[i]-ty) < min thenmin:=abs(tm[i]-ty);writeln('Среднегодовая температура = ',ty:0:2);for i:=1 to 12 doif abs(abs(tm[i]-ty)-min)<0.0001 thenwriteln(i,' ',tm[i]:0:2,' ',abs(tm[i]-ty):0:2);readlnend.",
            "parsed": "2019-04-29 21:13:59.136826",
            "question": "На вход программе подаются 366 строк, которые содержат информацию о среднесуточной температуре всех дней 2004 года. Формат каждой из строк следующий: сначала записана дата в виде dd.mm (на запись номера дня и номера месяца в числовом формате отводится строго два символа, день от месяца отделен точкой), затем через пробел записано значение температуры — число со знаком плюс или минус, с точностью до 1 цифры после десятичной точки. Данная информация отсортирована по значению температуры, то есть хронологический порядок нарушен. Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран информацию о месяце (месяцах) среднемесячная температура для которого (которых) наименее отклоняется от среднегодовой. В первой строке вывести среднегодовую температуру. Найденные значения для каждого из месяцев следует выводить в отдельной строке в следующем виде: номер месяца, значение среднемесячной температуры, отклонение от среднегодовой температуры.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body942126\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются 366 строк, которые содержат информацию о среднесуточной температуре всех дней 2004 года. Формат каждой из строк следующий: сначала записана дата в виде dd.mm (на запись номера дня и номера месяца в числовом формате отводится строго два символа, день от месяца отделен точкой), затем через пробел записано значение температуры — число со знаком плюс или минус, с точностью до 1 цифры после десятичной точки. Данная информация отсортирована по значению температуры, то есть хронологический порядок нарушен. Напишите эффективную, в том числе и по используемой памяти, программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран информацию о месяце (месяцах) среднемесячная температура для которого (которых) наименее отклоняется от среднегодовой. В первой строке вывести среднегодовую температуру. Найденные значения для каждого из месяцев следует выводить в отдельной строке в следующем виде: номер месяца, значение среднемесячной температуры, отклонение от среднегодовой температуры.</p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев, одновременно суммируя все температуры в году. Затем с использованием этого массива ищется минимальное отклонение среднемесячной температуры от среднегодовой. За дополнительный просмотр этого массива распечатывается информация об искомых месяцах. БейсикПаскальDATA 31,29,31,30,31,30,31,31,30,31,30,31DIM i, m, d(12) AS INTEGERDIM tm(12)DIM dat AS STRING *5FOR i = 1 TO 12tm(i) = 0READ d(i)NEXTity = 0'ty – среднегодовая температураFOR i = 1 TO 366INPUT dat, t'Вычисляем номер месяцаm=(ASC(MID$(dat,4,1))-ASC(\"0\"))*10+ASC(MID$(dat,5,1))-ASC(\"0\")tm(m) = tm(m) + tty = ty + tNEXT iFOR i = 1 TO 12tm(i) = tm(i) / d(i)NEXT ity = ty / 366min = 100FOR i = 1 TO 12IF ABS(tm(i) - ty) < min THEN min = ABS(tm(i) - ty)NEXT iPRINT \"Среднегодовая температура = \";PRINT USING \"##.##\"; tyFOR i = 1 TO 12IF ABS(ABS(tm(i) - ty) - min) < .0001 THENPRINT i;PRINT USING \"##.## \"; tm(i); ABS(tm(i) - ty)END IFNEXT iENDConst d:array[1..12] of integer =(31,29,31,30,31,30,31,31,30,31,30,31);var tm:array[1..12] of real;m:1..12;data:string[5];min,ty,t:real;i:integer;beginfor i:=1 to 12 dotm[i]:=0;ty:=0;{среднегодовая температура}for i:=1 to 366 dobeginreadln(data,t);{вычисляем номер месяца}m:=(ord(data[4])-ord('0'))*10+ord(data[5])-ord('0');tm[m]:=tm[m]+t;ty:=ty+t;end;for i:=1 to 12 dotm[i]:=tm[i]/d[i];ty:=ty/366;min:=100;for i:=1 to 12 doif abs(tm[i]-ty) < min thenmin:=abs(tm[i]-ty);writeln('Среднегодовая температура = ',ty:0:2);for i:=1 to 12 doif abs(abs(tm[i]-ty)-min)<0.0001 thenwriteln(i,' ',tm[i]:0:2,' ',abs(tm[i]-ty):0:2);readlnend.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol3794\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает входные данные, сразу подсчитывая в массиве, хранящем 12 вещественных чисел, сумму температур в каждом из месяцев, одновременно суммируя все температуры в году. Затем с использованием этого массива ищется минимальное отклонение среднемесячной температуры от среднегодовой. За дополнительный просмотр этого массива распечатывается информация об искомых месяцах.<p> </p><p><table align=\"center\" border=\"\" width=\"540\"><p><tr><p><th><b>Бейсик</b></th><p><th><b>Паскаль</b></th><p></p></p></p></tr><p><tr><p><td valign=\"top\"><div class=\"source_code lang_basic\"><p class=\"left_margin\">DATA 31,29,31,30,31,30,31,31,30,31,30,31<p class=\"left_margin\">DIM i, m, d(12) AS INTEGER<p class=\"left_margin\">DIM tm(12)<p class=\"left_margin\">DIM dat AS STRING *5<p class=\"left_margin\">FOR i = 1 TO 12<p>tm(i) = 0<p class=\"left_margin\">READ d(i)<p class=\"left_margin\">NEXTi<p>ty = 0<p>'ty – среднегодовая температура<p class=\"left_margin\">FOR i = 1 TO 366<p class=\"left_margin\">INPUT dat, t<p>'Вычисляем номер месяца<p>m=(ASC(MID$(dat,4,1))-ASC(\"0\"))*10+<p class=\"left_margin\">ASC(MID$(dat,5,1))-ASC(\"0\")<p>tm(m) = tm(m) + t<p>ty = ty + t<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR i = 1 TO 12<p>tm(i) = tm(i) / d(i)<p class=\"left_margin\">NEXT i<p>ty = ty / 366<p>min = 100<p class=\"left_margin\">FOR i = 1 TO 12<p class=\"left_margin\">IF ABS(tm(i) - ty) &lt; min THEN min = ABS(tm(i) - ty)<p class=\"left_margin\">NEXT i<p class=\"left_margin\">PRINT \"Среднегодовая температура = \";<p class=\"left_margin\">PRINT USING \"##.##\"; ty<p class=\"left_margin\">FOR i = 1 TO 12<p class=\"left_margin\">IF ABS(ABS(tm(i) - ty) - min) &lt; .0001 THEN<p class=\"left_margin\">PRINT i;<p class=\"left_margin\">PRINT USING \"##.## \"; tm(i); ABS(tm(i) - ty)<p class=\"left_margin\">END IF<p class=\"left_margin\">NEXT i<p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><p><td valign=\"top\"><div class=\"source_code lang_pascal\"><p class=\"left_margin\">Const d:array[1..12] of integer =<p class=\"left_margin\">(31,29,31,30,31,30,31,31,30,31,30,31);<p>var tm:array[1..12] of real;<p>m:1..12;<p>data:string[5];<p>min,ty,t:real;<p>i:integer;<p>begin<p>for i:=1 to 12 do<p>tm[i]:=0;<p>ty:=0;{среднегодовая температура}<p>for i:=1 to 366 do<p>begin<p>readln(data,t);<p>{вычисляем номер месяца}<p>m:=(ord(data[4])-ord('0'))*10<p>+ord(data[5])-ord('0');<p>tm[m]:=tm[m]+t;<p>ty:=ty+t;<p>end;<p>for i:=1 to 12 do<p>tm[i]:=tm[i]/d[i];<p>ty:=ty/366;<p>min:=100;<p>for i:=1 to 12 do<p>if abs(tm[i]-ty) &lt; min then<p>min:=abs(tm[i]-ty);<p>writeln('Среднегодовая температура = ',ty:0:2);<p>for i:=1 to 12 do<p>if abs(abs(tm[i]-ty)-min)&lt;0.0001 then<p>writeln(i,' ',tm[i]:0:2,' ',abs(tm[i]-ty):0:2);<p>readln<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><p></p></p></p></tr><p></p></p></p></table></p></p></div>",
            "source": "",
            "task_id": "3794"
        },
        {
            "answer": "Решение.Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных. Пример правильной программы на языке Паскаль:var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(с,c,c1); {считаны часы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;end;end;end. Пример правильной программы на языке Бейсик:DIM p(1000) AS INTEGERDIM s AS STRINGDIM nm AS STRINGINPUT nINPUT kFOR i = 1 TO kp(i) = 0NEXT iFOR j = 1 TO nLINE INPUT sc$ = MID$(s, 1, 1)i = 1WHILE NOT (c$ = \" \")i = i + 1c$ = MID$(s, i, 1)WENDnm = MID$(s, 1, i)time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))FOR i = 1 TO kIF time1 >= p(i) THENp(i) = time2PRINT nm, iGOTO 10ENDIFNEXT i10 NEXT jEND ",
            "parsed": "2019-04-29 21:13:59.520841",
            "question": "На вход программе подаются сведения о пассажирах, желающих сдать свой багаж в камеру хранения на заранее известное время до полуночи. В первой строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000; во второй строке – количество ячеек в камере хранения М, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:<Фамилия> <время сдачи багажа> <время освобождения ячейки>, где <Фамилия> – строка, состоящая не более чем из 20 непробельных символов; <время сдачи багажа> – через двоеточие два целых числа, соответствующие часам (от 00 до 23 – ровно 2 символа) и минутам (от 00 до 59 – ровно 2 символа); <время освобождения ячейки> имеет тот же формат.<Фамилия> и <время сдачи багажа>, а также <время сдачи багажа> и <время освобождения ячейки> разделены одним пробелом. Время освобождения больше времени сдачи.Сведения отсортированы в порядке времени сдачи багажа. Каждому из пассажиров в камере хранения выделяется свободная ячейка с минимальным номером. Если в момент сдачи багажа свободных ячеек нет, то пассажир уходит, не дожидаясь освобождения одной из них. Требуется написать программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран для каждого пассажира номер ему предоставленной ячейки (можно сразу после ввода данных очередного пассажира). Если ячейка пассажиру не предоставлена, то его фамилия не печатается. Пример входных данных:310Иванов 09:45 12:00Петров 10:00 11:00Сидоров 12:00 13:12 Результат работы программы на этих входных данных:Иванов 1Петров 2Сидоров 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body950055\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о пассажирах, желающих сдать свой багаж в камеру хранения на заранее известное время до полуночи. В первой строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000; во второй строке – количество ячеек в камере хранения М, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:<p>&lt;Фамилия&gt; &lt;время сдачи багажа&gt; &lt;время освобождения ячейки&gt;, где &lt;Фамилия&gt; – строка, состоящая не более чем из 20 непробельных символов; &lt;время сдачи багажа&gt; – через двоеточие два целых числа, соответствующие часам (от 00 до 23 – ровно 2 символа) и минутам (от 00 до 59 – ровно 2 символа); &lt;время освобождения ячейки&gt; имеет тот же формат.<p>&lt;Фамилия&gt; и &lt;время сдачи багажа&gt;, а также &lt;время сдачи багажа&gt; и &lt;время освобождения ячейки&gt; разделены одним пробелом. Время освобождения больше времени сдачи.<p class=\"left_margin\">Сведения отсортированы в порядке времени сдачи багажа. Каждому из пассажиров в камере хранения выделяется свободная ячейка с минимальным номером. Если в момент сдачи багажа свободных ячеек нет, то пассажир уходит, не дожидаясь освобождения одной из них. Требуется написать программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран для каждого пассажира номер ему предоставленной ячейки (можно сразу после ввода данных очередного пассажира). Если ячейка пассажиру не предоставлена, то его фамилия не печатается.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">10<p class=\"left_margin\">Иванов 09:45 12:00<p class=\"left_margin\">Петров 10:00 11:00<p class=\"left_margin\">Сидоров 12:00 13:12<p> </p><p class=\"left_margin\">Результат работы программы на этих входных данных:<p class=\"left_margin\">Иванов 1<p class=\"left_margin\">Петров 2<p class=\"left_margin\">Сидоров 1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных. Пример правильной программы на языке Паскаль:var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(с,c,c1); {считаны часы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;end;end;end. Пример правильной программы на языке Бейсик:DIM p(1000) AS INTEGERDIM s AS STRINGDIM nm AS STRINGINPUT nINPUT kFOR i = 1 TO kp(i) = 0NEXT iFOR j = 1 TO nLINE INPUT sc$ = MID$(s, 1, 1)i = 1WHILE NOT (c$ = \" \")i = i + 1c$ = MID$(s, i, 1)WENDnm = MID$(s, 1, i)time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))FOR i = 1 TO kIF time1 >= p(i) THENp(i) = time2PRINT nm, iGOTO 10ENDIFNEXT i10 NEXT jEND ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol4571\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Паскаль:<p>var p:array[1..1000] of integer;<p>c,c1:char;<p>i,j,N,K:integer;<p>name:string;<p>time1,time2:integer;<p>begin<p>readln(N,K);<p>for i:=1 to K do<p>p[i]:=0;<p>for i:=1 to N do<p>begin<p>name:='';<p>repeat<p>read(c);<p>name:=name+c<p>until c=' '; {считана фамилия}<p>read(c,c1); {считаны часы первого времени}<p>time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>read(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>read(с,c,c1); {считаны часы второго времени}<p>time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>readln(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>for j:=1 to K do<p>if p[j]&lt;=time1 then<p>begin<p>p[j]:=time2;<p>writeln(name,' ',j);<p>break;<p>end;<p>end;<p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p class=\"left_margin\">DIM p(1000) AS INTEGER<p class=\"left_margin\">DIM s AS STRING<p class=\"left_margin\">DIM nm AS STRING<p class=\"left_margin\">INPUT n<p class=\"left_margin\">INPUT k<p class=\"left_margin\">FOR i = 1 TO k<p>p(i) = 0<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR j = 1 TO n<p class=\"left_margin\">LINE INPUT s<p>c$ = MID$(s, 1, 1)<p>i = 1<p class=\"left_margin\">WHILE NOT (c$ = \" \")<p>i = i + 1<p>c$ = MID$(s, i, 1)<p class=\"left_margin\">WEND<p>nm = MID$(s, 1, i)<p>time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10<p>time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60<p>time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10<p>time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))<p>time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10<p>time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60<p>time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10<p>time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))<p class=\"left_margin\">FOR i = 1 TO k<p class=\"left_margin\">IF time1 &gt;= p(i) THEN<p>p(i) = time2<p class=\"left_margin\">PRINT nm, i<p class=\"left_margin\">GOTO 10<p class=\"left_margin\">ENDIF<p class=\"left_margin\">NEXT i<p class=\"left_margin\">10 NEXT j<p class=\"left_margin\">END<p> </p><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Демонстрационная версия ЕГЭ—2013 по информатике.",
            "task_id": "4571"
        },
        {
            "answer": "Решение.Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных. Пример правильной программы на языке Паскаль:var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(с,c,c1); {считаны часы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;end;end;end. Пример правильной программы на языке Бейсик:DIM p(1000) AS INTEGERDIM s AS STRINGDIM nm AS STRINGINPUT nINPUT kFOR i = 1 TO kp(i) = 0NEXT iFOR j = 1 TO nLINE INPUT sc$ = MID$(s, 1, 1)i = 1WHILE NOT (c$ = \" \")i = i + 1c$ = MID$(s, i, 1)WENDnm = MID$(s, 1, i)time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))FOR i = 1 TO kIF time1 >= p(i) THENp(i) = time2PRINT nm, iGOTO 10ENDIFNEXT i10 NEXT jEND ",
            "parsed": "2019-04-29 21:13:59.930693",
            "question": "На вход программе подаются сведения о пассажирах, желающих сдать свой багаж в камеру хранения на заранее известное время до полуночи. В первой строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000; во второй строке – количество ячеек в камере хранения М, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:<Фамилия> <время сдачи багажа> <время освобождения ячейки>, где <Фамилия> – строка, состоящая не более чем из 20 непробельных символов; <время сдачи багажа> – через двоеточие два целых числа, соответствующие часам (от 00 до 23 – ровно 2 символа) и минутам (от 00 до 59 – ровно 2 символа); <время освобождения ячейки> имеет тот же формат.<Фамилия> и <время сдачи багажа>, а также <время сдачи багажа> и <время освобождения ячейки> разделены одним пробелом. Время освобождения больше времени сдачи.Сведения отсортированы в порядке времени сдачи багажа. Каждому из пассажиров в камере хранения выделяется свободная ячейка с минимальным номером. Если в момент сдачи багажа свободных ячеек нет, то пассажир уходит, не дожидаясь освобождения одной из них. Требуется написать программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран для каждого пассажира номер ему предоставленной ячейки (можно сразу после ввода данных очередного пассажира). Если ячейка пассажиру не предоставлена, то его фамилия не печатается. Пример входных данных:310Иванов 09:45 12:00Петров 10:00 11:00Сидоров 12:00 13:12 Результат работы программы на этих входных данных:Иванов 1Петров 2Сидоров 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body950023\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о пассажирах, желающих сдать свой багаж в камеру хранения на заранее известное время до полуночи. В первой строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000; во второй строке – количество ячеек в камере хранения М, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:<p>&lt;Фамилия&gt; &lt;время сдачи багажа&gt; &lt;время освобождения ячейки&gt;, где &lt;Фамилия&gt; – строка, состоящая не более чем из 20 непробельных символов; &lt;время сдачи багажа&gt; – через двоеточие два целых числа, соответствующие часам (от 00 до 23 – ровно 2 символа) и минутам (от 00 до 59 – ровно 2 символа); &lt;время освобождения ячейки&gt; имеет тот же формат.<p>&lt;Фамилия&gt; и &lt;время сдачи багажа&gt;, а также &lt;время сдачи багажа&gt; и &lt;время освобождения ячейки&gt; разделены одним пробелом. Время освобождения больше времени сдачи.<p class=\"left_margin\">Сведения отсортированы в порядке времени сдачи багажа. Каждому из пассажиров в камере хранения выделяется свободная ячейка с минимальным номером. Если в момент сдачи багажа свободных ячеек нет, то пассажир уходит, не дожидаясь освобождения одной из них. Требуется написать программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет выводить на экран для каждого пассажира номер ему предоставленной ячейки (можно сразу после ввода данных очередного пассажира). Если ячейка пассажиру не предоставлена, то его фамилия не печатается.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">10<p class=\"left_margin\">Иванов 09:45 12:00<p class=\"left_margin\">Петров 10:00 11:00<p class=\"left_margin\">Сидоров 12:00 13:12<p> </p><p class=\"left_margin\">Результат работы программы на этих входных данных:<p class=\"left_margin\">Иванов 1<p class=\"left_margin\">Петров 2<p class=\"left_margin\">Сидоров 1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных. Пример правильной программы на языке Паскаль:var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(с,c,c1); {считаны часы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;end;end;end. Пример правильной программы на языке Бейсик:DIM p(1000) AS INTEGERDIM s AS STRINGDIM nm AS STRINGINPUT nINPUT kFOR i = 1 TO kp(i) = 0NEXT iFOR j = 1 TO nLINE INPUT sc$ = MID$(s, 1, 1)i = 1WHILE NOT (c$ = \" \")i = i + 1c$ = MID$(s, i, 1)WENDnm = MID$(s, 1, i)time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))FOR i = 1 TO kIF time1 >= p(i) THENp(i) = time2PRINT nm, iGOTO 10ENDIFNEXT i10 NEXT jEND ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol4603\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа верно читает входные данные, сразу запоминая только время окончания хранения багажа в массиве, соответствующем ячейкам камеры хранения. Подходящая ячейка определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания хранения, не превосходящее текущего времени сдачи очередного багажа. В случае удачного выбора ячейки фамилия и номер ячейки распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая. Время можно как переводить в минуты, так и хранить в виде строки, сравнивая затем строки непосредственно. В последнем случае упрощается ввод данных.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Паскаль:<p>var p:array[1..1000] of integer;<p>c,c1:char;<p>i,j,N,K:integer;<p>name:string;<p>time1,time2:integer;<p>begin<p>readln(N,K);<p>for i:=1 to K do<p>p[i]:=0;<p>for i:=1 to N do<p>begin<p>name:='';<p>repeat<p>read(c);<p>name:=name+c<p>until c=' '; {считана фамилия}<p>read(c,c1); {считаны часы первого времени}<p>time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>read(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>read(с,c,c1); {считаны часы второго времени}<p>time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>readln(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>for j:=1 to K do<p>if p[j]&lt;=time1 then<p>begin<p>p[j]:=time2;<p>writeln(name,' ',j);<p>break;<p>end;<p>end;<p>end.<p> </p><p class=\"left_margin\">Пример правильной программы на языке Бейсик:<p class=\"left_margin\">DIM p(1000) AS INTEGER<p class=\"left_margin\">DIM s AS STRING<p class=\"left_margin\">DIM nm AS STRING<p class=\"left_margin\">INPUT n<p class=\"left_margin\">INPUT k<p class=\"left_margin\">FOR i = 1 TO k<p>p(i) = 0<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR j = 1 TO n<p class=\"left_margin\">LINE INPUT s<p>c$ = MID$(s, 1, 1)<p>i = 1<p class=\"left_margin\">WHILE NOT (c$ = \" \")<p>i = i + 1<p>c$ = MID$(s, i, 1)<p class=\"left_margin\">WEND<p>nm = MID$(s, 1, i)<p>time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10<p>time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60<p>time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10<p>time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))<p>time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10<p>time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60<p>time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10<p>time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))<p class=\"left_margin\">FOR i = 1 TO k<p class=\"left_margin\">IF time1 &gt;= p(i) THEN<p>p(i) = time2<p class=\"left_margin\">PRINT nm, i<p class=\"left_margin\">GOTO 10<p class=\"left_margin\">ENDIF<p class=\"left_margin\">NEXT i<p class=\"left_margin\">10 NEXT j<p class=\"left_margin\">END<p> </p><p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "4603"
        },
        {
            "answer": "Решение.Для каждого игрока нам необходимо знать только максимальное количество очков, которое тот смог набрать, и момент времени, в который это количество было набрано. Будем хранить для каждого игрока имя, максимальное количество очков, которое он набрал на данный момент, и время, в которое было набрано это количество. При добавлении новой записи будем пробегать по списку и искать игрока с данным именем. Если такого игрока нет, добавим его. Если есть, то сравним его предыдущий результат с новым и, если нужно, обновим. После того, как считаны все данные, три раза повторим процедуру: найдём игрока с максимальным количеством очков. Если таких несколько, выберем из них игрока и минимальным временем. Выпишем его результат. Теперь в его очки запишем -1, чтобы в следующий раз он никак не мог быть лучшим. Ниже приведён код решения на языке Pascal версии 2.6.2. Эффективный по памяти и времени. var a,a1,a2,a3,i,n:longint;s,s1,s2,s3:string;Beginreadln(n);a1:=0;a2:=0;a2:=0;s1:='';s2:='';s3:='';for i:=1 to n do beginread(a,s);if a>a1 then beginif s=s1 then begin a1:=a; s1:=s; endelse if s=s2 then begin a2:=a1; s2:=s1; a1:=a; s1:=s endelse begina3:=a2;a2:=a1;s3:=s2;s2:=s1;a1:=a;s1:=s;end;end else if a>a2 then beginif s=s2 then begin s2:=s; a2:=a; endelse if (s<>s1) then begina3:=a2;s3:=s2;a2:=a;s2:=s;end;end else if a>a3 then beginif (s<>s1) and (s<>s2) then begina3:=a;s3:=s;end;end;end;writeln('1 место.',s1,' (',a1,')');writeln('2 место.',s2,' (',a2,')');writeln('3 место.',s3,' (',a3,')');end.  Ниже приведён код решения на языке Pascal версии 2.6.2. Не являющегося эффективным по памяти. var n, i, j, cnt, p, found, best, first, ind : longint;    s : string;    name : array [1..100000] of string;    points, num : array [1..100000] of longint;beginreadln(n);for i := 1 to n do  begin  read(p);  readln(s);  found := 0;  for j := 1 to cnt do    if s = name[j] then      found := j;  if found = 0 then    begin    inc(cnt);    name[cnt] := s;    points[cnt] := -1;    found := cnt;    end;  if p > points[found] then    begin    points[found] := p;    num[found] := i;    end;  end;for i := 1 to 3 do  begin  best := -1;  for j := 1 to cnt do    if (points[j] > best) or (points[j] = best) and (num[j] < first) then      begin      best := points[j];      first := num[j];      ind := j;      end;  writeln(i, ' место.', name[ind], ' (', points[ind], ')');  points[ind] := -1;  end;end.",
            "parsed": "2019-04-29 21:14:18.631827",
            "question": "Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам.1. Каждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.2. Чемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат(количество набранных очков) фиксируется и заносится в протокол.3. Участники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.4. Окончательный результат участника определяется по одной игре, лучшей для данного участника.5. Более высокое место в соревнованиях занимает участник, показавший лучший результат.6. При равенстве результатов более высокое место занимает участник, раньше показавший лучший результат.В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра. Напишите эффективную, в том числе по памяти, программу, которая по данным протокола определяет победителя и призёров. Гарантируется, что в чемпионате участвует не менее трёх игроков. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данныхПервая строка содержит число N — общее количество строк протокола. Каждая из следующих N строк содержит записанные через пробел результат участника (целое неотрицательное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе. Гарантируется, что количество участников соревнований не меньше 3.Описание выходных данныхПрограмма должна вывести имена и результаты трёх лучших игроков по форме,приведённой ниже в примере. Пример входных данных:969485 Jack95715 qwerty95715 Alex83647 M197128 qwerty95715 Jack93289 Alex95715 Alex95715 MПример выходных данных для приведённого выше примера входныхданных:1 место. qwerty (197128)2 место. Alex (95715)3 место. Jack (95715)",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body949667\" width=\"100%\"><p class=\"left_margin\">Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам.<p class=\"left_margin\">1. Каждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.<p class=\"left_margin\">2. Чемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат<p class=\"left_margin\">(количество набранных очков) фиксируется и заносится в протокол.<p class=\"left_margin\">3. Участники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.<p class=\"left_margin\">4. Окончательный результат участника определяется по одной игре, лучшей для данного участника.<p class=\"left_margin\">5. Более высокое место в соревнованиях занимает участник, показавший лучший результат.<p class=\"left_margin\">6. При равенстве результатов более высокое место занимает участник, раньше показавший лучший результат.<p class=\"left_margin\">В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра. Напишите эффективную, в том числе по памяти, программу, которая по данным протокола определяет победителя и призёров. Гарантируется, что в чемпионате участвует не менее трёх игроков.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.<p> </p><p><b>Описание входных данных</b><p class=\"left_margin\">Первая строка содержит число N — общее количество строк протокола. Каждая из следующих N строк содержит записанные через пробел результат участника (целое неотрицательное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе.<p> </p><p class=\"left_margin\">Гарантируется, что количество участников соревнований не меньше 3.<p><b>Описание выходных данных</b><p class=\"left_margin\">Программа должна вывести имена и результаты трёх лучших игроков по форме,<p>приведённой ниже в примере.<p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">9<p class=\"left_margin\">69485 Jack<p class=\"left_margin\">95715 qwerty<p class=\"left_margin\">95715 Alex<p class=\"left_margin\">83647 M<p class=\"left_margin\">197128 qwerty<p class=\"left_margin\">95715 Jack<p class=\"left_margin\">93289 Alex<p class=\"left_margin\">95715 Alex<p class=\"left_margin\">95715 M<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных<p>данных:<p class=\"left_margin\">1 место. qwerty (197128)<p class=\"left_margin\">2 место. Alex (95715)<p class=\"left_margin\">3 место. Jack (95715)</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Для каждого игрока нам необходимо знать только максимальное количество очков, которое тот смог набрать, и момент времени, в который это количество было набрано. Будем хранить для каждого игрока имя, максимальное количество очков, которое он набрал на данный момент, и время, в которое было набрано это количество. При добавлении новой записи будем пробегать по списку и искать игрока с данным именем. Если такого игрока нет, добавим его. Если есть, то сравним его предыдущий результат с новым и, если нужно, обновим. После того, как считаны все данные, три раза повторим процедуру: найдём игрока с максимальным количеством очков. Если таких несколько, выберем из них игрока и минимальным временем. Выпишем его результат. Теперь в его очки запишем -1, чтобы в следующий раз он никак не мог быть лучшим. Ниже приведён код решения на языке Pascal версии 2.6.2. Эффективный по памяти и времени. var a,a1,a2,a3,i,n:longint;s,s1,s2,s3:string;Beginreadln(n);a1:=0;a2:=0;a2:=0;s1:='';s2:='';s3:='';for i:=1 to n do beginread(a,s);if a>a1 then beginif s=s1 then begin a1:=a; s1:=s; endelse if s=s2 then begin a2:=a1; s2:=s1; a1:=a; s1:=s endelse begina3:=a2;a2:=a1;s3:=s2;s2:=s1;a1:=a;s1:=s;end;end else if a>a2 then beginif s=s2 then begin s2:=s; a2:=a; endelse if (s<>s1) then begina3:=a2;s3:=s2;a2:=a;s2:=s;end;end else if a>a3 then beginif (s<>s1) and (s<>s2) then begina3:=a;s3:=s;end;end;end;writeln('1 место.',s1,' (',a1,')');writeln('2 место.',s2,' (',a2,')');writeln('3 место.',s3,' (',a3,')');end.  Ниже приведён код решения на языке Pascal версии 2.6.2. Не являющегося эффективным по памяти. var n, i, j, cnt, p, found, best, first, ind : longint;    s : string;    name : array [1..100000] of string;    points, num : array [1..100000] of longint;beginreadln(n);for i := 1 to n do  begin  read(p);  readln(s);  found := 0;  for j := 1 to cnt do    if s = name[j] then      found := j;  if found = 0 then    begin    inc(cnt);    name[cnt] := s;    points[cnt] := -1;    found := cnt;    end;  if p > points[found] then    begin    points[found] := p;    num[found] := i;    end;  end;for i := 1 to 3 do  begin  best := -1;  for j := 1 to cnt do    if (points[j] > best) or (points[j] = best) and (num[j] < first) then      begin      best := points[j];      first := num[j];      ind := j;      end;  writeln(i, ' место.', name[ind], ' (', points[ind], ')');  points[ind] := -1;  end;end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol4959\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Для каждого игрока нам необходимо знать только максимальное количество очков, которое тот смог набрать, и момент времени, в который это количество было набрано. Будем хранить для каждого игрока имя, максимальное количество очков, которое он набрал на данный момент, и время, в которое было набрано это количество. При добавлении новой записи будем пробегать по списку и искать игрока с данным именем. Если такого игрока нет, добавим его. Если есть, то сравним его предыдущий результат с новым и, если нужно, обновим. После того, как считаны все данные, три раза повторим процедуру: найдём игрока с максимальным количеством очков. Если таких несколько, выберем из них игрока и минимальным временем. Выпишем его результат. Теперь в его очки запишем -1, чтобы в следующий раз он никак не мог быть лучшим.<p> </p><p class=\"left_margin\">Ниже приведён код решения на языке Pascal версии 2.6.2. Эффективный по памяти и времени.<p> </p><p>var a,a1,a2,a3,i,n:longint;<p>s,s1,s2,s3:string;<p class=\"left_margin\">Begin<p>readln(n);<p>a1:=0;<p>a2:=0;<p>a2:=0;<p>s1:='';<p>s2:='';<p>s3:='';<p>for i:=1 to n do begin<p>read(a,s);<p>if a&gt;a1 then begin<p>if s=s1 then begin a1:=a; s1:=s; end<p>else if s=s2 then begin a2:=a1; s2:=s1; a1:=a; s1:=s end<p>else begin<p>a3:=a2;<p>a2:=a1;<p>s3:=s2;<p>s2:=s1;<p>a1:=a;<p>s1:=s;<p>end;<p>end else if a&gt;a2 then begin<p>if s=s2 then begin s2:=s; a2:=a; end<p>else if (s&lt;&gt;s1) then begin<p>a3:=a2;<p>s3:=s2;<p>a2:=a;<p>s2:=s;<p>end;<p>end else if a&gt;a3 then begin<p>if (s&lt;&gt;s1) and (s&lt;&gt;s2) then begin<p>a3:=a;<p>s3:=s;<p>end;<p>end;<p>end;<p>writeln('1 место.',s1,' (',a1,')');<p>writeln('2 место.',s2,' (',a2,')');<p>writeln('3 место.',s3,' (',a3,')');<p>end.<p> </p><p> </p><p class=\"left_margin\">Ниже приведён код решения на языке Pascal версии 2.6.2. Не являющегося эффективным по памяти.<p> </p><p>var n, i, j, cnt, p, found, best, first, ind : longint;<p>    s : string;<p>    name : array [1..100000] of string;<p>    points, num : array [1..100000] of longint;<p>begin<p>readln(n);<p>for i := 1 to n do<p>  begin<p>  read(p);<p>  readln(s);<p>  found := 0;<p>  for j := 1 to cnt do<p>    if s = name[j] then<p>      found := j;<p>  if found = 0 then<p>    begin<p>    inc(cnt);<p>    name[cnt] := s;<p>    points[cnt] := -1;<p>    found := cnt;<p>    end;<p>  if p &gt; points[found] then<p>    begin<p>    points[found] := p;<p>    num[found] := i;<p>    end;<p>  end;<p>for i := 1 to 3 do<p>  begin<p>  best := -1;<p>  for j := 1 to cnt do<p>    if (points[j] &gt; best) or (points[j] = best) and (num[j] &lt; first) then<p>      begin<p>      best := points[j];<p>      first := num[j];<p>      ind := j;<p>      end;<p>  writeln(i, ' место.', name[ind], ' (', points[ind], ')');<p>  points[ind] := -1;<p>  end;<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "4959"
        },
        {
            "answer": "Решение.Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока. При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты - сдвинуты на одну позицию вниз. Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.Пример правильной и эффективной программы на алгоритмическом языкеалг начцел К, N ввод К, N целтаб суммы[1:К] литтаб имена[1:К] цел сум лит имяцел низ, верх, место нц для место  от 1 до К суммы[место]:= 0 имена[место]:= \"\"кцнц N разввод сум, имяверх:= 0; низ:= Кнц для место от 1 до Кесли сум>суммы[место] и верх=0 то верх:= место все если имя=имена [место] то низ:= место всекцесли 0<верх<= низ тонц для место от низ до верх+1 шаг −1 суммы[место]:= суммы[место −1] имена[место]:= имена[место −1]кцсуммы[верх]:= сум имена[верх]:= имя всекцнц для место от 1 до К если суммы[место]>0то вывод не, место,\".\",имена[место],\"(\",суммы[место] всекцкон ",
            "parsed": "2019-04-29 21:14:19.046890",
            "question": "Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам: 1.\tКаждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.2.\tЧемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат (количество набранных очков) фиксируется и заносится в протокол.3.\tУчастники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.4.\tОкончательный результат участника определяется по одной, лучшей для данного участника игре.5.\tБолее высокое место в соревнованиях занимает участник, показавший лучший результат.6.\tПри равенстве результатов более высокое место занимает участник, раньше показавший лучший результат. В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра. Спонсор чемпионата предоставил призы различной ценности для награждения К лучших игроков (К<=20). Если участников окажется меньше К, призами награждаются все. Вам необходимо написать эффективную, в том числе по памяти, программу, которая по данным протокола определяет К лучших игроков и занятые ими места.  Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данныхПервая строка содержит числа К — количество имеющихся призов и N — общее количество строк протокола.Каждая из следующих N строк содержит записанные через пробел результат участника (целое положительное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе. Описание выходных данныхПрограмма должна вывести имена и результаты К лучших игроков в порядке занятых мест по форме, приведённой ниже в примере. Если игроков окажется меньше К, нужно вывести данные обо всех игроках. Пример входных данных: 6 1569485 Jack 95715 qwerty 95715 Alex 83647 M 197128 qwerty 95715 Jack 93289 Alex 95715 Alex 95715 M32768 BilboBaggins 99824 TetrisMaster 45482 BilboBaggins 62123 BilboBaggins 77623 M 56791 Champion Пример выходных данных для приведённого выше примера входных данных:1.\tqwerty (197128)2.\tTetrisMaster (99824)3.\tAlex (95715)4.\tJack (95715)5.\tM (95715)6.\tBilboBaggins (62123) ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body949554\" width=\"100%\"><p class=\"left_margin\">Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам:<p> </p><p class=\"left_margin\">1.\tКаждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.<p class=\"left_margin\">2.\tЧемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат (количество набранных очков) фиксируется и заносится в протокол.<p class=\"left_margin\">3.\tУчастники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.<p class=\"left_margin\">4.\tОкончательный результат участника определяется по одной, лучшей для данного участника игре.<p class=\"left_margin\">5.\tБолее высокое место в соревнованиях занимает участник, показавший лучший результат.<p class=\"left_margin\">6.\tПри равенстве результатов более высокое место занимает участник, раньше показавший лучший результат.<p> </p><p class=\"left_margin\">В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра.<p> </p><p class=\"left_margin\">Спонсор чемпионата предоставил призы различной ценности для награждения К лучших игроков (К&lt;=20). Если участников окажется меньше К, призами награждаются все. Вам необходимо написать эффективную, в том числе по памяти, программу, которая по данным протокола определяет К лучших игроков и занятые ими места. <p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.<p> </p><p><i>Описание входных данных</i><p class=\"left_margin\">Первая строка содержит числа К — количество имеющихся призов и N — общее количество строк протокола.<p class=\"left_margin\">Каждая из следующих N строк содержит записанные через пробел результат участника (целое положительное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе.<p> </p><p><i>Описание выходных данных</i><p class=\"left_margin\">Программа должна вывести имена и результаты К лучших игроков в порядке занятых мест по форме, приведённой ниже в примере. Если игроков окажется меньше К, нужно вывести данные обо всех игроках.<p> </p><p><i>Пример входных данных: </i><p class=\"left_margin\">6 15<p class=\"left_margin\">69485 Jack <p class=\"left_margin\">95715 qwerty <p class=\"left_margin\">95715 Alex <p class=\"left_margin\">83647 M <p class=\"left_margin\">197128 qwerty <p class=\"left_margin\">95715 Jack <p class=\"left_margin\">93289 Alex <p class=\"left_margin\">95715 Alex <p class=\"left_margin\">95715 M<p class=\"left_margin\">32768 BilboBaggins <p class=\"left_margin\">99824 TetrisMaster <p class=\"left_margin\">45482 BilboBaggins <p class=\"left_margin\">62123 BilboBaggins <p class=\"left_margin\">77623 M <p class=\"left_margin\">56791 Champion<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">1.\tqwerty (197128)<p class=\"left_margin\">2.\tTetrisMaster (99824)<p class=\"left_margin\">3.\tAlex (95715)<p class=\"left_margin\">4.\tJack (95715)<p class=\"left_margin\">5.\tM (95715)<p class=\"left_margin\">6.\tBilboBaggins (62123) <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока. При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты - сдвинуты на одну позицию вниз. Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.Пример правильной и эффективной программы на алгоритмическом языкеалг начцел К, N ввод К, N целтаб суммы[1:К] литтаб имена[1:К] цел сум лит имяцел низ, верх, место нц для место  от 1 до К суммы[место]:= 0 имена[место]:= \"\"кцнц N разввод сум, имяверх:= 0; низ:= Кнц для место от 1 до Кесли сум>суммы[место] и верх=0 то верх:= место все если имя=имена [место] то низ:= место всекцесли 0<верх<= низ тонц для место от низ до верх+1 шаг −1 суммы[место]:= суммы[место −1] имена[место]:= имена[место −1]кцсуммы[верх]:= сум имена[верх]:= имя всекцнц для место от 1 до К если суммы[место]>0то вывод не, место,\".\",имена[место],\"(\",суммы[место] всекцкон ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5070\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока.<p> </p><p class=\"left_margin\">При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты - сдвинуты на одну позицию вниз.<p> </p><p class=\"left_margin\">Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.<p><b><p class=\"left_margin\">Пример правильной и эффективной программы на алгоритмическом языке</p></b><p>алг <p>нач<p>цел К, N <p>ввод К, N <p>целтаб суммы[1:К] <p>литтаб имена[1:К] <p>цел сум <p>лит имя<p>цел низ, верх, место <p>нц для место  от 1 до К <p>суммы[место]:= 0 <p>имена[место]:= \"\"<p>кц<p>нц N раз<p>ввод сум, имя<p>верх:= 0; низ:= К<p>нц для место от 1 до К<p>если сум&gt;суммы[место] и верх=0 то верх:= место все <p>если имя=имена [место] то низ:= место все<p>кц<p>если 0&lt;верх&lt;= низ то<p>нц для место от низ до верх+1 шаг −1 <p>суммы[место]:= суммы[место −1] <p>имена[место]:= имена[место −1]<p>кц<p>суммы[верх]:= сум <p>имена[верх]:= имя <p>все<p>кц<p>нц для место от 1 до К <p>если суммы[место]&gt;0<p>то вывод не, место,\".\",имена[место],\"(\",суммы[место] <p>все<p>кц<p>кон <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "5070"
        },
        {
            "answer": "Решение.Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока. При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты — сдвинуты на одну позицию вниз. Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.Пример правильной и эффективной программы на алгоритмическом языкеалг начцел К, N ввод К, N целтаб суммы[1:К] литтаб имена[1:К] цел сум лит имяцел низ, верх, место нц для место  от 1 до К суммы[место]:= 0 имена[место]:= \"\"кцнц N разввод сум, имяверх:= 0; низ:= Кнц для место от 1 до Кесли сум>суммы[место] и верх=0 то верх:= место все если имя=имена [место] то низ:= место всекцесли 0<верх<= низ тонц для место от низ до верх+1 шаг −1 суммы[место]:= суммы[место −1] имена[место]:= имена[место −1]кцсуммы[верх]:= сум имена[верх]:= имя всекцнц для место от 1 до К если суммы[место]>0то вывод не, место,\".\",имена[место],\"(\",суммы[место] всекцкон",
            "parsed": "2019-04-29 21:14:19.381606",
            "question": "Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам: 1.\tКаждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.2.\tЧемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат (количество набранных очков) фиксируется и заносится в протокол.3.\tУчастники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.4.\tОкончательный результат участника определяется по одной, лучшей для данного участника игре.5.\tБолее высокое место в соревнованиях занимает участник, показавший лучший результат.6.\tПри равенстве результатов более высокое место занимает участник, раньше показавший лучший результат. В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра. Спонсор чемпионата предоставил призы различной ценности для награждения К лучших игроков (К<=20). Если участников окажется меньше К, призами награждаются все. Вам необходимо написать эффективную, в том числе по памяти, программу, которая по данным протокола определяет К лучших игроков и занятые ими места.  Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данныхПервая строка содержит числа К — количество имеющихся призов и N — общее количество строк протокола.Каждая из следующих N строк содержит записанные через пробел результат участника (целое положительное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе. Описание выходных данныхПрограмма должна вывести имена и результаты К лучших игроков в порядке занятых мест по форме, приведённой ниже в примере. Если игроков окажется меньше К, нужно вывести данные обо всех игроках. Пример входных данных: 6 1569485 Jack 95715 qwerty 95715 Alex 83647 M 197128 qwerty 95715 Jack 93289 Alex 95715 Alex 95715 M32768 BilboBaggins 99824 TetrisMaster 45482 BilboBaggins 62123 BilboBaggins 77623 M 56791 Champion Пример выходных данных для приведённого выше примера входных данных:1.\tqwerty (197128)2.\tTetrisMaster (99824)3.\tAlex (95715)4.\tJack (95715)5.\tM (95715)6.\tBilboBaggins (62123)",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948886\" width=\"100%\"><p class=\"left_margin\">Соревнования по игре «Тетрис-онлайн» проводятся по следующим правилам:<p> </p><p class=\"left_margin\">1.\tКаждый участник регистрируется на сайте игры под определённым игровым именем. Имена участников не повторяются.<p class=\"left_margin\">2.\tЧемпионат проводится в течение определённого времени. В любой момент этого времени любой зарегистрированный участник может зайти на сайт чемпионата и начать зачётную игру. По окончании игры её результат (количество набранных очков) фиксируется и заносится в протокол.<p class=\"left_margin\">3.\tУчастники имеют право играть несколько раз. Количество попыток одного участника не ограничивается.<p class=\"left_margin\">4.\tОкончательный результат участника определяется по одной, лучшей для данного участника игре.<p class=\"left_margin\">5.\tБолее высокое место в соревнованиях занимает участник, показавший лучший результат.<p class=\"left_margin\">6.\tПри равенстве результатов более высокое место занимает участник, раньше показавший лучший результат.<p> </p><p class=\"left_margin\">В ходе соревнований заполняется протокол, каждая строка которого описывает одну игру и содержит результат участника и его игровое имя. Протокол формируется в реальном времени по ходу проведения чемпионата, поэтому строки в нём расположены в порядке проведения игр: чем раньше встречается строка в протоколе, тем раньше закончилась соответствующая этой строке игра.<p> </p><p class=\"left_margin\">Спонсор чемпионата предоставил призы различной ценности для награждения К лучших игроков (К&lt;=20). Если участников окажется меньше К, призами награждаются все. Вам необходимо написать эффективную, в том числе по памяти, программу, которая по данным протокола определяет К лучших игроков и занятые ими места. <p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.<p> </p><p><i>Описание входных данных</i><p class=\"left_margin\">Первая строка содержит числа К — количество имеющихся призов и N — общее количество строк протокола.<p class=\"left_margin\">Каждая из следующих N строк содержит записанные через пробел результат участника (целое положительное число, не превышающее 100 миллионов) и игровое имя (имя не может содержать пробелов). Строки исходных данных соответствуют строкам протокола и расположены в том же порядке, что и в протоколе.<p> </p><p><i>Описание выходных данных</i><p class=\"left_margin\">Программа должна вывести имена и результаты К лучших игроков в порядке занятых мест по форме, приведённой ниже в примере. Если игроков окажется меньше К, нужно вывести данные обо всех игроках.<p> </p><p><i>Пример входных данных: </i><p class=\"left_margin\">6 15<p class=\"left_margin\">69485 Jack <p class=\"left_margin\">95715 qwerty <p class=\"left_margin\">95715 Alex <p class=\"left_margin\">83647 M <p class=\"left_margin\">197128 qwerty <p class=\"left_margin\">95715 Jack <p class=\"left_margin\">93289 Alex <p class=\"left_margin\">95715 Alex <p class=\"left_margin\">95715 M<p class=\"left_margin\">32768 BilboBaggins <p class=\"left_margin\">99824 TetrisMaster <p class=\"left_margin\">45482 BilboBaggins <p class=\"left_margin\">62123 BilboBaggins <p class=\"left_margin\">77623 M <p class=\"left_margin\">56791 Champion<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">1.\tqwerty (197128)<p class=\"left_margin\">2.\tTetrisMaster (99824)<p class=\"left_margin\">3.\tAlex (95715)<p class=\"left_margin\">4.\tJack (95715)<p class=\"left_margin\">5.\tM (95715)<p class=\"left_margin\">6.\tBilboBaggins (62123)</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока. При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты — сдвинуты на одну позицию вниз. Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.Пример правильной и эффективной программы на алгоритмическом языкеалг начцел К, N ввод К, N целтаб суммы[1:К] литтаб имена[1:К] цел сум лит имяцел низ, верх, место нц для место  от 1 до К суммы[место]:= 0 имена[место]:= \"\"кцнц N разввод сум, имяверх:= 0; низ:= Кнц для место от 1 до Кесли сум>суммы[место] и верх=0 то верх:= место все если имя=имена [место] то низ:= место всекцесли 0<верх<= низ тонц для место от низ до верх+1 шаг −1 суммы[место]:= суммы[место −1] имена[место]:= имена[место −1]кцсуммы[верх]:= сум имена[верх]:= имя всекцнц для место от 1 до К если суммы[место]>0то вывод не, место,\".\",имена[место],\"(\",суммы[место] всекцкон",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5226\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает входные данные, не запоминая в массиве информацию обо всех сделанных попытках. В процессе ввода заполняется массив, содержащий К лучших результатов. Допускается создание массива из 20 элементов (указанное в условии максимально возможное значение К) и использование его первых К элементов. Для каждой строки протокола необходимо определить, попадает ли данный результат в текущий список лучших. При этом необходимо учитывать, что очередная попытка может принадлежать игроку, который уже входит в список, в этом случае она засчитывается, только если данный результат выше уже записанного результата данного игрока.<p> </p><p class=\"left_margin\">При включении нового результата в список лучших этот результат должен быть записан на соответствующее ему место, а более низкие результаты — сдвинуты на одну позицию вниз.<p> </p><p class=\"left_margin\">Ниже приводится пример правильной программы на алгоритмическом языке. В данной программе для каждой строки протокола просматривается полный текущий список лучших результатов. Допускается сокращение этого просмотра за счёт дополнительных проверок.<p><b><p class=\"left_margin\">Пример правильной и эффективной программы на алгоритмическом языке</p></b><p>алг <p>нач<p>цел К, N <p>ввод К, N <p>целтаб суммы[1:К] <p>литтаб имена[1:К] <p>цел сум <p>лит имя<p>цел низ, верх, место <p>нц для место  от 1 до К <p>суммы[место]:= 0 <p>имена[место]:= \"\"<p>кц<p>нц N раз<p>ввод сум, имя<p>верх:= 0; низ:= К<p>нц для место от 1 до К<p>если сум&gt;суммы[место] и верх=0 то верх:= место все <p>если имя=имена [место] то низ:= место все<p>кц<p>если 0&lt;верх&lt;= низ то<p>нц для место от низ до верх+1 шаг −1 <p>суммы[место]:= суммы[место −1] <p>имена[место]:= имена[место −1]<p>кц<p>суммы[верх]:= сум <p>имена[верх]:= имя <p>все<p>кц<p>нц для место от 1 до К <p>если суммы[место]&gt;0<p>то вывод не, место,\".\",имена[место],\"(\",суммы[место] <p>все<p>кц<p>кон</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "5226"
        },
        {
            "answer": "Решение.Программа читает исходные данные, не запоминая все точки в массиве. Для каждой четверти хранятся количество точек в этой четверти, координаты ближайшей к осям точки, минимальное расстояние до оси. Для каждой точки определяется, в какой четверти она лежит, после чего данные соответствующей четверти корректируются. При этом точки, лежащие на осях (одна из координат равна нулю), не рассматриваются.Пример правильной и эффективной программы на алгоритмическом языкеалг нач цел N цел х, уцелтаб М[1:4], Rm[1:4], хА[1:4], уА[1:4] цел i цел кнц для i от 1 до 4 М [i] :=0 Rm[i]:=0кцввод N нц N раз ввод х, у выборпри х>0\tи\tу>0 : к\t:= 1при х<0\tи\tу>0 : к\t:=2при х<0\tи\tу<0 : к\t:=3при х>0\tи\tу<0 : к\t:=4иначе к\t:=0\t\t\tвсеесли к>0 тоМ[к]:=М[к]+1если (imin(iabs(х),iabs(у))0) или Rm[k]=0тоRm[к]:=imin(iabs(х),iabs(у)) хА[к]:=х; уА[к]:=увсевсекц к: =1нц для i от 2 до 4если М[i]>М[к] или M[i]=M[k] и Rm[i] < Rm[k]то к:=i всекцвывод \"К = \", к, нc вывод \"М = \" М [ к] , нcвывод \"А = (\", хА[к], \", \",  уА[к], \")\", нcвывод \"R =\" ,Rm[к] кон",
            "parsed": "2019-04-29 21:13:18.452397",
            "question": "Дан список точек плоскости с целочисленными координатами. Необходимо определить: 1)\tномер координатной четверти K, в которой находится больше всего точек;2)\tточку A в этой четверти, наименее удалённую от осей координат;3)\tрасстояние R от этой точки до ближайшей оси. Если в нескольких четвертях расположено одинаковое количество точек, следует выбрать ту четверть, в которой величина R меньше. При равенстве и количества точек, и величины R необходимо выбрать четверть с меньшим номером K. Если в выбранной четверти несколько точек находятся на одинаковом минимальном расстоянии от осей координат, нужно выбрать первую по списку. Точки, хотя бы одна из координат которых равна нулю, считаются не принадлежащими ни одной четверти и не рассматриваются. Напишите эффективную, в том числе по памяти, программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данныхВ первой строке вводится одно целое положительное число - количество точек N.Каждая из следующих N строк содержит координаты очередной точки - два целых числа (первое — координата x, второе — координата у).  Описание выходных данныхПрограмма должна вывести номер выбранной четверти K, количество точек в ней M, координаты выбранной точки A и минимальное расстояние R по образцу, приведённому ниже в примере. Пример входных данных: 7−3 4 1 2 1 1 0 4 −2 −3 −6 8 −12 1   Пример выходных данных для приведённого выше примера входных данных:K = 2 M = 3A = (−12, 1)R = 1 Примечание.Считайте, что во входных данных имеется хотя бы одна точка, не лежащая на осях координат.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948854\" width=\"100%\"><p class=\"left_margin\">Дан список точек плоскости с целочисленными координатами. Необходимо определить:<p> </p><p class=\"left_margin\">1)\tномер координатной четверти K, в которой находится больше всего точек;<p class=\"left_margin\">2)\tточку A в этой четверти, наименее удалённую от осей координат;<p class=\"left_margin\">3)\tрасстояние R от этой точки до ближайшей оси.<p> </p><p class=\"left_margin\">Если в нескольких четвертях расположено одинаковое количество точек, следует выбрать ту четверть, в которой величина R меньше. При равенстве и количества точек, и величины R необходимо выбрать четверть с меньшим номером K. Если в выбранной четверти несколько точек находятся на одинаковом минимальном расстоянии от осей координат, нужно выбрать первую по списку. Точки, хотя бы одна из координат которых равна нулю, считаются не принадлежащими ни одной четверти и не рассматриваются.<p> </p><p class=\"left_margin\">Напишите эффективную, в том числе по памяти, программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.<p> </p><p><i>Описание входных данных</i><p class=\"left_margin\">В первой строке вводится одно целое положительное число - количество точек N.<p class=\"left_margin\">Каждая из следующих N строк содержит координаты очередной точки - два целых числа (первое — координата x, второе — координата у).<p> </p><p> </p><p><i>Описание выходных данных</i><p class=\"left_margin\">Программа должна вывести номер выбранной четверти K, количество точек в ней M, координаты выбранной точки A и минимальное расстояние R по образцу, приведённому ниже в примере.<p> </p><p><i>Пример входных данных: </i><p class=\"left_margin\">7<p>−3 4 <p class=\"left_margin\">1 2 <p class=\"left_margin\">1 1 <p class=\"left_margin\">0 4<p> −2 −3<p> −6 8<p> −12 1<p> </p><p> </p><p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">K = 2 <p class=\"left_margin\">M = 3<p class=\"left_margin\">A = (−12, 1)<p class=\"left_margin\">R = 1<p> </p><p><i>Примечание.</i><p class=\"left_margin\">Считайте, что во входных данных имеется хотя бы одна точка, не лежащая на осях координат.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает исходные данные, не запоминая все точки в массиве. Для каждой четверти хранятся количество точек в этой четверти, координаты ближайшей к осям точки, минимальное расстояние до оси. Для каждой точки определяется, в какой четверти она лежит, после чего данные соответствующей четверти корректируются. При этом точки, лежащие на осях (одна из координат равна нулю), не рассматриваются.Пример правильной и эффективной программы на алгоритмическом языкеалг нач цел N цел х, уцелтаб М[1:4], Rm[1:4], хА[1:4], уА[1:4] цел i цел кнц для i от 1 до 4 М [i] :=0 Rm[i]:=0кцввод N нц N раз ввод х, у выборпри х>0\tи\tу>0 : к\t:= 1при х<0\tи\tу>0 : к\t:=2при х<0\tи\tу<0 : к\t:=3при х>0\tи\tу<0 : к\t:=4иначе к\t:=0\t\t\tвсеесли к>0 тоМ[к]:=М[к]+1если (imin(iabs(х),iabs(у))0) или Rm[k]=0тоRm[к]:=imin(iabs(х),iabs(у)) хА[к]:=х; уА[к]:=увсевсекц к: =1нц для i от 2 до 4если М[i]>М[к] или M[i]=M[k] и Rm[i] < Rm[k]то к:=i всекцвывод \"К = \", к, нc вывод \"М = \" М [ к] , нcвывод \"А = (\", хА[к], \", \",  уА[к], \")\", нcвывод \"R =\" ,Rm[к] кон",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5258\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает исходные данные, не запоминая все точки в массиве. Для каждой четверти хранятся количество точек в этой четверти, координаты ближайшей к осям точки, минимальное расстояние до оси. Для каждой точки определяется, в какой четверти она лежит, после чего данные соответствующей четверти корректируются. При этом точки, лежащие на осях (одна из координат равна нулю), не рассматриваются.<p><b><p class=\"left_margin\">Пример правильной и эффективной программы на алгоритмическом языке</p></b><p>алг <p>нач <p>цел N <p>цел х, у<p>целтаб М[1:4], Rm[1:4], хА[1:4], уА[1:4] <p>цел i <p>цел к<p>нц для i от 1 до 4 М [i] :=0 Rm[i]:=0<p>кц<p>ввод N <p>нц N раз <p>ввод х, у <p>выбор<p>при х&gt;0\tи\tу&gt;0 : к\t:= 1<p>при х&lt;0\tи\tу&gt;0 : к\t:=2<p>при х&lt;0\tи\tу&lt;0 : к\t:=3<p>при х&gt;0\tи\tу&lt;0 : к\t:=4<p>иначе к\t:=0\t\t\t<p>все<p>если к&gt;0 то<p class=\"left_margin\">М[к]:=М[к]+1<p>если (imin(iabs(х),iabs(у))<rm[k] rm[k]<=\"\" и=\"\">0) или Rm[k]=0<p>то<p class=\"left_margin\">Rm[к]:=imin(iabs(х),iabs(у)) <p>хА[к]:=х; уА[к]:=у<p>все<p>все<p>кц к: =1<p>нц для i от 2 до 4<p>если М[i]&gt;М[к] или M[i]=M[k] и Rm[i] &lt; Rm[k]<p>то к:=i все<p>кц<p>вывод \"К = \", к, нc <p>вывод \"М = \" М [ к] , нc<p>вывод \"А = (\", хА[к], \", \",  уА[к], \")\", нc<p>вывод \"R =\" ,Rm[к] <p>кон</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></rm[k]></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "5258"
        },
        {
            "answer": "Решение.Ниже приведены примеры решения задания на языке Паскаль, на алгоритмическом языке и на языке Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль:program с4_1; varn, up, х, start, last :\tinteger;beginn: =0; up:=0;start:=1001; last:=1001; repeatreadln(x); n: =n+1;if x < last then beginif last > 2*start then up:=up+1; start:=x; end;last:=x; until x = 0;writeln('Получено чисел:\t',\tn-1);writeln('Найдено значительных подъемов:\t', up);end.Пример правильной и эффективной программы на алгоритмическом языке:алг С4_1 начцел n, up, х, start, last n: =0 up: =0start:=1001 last:=1001 нцввод x n: =n+1если x < last toесли last > 2*start to up:=up+1 все start:=x; всеlast:=x; кц при x=0вывод \"Получено чисел: \", n-1, невывод \"Найдено значительных подъемов: \", up, не кон Пример правильной и эффективной программы на языке Бейсик:DIM n, up, х, start, last AS INTEGERn=0up=0start=1001last=1001DOINPUT xn = n + 1IF x < last THENIF last > 2 * start THEN up = up + 1 start = x;END IF last = x LOOP UNTIL x = 0 PRINT \"Получено чисел: \"; n-1PRINT \"Найдено значительных подъемов:\tup",
            "parsed": "2019-04-29 21:13:13.223634",
            "question": "По каналу связи передаётся последовательность положительных целых чисел Х1, Х2, ... все числа не превышают 1000, их количество заранее неизвестно. Каждое число передаётся в виде отдельной текстовой строки, содержащей десятичную запись числа. Признаком конца передаваемой последовательности является число 0. Участок последовательности от элемента ХT до элемента XT+N называется подъёмом, если на этом участке каждое следующее число больше или равно предыдущему, причем участок нельзя расширить, т.е.1) Т = 1 или ХT-1 > ХT2) XT+N — последний элемент последовательности или XT+N > XT+N+1. Высотой подъёма называется разность XT+N − ХT. Подъём считается значительным, если высота подъёма больше величины минимального элемента этого подъема. Напишите программу, которая вычисляет количество значительных подъемов в заданной последовательности. Программа должна вывести результаты в следующей форме: Получено чисел: ...Найдено значительных подъемов: ... Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б. Перед текстом программы кратко опишите алгоритм решения задачи. Пример входных данных: 14417212737911250 Пример выходных данных для приведённого выше примера входных данных:Получено чисел: 9Найдено значительных подъемов: 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948823\" width=\"100%\"><p class=\"left_margin\">По каналу связи передаётся последовательность положительных целых чисел Х<sub>1</sub>, Х<sub>2</sub>, ... все числа не превышают 1000, их количество заранее неизвестно. Каждое число передаётся в виде отдельной текстовой строки, содержащей десятичную запись числа. Признаком конца передаваемой последовательности является число 0.<p> </p><p class=\"left_margin\">Участок последовательности от элемента Х<sub>T</sub> до элемента X<sub>T+N</sub> называется подъёмом, если на этом участке каждое следующее число больше или равно предыдущему, причем участок нельзя расширить, т.е.<p class=\"left_margin\">1) Т = 1 или Х<sub>T-1</sub> &gt; Х<sub>T</sub><p class=\"left_margin\">2) X<sub>T+N</sub> — последний элемент последовательности или X<sub>T+N</sub> &gt; X<sub>T+N+1</sub>. Высотой подъёма называется разность <nobr>X<sub>T+N</sub> − Х<sub>T</sub>.</nobr> Подъём считается значительным, если высота подъёма больше величины минимального элемента этого подъема.<p> </p><p class=\"left_margin\">Напишите программу, которая вычисляет количество значительных подъемов в заданной последовательности.<p> </p><p class=\"left_margin\">Программа должна вывести результаты в следующей форме:<p> </p><p><b>Получено чисел: ...</b><p><b>Найдено значительных подъемов: ...</b><p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения задачи.<p> </p><p><i>Пример входных данных:</i><p> </p><p class=\"left_margin\">144<p class=\"left_margin\">17<p class=\"left_margin\">21<p class=\"left_margin\">27<p class=\"left_margin\">3<p class=\"left_margin\">7<p class=\"left_margin\">9<p class=\"left_margin\">11<p class=\"left_margin\">25<p class=\"left_margin\">0<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">Получено чисел: 9<p class=\"left_margin\">Найдено значительных подъемов: 1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Ниже приведены примеры решения задания на языке Паскаль, на алгоритмическом языке и на языке Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль:program с4_1; varn, up, х, start, last :\tinteger;beginn: =0; up:=0;start:=1001; last:=1001; repeatreadln(x); n: =n+1;if x < last then beginif last > 2*start then up:=up+1; start:=x; end;last:=x; until x = 0;writeln('Получено чисел:\t',\tn-1);writeln('Найдено значительных подъемов:\t', up);end.Пример правильной и эффективной программы на алгоритмическом языке:алг С4_1 начцел n, up, х, start, last n: =0 up: =0start:=1001 last:=1001 нцввод x n: =n+1если x < last toесли last > 2*start to up:=up+1 все start:=x; всеlast:=x; кц при x=0вывод \"Получено чисел: \", n-1, невывод \"Найдено значительных подъемов: \", up, не кон Пример правильной и эффективной программы на языке Бейсик:DIM n, up, х, start, last AS INTEGERn=0up=0start=1001last=1001DOINPUT xn = n + 1IF x < last THENIF last > 2 * start THEN up = up + 1 start = x;END IF last = x LOOP UNTIL x = 0 PRINT \"Получено чисел: \"; n-1PRINT \"Найдено значительных подъемов:\tup",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5291\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Ниже приведены примеры решения задания на языке Паскаль, на алгоритмическом языке и на языке Бейсик. Допускаются решения, записанные на других языках программирования.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль:</b><p><div class=\"source_code lang_pascal\"><p>program с4_1; <p>var<p>n, up, х, start, last :\tinteger;<p>begin<p>n: =0; <p>up:=0;<p>start:=1001; <p>last:=1001; <p>repeat<p>readln(x); <p>n: =n+1;<p>if x &lt; last then begin<p>if last &gt; 2*start then up:=up+1; <p>start:=x; <p>end;<p>last:=x; <p>until x = 0;<p>writeln('Получено чисел:\t',\tn-1);<p>writeln('Найдено значительных подъемов:\t', up);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p><b>Пример правильной и эффективной программы на алгоритмическом языке:</b><p><div class=\"source_code lang_alg\"><p>алг С4_1 <p>нач<p>цел n, up, х, start, last <p>n: =0 <p>up: =0<p>start:=1001 <p>last:=1001 <p>нц<p>ввод x <p>n: =n+1<p>если x &lt; last to<p>если last &gt; 2*start to up:=up+1 все <p>start:=x; <p>все<p>last:=x; <p>кц при x=0<p>вывод \"Получено чисел: \", n-1, не<p>вывод \"Найдено значительных подъемов: \", up, не кон<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример правильной и эффективной программы на языке Бейсик:</b><p><div class=\"source_code lang_basic\"><p class=\"left_margin\">DIM n, up, х, start, last AS INTEGER<p>n=0<p>up=0<p>start=1001<p>last=1001<p class=\"left_margin\">DO<p class=\"left_margin\">INPUT x<p>n = n + 1<p class=\"left_margin\">IF x &lt; last THEN<p class=\"left_margin\">IF last &gt; 2 * start THEN up = up + 1 <p>start = x;<p class=\"left_margin\">END IF <p>last = x <p class=\"left_margin\">LOOP UNTIL x = 0 <p class=\"left_margin\">PRINT \"Получено чисел: \"; n-1<p class=\"left_margin\">PRINT \"Найдено значительных подъемов:\tup<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "5291"
        },
        {
            "answer": "Решение.Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимальной по модулю отрицательной скорости, если отрицательных скоростей нечётное число.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество отрицательных значений и ищется минимальное по модулю отрицательное значение. После окончания ввода распечатываются все номера, кроме номера 0 номера минимального по модулю отрицательного значения, но только в случае, если их нечётное число.Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскальvar n, i, j, k, c, min, a: longint;beginreadln(n);min := -1000000001;k := 0;j := 0;c := 0;for i := 1 to n dobeginreadln(a);if a = 0 then j := i;if a < 0 thenbeginc := c + 1;if a > min thenbeginmin := a;k := i;endendend;for i := 1 to n doif (i <> j) and ((c mod 2 = 0 ) or (i <> k)) thenwrite(i, ' ');end. Пример правильной и эффективной программы на языке Бейсик  INPUT n min = 0 k = 0 j = 0 c = 0 FOR i = 1 TO n INPUT a IF a = 0 THEN j = i IF a < 0 THEN c = c +1 IF (min = 0) OR (a > min) THEN min = a k = i END IF END IF NEXT i FOR i = 1 TO n IF (i <> j) AND ((C MOD 2 = 0) OR (i <> k)) THEN PRINT i NEXT i END Пример правильной и эффективной программы на языке C++.\t#include <iostream>\tusing namespace std;\tint main (){ \tint N = 0;\tcin >> N;\tlong min = -1000000001;\tint j = 0, k = 0, c = 0;\tfor (int i = 1; i <= N; ++i)\t{\t\tint num;\t\tcin >> num;\t\tif (num == 0)\t\t\tj = i;\t\tif (num < 0)\t\t{\t\t\tc += 1;\t\t\tif (min < num)\t\t\t{\t\t\t\tmin = num;\t\t\t\tk = i;\t\t\t}\t\t}\t}\tfor (int i = 1; i <= N; ++i)\t{\t\tif (i != j && (c % 2 == 0 || i != k))\t\t\tcout << i << ' ';\t} \treturn 0;\t}  Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество чисел}  neg: integer; {количество отрицательных чисел}  maxneg: integer; {наибольшее отрицательное число}  i: integer;begin  readln(N);  neg := 0;  maxneg := -1000000001;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    if a[i]<0 then neg := neg + 1;    if (a[i]<0) and (a[i]>maxneg) then maxneg := a[i];  end;  if neg mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) and (a[i]<>maxneg) then write(i, ' ');  if neg mod 2 = 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "parsed": "2019-04-29 21:13:18.934668",
            "question": "На ускорителе для большого числа частиц производятся замеры скорости каждой из них. Скорость частицы — это целое число (положительное, отрицательное или 0). Частиц, скорость которых измерена, может быть очень много, но не может быть меньше трёх. Скорости всех частиц различны. При обработке результатов в каждой серии эксперимента отбирается основное множество скоростей. Это такое непустое множество скоростей частиц (в него могут войти как скорость одной частицы, так и скорости всех частиц серии), для которого произведение скоростей является максимальным среди всех возможных множеств. При нахождении произведения знак числа учитывается. Если есть несколько таких множеств, то основным считается то, которое содержит наибольшее количество элементов. Вам предлагается написать программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты эксперимента, находя основное множество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество частиц N. В каждой из последующих N строк записано одно целое число, по абсолютной величине не превышающее 109. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.  Пример входных данных: 5 123 2 -1000 0 10 Программа должна вывести в порядке возрастания номера частиц, скорости которых принадлежат основному множеству данной серии. Нумерация частиц ведётся с единицы.Пример выходных данных для приведённого выше примера входных данных: 1 2 5",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948739\" width=\"100%\"><p class=\"left_margin\">На ускорителе для большого числа частиц производятся замеры скорости каждой из них. Скорость частицы — это целое число (положительное, отрицательное или 0). Частиц, скорость которых измерена, может быть очень много, но не может быть меньше трёх. Скорости всех частиц различны. При обработке результатов в каждой серии эксперимента отбирается основное множество скоростей. Это такое непустое множество скоростей частиц (в него могут войти как скорость одной частицы, так и скорости всех частиц серии), для которого произведение скоростей является максимальным среди всех возможных множеств. При нахождении произведения знак числа учитывается. Если есть несколько таких множеств, то основным считается то, которое содержит наибольшее количество элементов.<p> </p><p class=\"left_margin\">Вам предлагается написать программу (укажите используемую версию языка программирования, например, <i>Borland Pascal 7.0</i>), которая будет обрабатывать результаты эксперимента, находя основное множество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи.<p> </p><p class=\"left_margin\">На вход программе в первой строке подаётся количество частиц <i>N</i>. В каждой из последующих <i>N</i> строк записано одно целое число, по абсолютной величине не превышающее 10<sup>9</sup>.<p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p> </p><p><i>Пример входных данных:</i><p> </p><p><i>5<p> </p><p class=\"left_margin\">123 <p class=\"left_margin\">2<p> </p><p>-1000<p> </p><p class=\"left_margin\">0<p> </p><p class=\"left_margin\">10</p></p></p></p></p></i><p> </p><p class=\"left_margin\">Программа должна вывести в порядке возрастания номера частиц, скорости которых принадлежат основному множеству данной серии. Нумерация частиц ведётся с единицы.<p><i>Пример выходных данных для приведённого выше примера входных данных:<p> </p><p class=\"left_margin\">1 2 5</p></i></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимальной по модулю отрицательной скорости, если отрицательных скоростей нечётное число.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество отрицательных значений и ищется минимальное по модулю отрицательное значение. После окончания ввода распечатываются все номера, кроме номера 0 номера минимального по модулю отрицательного значения, но только в случае, если их нечётное число.Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскальvar n, i, j, k, c, min, a: longint;beginreadln(n);min := -1000000001;k := 0;j := 0;c := 0;for i := 1 to n dobeginreadln(a);if a = 0 then j := i;if a < 0 thenbeginc := c + 1;if a > min thenbeginmin := a;k := i;endendend;for i := 1 to n doif (i <> j) and ((c mod 2 = 0 ) or (i <> k)) thenwrite(i, ' ');end. Пример правильной и эффективной программы на языке Бейсик  INPUT n min = 0 k = 0 j = 0 c = 0 FOR i = 1 TO n INPUT a IF a = 0 THEN j = i IF a < 0 THEN c = c +1 IF (min = 0) OR (a > min) THEN min = a k = i END IF END IF NEXT i FOR i = 1 TO n IF (i <> j) AND ((C MOD 2 = 0) OR (i <> k)) THEN PRINT i NEXT i END Пример правильной и эффективной программы на языке C++.\t#include <iostream>\tusing namespace std;\tint main (){ \tint N = 0;\tcin >> N;\tlong min = -1000000001;\tint j = 0, k = 0, c = 0;\tfor (int i = 1; i <= N; ++i)\t{\t\tint num;\t\tcin >> num;\t\tif (num == 0)\t\t\tj = i;\t\tif (num < 0)\t\t{\t\t\tc += 1;\t\t\tif (min < num)\t\t\t{\t\t\t\tmin = num;\t\t\t\tk = i;\t\t\t}\t\t}\t}\tfor (int i = 1; i <= N; ++i)\t{\t\tif (i != j && (c % 2 == 0 || i != k))\t\t\tcout << i << ' ';\t} \treturn 0;\t}  Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество чисел}  neg: integer; {количество отрицательных чисел}  maxneg: integer; {наибольшее отрицательное число}  i: integer;begin  readln(N);  neg := 0;  maxneg := -1000000001;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    if a[i]<0 then neg := neg + 1;    if (a[i]<0) and (a[i]>maxneg) then maxneg := a[i];  end;  if neg mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) and (a[i]<>maxneg) then write(i, ' ');  if neg mod 2 = 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5375\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимальной по модулю отрицательной скорости, если отрицательных скоростей нечётное число.<p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество отрицательных значений и ищется минимальное по модулю отрицательное значение. После окончания ввода распечатываются все номера, кроме номера 0 номера минимального по модулю отрицательного значения, но только в случае, если их нечётное число.<p class=\"left_margin\">Ниже приведены примеры решения задания на языках Паскаль и Бейсик. <p class=\"left_margin\">Допускаются решения, записанные на других языках программирования.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль<p><div class=\"source_code lang_pascal\"><p>var n, i, j, k, c, min, a: longint;<p>begin<p>readln(n);<p>min := -1000000001;<p>k := 0;<p>j := 0;<p>c := 0;<p>for i := 1 to n do<p>begin<p>readln(a);<p>if a = 0 then j := i;<p>if a &lt; 0 then<p>begin<p>c := c + 1;<p>if a &gt; min then<p>begin<p>min := a;<p>k := i;<p>end<p>end<p>end;<p>for i := 1 to n do<p>if (i &lt;&gt; j) and ((c mod 2 = 0 ) or (i &lt;&gt; k)) then<p>write(i, ' ');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример правильной и эффективной программы на языке Бейсик</b><p><div class=\"source_code lang_basic\"><p> </p><p> INPUT n<p> min = 0<p> k = 0<p> j = 0<p> c = 0<p> FOR i = 1 TO n<p> INPUT a<p> IF a = 0 THEN j = i<p> IF a &lt; 0 THEN<p> c = c +1<p> IF (min = 0) OR (a &gt; min) THEN<p> min = a<p> k = i<p> END IF<p> END IF<p> NEXT i<p> FOR i = 1 TO n<p> IF (i &lt;&gt; j) AND ((C MOD 2 = 0) OR (i &lt;&gt; k)) THEN PRINT i<p> NEXT i<p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример правильной и эффективной программы на языке C++.</b><p><div class=\"source_code lang_c\"><pre><p>\t#include &lt;iostream&gt;<p>\tusing namespace std;<p>\tint main (){<p> <p>\tint N = 0;<p>\tcin &gt;&gt; N;<p>\tlong min = -1000000001;<p>\tint j = 0, k = 0, c = 0;<p>\tfor (int i = 1; i &lt;= N; ++i)<p>\t{<p>\t\tint num;<p>\t\tcin &gt;&gt; num;<p>\t\tif (num == 0)<p>\t\t\tj = i;<p>\t\tif (num &lt; 0)<p>\t\t{<p>\t\t\tc += 1;<p>\t\t\tif (min &lt; num)<p>\t\t\t{<p>\t\t\t\tmin = num;<p>\t\t\t\tk = i;<p>\t\t\t}<p>\t\t}<p>\t}<p>\tfor (int i = 1; i &lt;= N; ++i)<p>\t{<p>\t\tif (i != j &amp;&amp; (c % 2 == 0 || i != k))<p>\t\t\tcout &lt;&lt; i &lt;&lt; ' ';<p>\t}<p> <p>\treturn 0;<p>\t}<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre><p></p></div> <p> </p><p class=\"left_margin\"><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество чисел}<p>  neg: integer; {количество отрицательных чисел}<p>  maxneg: integer; {наибольшее отрицательное число}<p>  i: integer;<p>begin<p>  readln(N);<p>  neg := 0;<p>  maxneg := -1000000001;<p>  for i := 1 to N do readln(a[i]);<p>  for i := 1 to N do begin<p>    if a[i]&lt;0 then neg := neg + 1;<p>    if (a[i]&lt;0) and (a[i]&gt;maxneg) then maxneg := a[i];<p>  end;<p>  if neg mod 2 &lt;&gt; 0 then<p>    for i := 1 to N do<p>      if (a[i]&lt;&gt;0) and (a[i]&lt;&gt;maxneg) then write(i, ' ');<p>  if neg mod 2 = 0 then<p>    for i := 1 to N do<p>      if (a[i]&lt;&gt;0) then write(i, ' ');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 30.05.2013. Ос­нов­ная волна. Дальний Восток. Ва­ри­ант 1.",
            "task_id": "5375"
        },
        {
            "answer": "Решение.Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число.Программа читает все входные данные одни раз. не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретился (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное нечётное значение. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно.Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на другихязыках программирования. Пример правильной и эффективной программы на языке Паскаль:var n,i,j,k, c, min, a: longint;beginreadln(n);min := 1000000001; k := 0; j := 0; c := 0;for i := 1 to n do beginreadln(a);if a = 0 then j := i; if a mod 2 <> 0 then beginc := c + 1; if a < min then beginmin := a; k := i; end ;end; end;for i:=1 to n doif (i <> j) and ((c mod 2 <> 0) or (i <> k)) then write(i, ' ');end.  Пример правильной и эффективной программы на языке Бейсик:INPUT nmin = 0k = 0j = 0c = 0FOR i = 1 TO nINPUT aIF a = 0 THEN j = iIF a MOD 2 <> 0 THENc = c + 1IF (min = 0) OR (a < min) THENmin = ak = iEND IFEND IFNEXT iFOR i = 1 TO nIF (i <> j) AND ((c mod 2 <> 0) OR (i <> k)) THEN PRINT iNEXT iEND Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  min: integer; {минимальное нечётное число}  N: integer; {количество чисел}  sum: integer; {максимальная сумма}  i: integer;begin  readln(N);  min := 1000000001;  sum := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    sum := sum + a[i];    if (a[i] mod 2 <> 0) and (a[i]      min := a[i];    end;  if sum mod 2 = 0 then    for i := 1 to N do      if (a[i] <> min) and (a[i]<>0) then write(i, ' ');  if sum mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "parsed": "2019-04-29 21:13:19.236050",
            "question": "На ускорителе для большого числа частиц производятся замеры скорости каждой из них. Скорость частицы — это целое неотрицательное число. Частиц, скорость которых измерена, может быть очень много, но не может быть меньше трёх. Скорости всех частиц различны. Скорость, по крайней мере, одной частицы нечётна.При обработке результатов в каждой серии эксперимента отбирается множество скоростей. Это непустое подмножество скоростей частиц (в него могу войти как скорость одной частицы, так и скорости всех частиц серии), такое, что сумма всех значений скоростей у него нечётна и максимальна среди всех возможных непустых подмножеств с нечётной суммой. Если таких подмножеств несколько, то из них выбирается то подмножество, которое содержит наименьшее количество элементов. Вам предлагается написать программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты эксперимента, находя основное множество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество частиц N. В каждой из последующих N строк записано одно целое неотрицательное число, не превышающее 109. Все N чисел различны. Хотя бы одно из чисел нечётно. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Пример входных данных: 3 1230 2 Программа должна вывести в порядке возрастания номера частиц, скорости которых принадлежат основному множеству данной серии. Нумерация частиц ведётся с единицы. Пример выходных данных для приведённого выше примера входных данных: 1 3",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body949155\" width=\"100%\"><p class=\"left_margin\"><b></b>На ускорителе для большого числа частиц производятся замеры скорости каждой из них. Скорость частицы — это целое неотрицательное число. Частиц, скорость которых измерена, может быть очень много, но не может быть меньше трёх. Скорости всех частиц различны. Скорость, по крайней мере, одной частицы нечётна.<p class=\"left_margin\">При обработке результатов в каждой серии эксперимента отбирается множество скоростей. Это непустое подмножество скоростей частиц (в него могу войти как скорость одной частицы, так и скорости всех частиц серии), такое, что сумма всех значений скоростей у него нечётна и максимальна среди всех возможных непустых подмножеств с нечётной суммой. Если таких подмножеств несколько, то из них выбирается то подмножество, которое содержит наименьшее количество элементов.<p> </p><p class=\"left_margin\">Вам предлагается написать программу (укажите используемую версию языка программирования, например, <i>Borland Pascal 7.0</i>), которая будет обрабатывать результаты эксперимента, находя основное множество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи.<p> </p><p class=\"left_margin\">На вход программе в первой строке подаётся количество частиц N. В каждой из последующих <i>N</i> строк записано одно целое неотрицательное число, не превышающее 10<sup>9</sup>. Все <i>N</i> чисел различны. Хотя бы одно из чисел нечётно.<p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p><i>Пример входных данных:<p> </p><p class=\"left_margin\">3<p> </p><p class=\"left_margin\">123<p class=\"left_margin\">0 <p class=\"left_margin\">2</p></p></p></p></i><p> </p><p class=\"left_margin\">Программа должна вывести в порядке возрастания номера частиц, скорости которых принадлежат основному множеству данной серии. Нумерация частиц ведётся с единицы.<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:<p> </p><p class=\"left_margin\">1 3<p></p></p></i></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число.Программа читает все входные данные одни раз. не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретился (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное нечётное значение. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно.Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на другихязыках программирования. Пример правильной и эффективной программы на языке Паскаль:var n,i,j,k, c, min, a: longint;beginreadln(n);min := 1000000001; k := 0; j := 0; c := 0;for i := 1 to n do beginreadln(a);if a = 0 then j := i; if a mod 2 <> 0 then beginc := c + 1; if a < min then beginmin := a; k := i; end ;end; end;for i:=1 to n doif (i <> j) and ((c mod 2 <> 0) or (i <> k)) then write(i, ' ');end.  Пример правильной и эффективной программы на языке Бейсик:INPUT nmin = 0k = 0j = 0c = 0FOR i = 1 TO nINPUT aIF a = 0 THEN j = iIF a MOD 2 <> 0 THENc = c + 1IF (min = 0) OR (a < min) THENmin = ak = iEND IFEND IFNEXT iFOR i = 1 TO nIF (i <> j) AND ((c mod 2 <> 0) OR (i <> k)) THEN PRINT iNEXT iEND Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  min: integer; {минимальное нечётное число}  N: integer; {количество чисел}  sum: integer; {максимальная сумма}  i: integer;begin  readln(N);  min := 1000000001;  sum := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    sum := sum + a[i];    if (a[i] mod 2 <> 0) and (a[i]      min := a[i];    end;  if sum mod 2 = 0 then    for i := 1 to N do      if (a[i] <> min) and (a[i]<>0) then write(i, ' ');  if sum mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5471\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Основное множество состоит из всех значений скоростей, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число.<p class=\"left_margin\">Программа читает все входные данные одни раз. не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретился (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное нечётное значение. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно.<p class=\"left_margin\">Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других<p>языках программирования.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль:</b><p><div class=\"source_code lang_pascal\"><p>var n,i,j,k, c, min, a: longint;<p>begin<p>readln(n);<p>min := 1000000001;<p> k := 0;<p> j := 0;<p> c := 0;<p>for i := 1 to n <p>do<p> begin<p>readln(a);<p>if a = 0 then <p>j := i;<p> if a mod 2 &lt;&gt; 0<p> then begin<p>c := c + 1; <p>if a &lt; min<p> then begin<p>min := a; <p>k := i;<p> end ;<p>end;<p> end;<p>for i:=1 to n <p>do<p>if (i &lt;&gt; j) and ((c mod 2 &lt;&gt; 0) or (i &lt;&gt; k)) then write(i, ' ');<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p> <p><b>Пример правильной и эффективной программы на языке Бейсик:</b><p><div class=\"source_code lang_basic\"><p class=\"left_margin\">INPUT n<p>min = 0<p>k = 0<p>j = 0<p>c = 0<p class=\"left_margin\">FOR i = 1 TO n<p class=\"left_margin\">INPUT a<p class=\"left_margin\">IF a = 0 THEN j = i<p class=\"left_margin\">IF a MOD 2 &lt;&gt; 0 THEN<p>c = c + 1<p class=\"left_margin\">IF (min = 0) OR (a &lt; min) THEN<p>min = a<p>k = i<p class=\"left_margin\">END IF<p class=\"left_margin\">END IF<p class=\"left_margin\">NEXT i<p class=\"left_margin\">FOR i = 1 TO n<p class=\"left_margin\">IF (i &lt;&gt; j) AND ((c mod 2 &lt;&gt; 0) OR (i &lt;&gt; k)) THEN PRINT i<p class=\"left_margin\">NEXT i<p class=\"left_margin\">END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\"><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  min: integer; {минимальное нечётное число}<p>  N: integer; {количество чисел}<p>  sum: integer; {максимальная сумма}<p>  i: integer;<p>begin<p>  readln(N);<p>  min := 1000000001;<p>  sum := 0;<p>  for i := 1 to N do readln(a[i]);<p>  for i := 1 to N do begin<p>    sum := sum + a[i];<p>    if (a[i] mod 2 &lt;&gt; 0) and (a[i]<min) then<p=\"\">      min := a[i];<p>    end;<p>  if sum mod 2 = 0 then<p>    for i := 1 to N do<p>      if (a[i] &lt;&gt; min) and (a[i]&lt;&gt;0) then write(i, ' ');<p>  if sum mod 2 &lt;&gt; 0 then<p>    for i := 1 to N do<p>      if (a[i]&lt;&gt;0) then write(i, ' ');<p>end.</p></p></p></p></p></p></p></p></min)></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 30.05.2013. Ос­нов­ная волна. Сибирь. Ва­ри­ант 1.",
            "task_id": "5471"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 14, если:-\tодин из сомножителей делится на 14 (второй может быть любым) либо-\tни один из сомножителей не делится на 14. причём один из сомножителей делится на 2, а другой - на 7.Поэтому программа, вычисляющая кодовое число, может работать так.Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырех величин:М2 - самое большое чётное число, не кратное 7;М7 - самое большое число, кратное 7. но не кратное 2;М14 - самое большое число, кратное 14;МАХ - самое большое число среди всех элементов последовательности, отличное от M14 (если число М14 встретилось более одного раза и оно же является максимальным, то МАХ = M14).После того как все данные прочитаны, искомое кодовое слово вычисляется как максимум из произведений  M14*МАХ и М2*М7.Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль: var М2, М7, М14, R, MAX, dat, res, i, N: longint;beginM2 := 0; M7 := 0; M14 := 0; MAX := 0;readln(N);for i := 1 to N do beginreadln(dat);if ((dat mod 2) = 0) and ((dat mod 7) >0) and (dat > M2) then M2 := dat;if ((dat mod 7) = 0) and ((dat mod 2) > 0) and (dat > M7) then M7 := dat;if (dat mod 14 = 0) and (dat > M14) then beginif M14 > MAX then MAX := M14;M14 := datendelseif dat > MAX then MAX := dat;end;readln(R);if (M2*M7 < M14 *MAX) thenres := M14*MAXelseres := M2*M7;writeln('Вычисленное контрольное значение: ',res);if R = res then writeln('Контроль пройден')else writeln('Контроль не пройден');end. Пример правильной и эффективной программы на языке Бейсик: М14 = 0М2 = 0М7 = 0 МАХ = 0 INPUT NFOR I = 1 ТО N INPUT DATIF DAT MOD 2=0 AND DAT > M2 THEN M2 = DATELSEIF DAT MOD 7=0 AND DAT > M7 THEN M7 = DAT END IF END IFIF DAT MOD 14 = 0 AND DAT > M14 THENIF M14 > MAX THENMAX = M14END IF M14 = DAT ELSEIF DAT > MAX THENMAX = DAT END IF END IF NEXT I INPUT RIF M7 * M2 < M14 * MAX THEN RES = M14 * MAX ELSE RES = M7 * M2 END IFPRINT \"Вычисленное контрольное значение:\"; RES IF RES = R THENPRINT \"Контроль пройден\" ELSEPRINT \"Контроль не пройден\" END IF END Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];  readln(R);  writeln('Вычисленное контрольное значение: ', max);  if R=max then writeln('Контроль пройден')  else writeln('Контроль не пройден');end.",
            "parsed": "2019-04-29 21:13:13.639859",
            "question": "По каналу связи передаётся последовательность положительных целых чисел, все числа не превышают 1000. Количество чисел известно, но может быть очень велико. Затем передаётся контрольное значение последовательности — наибольшее число R, удовлетворяющее следующим условиям: 1)\tR — произведение двух различных переданных элементов последовательности («различные» означает, что не рассматриваются квадраты переданных чисел, произведения различных элементов последовательности, равных по величине, допускаются); 2)\tR делится на 14. Если такого числа R нет, то контрольное значение полагается равным 0. В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены. Напишите программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме: Вычисленное контрольное значение: ... Контроль пройден (или — Контроль не пройден) Перед текстом программы кратко опишите используемый Вами алгоритм решения. На вход программе в первой строке подаётся количество чисел N. В каждой из последующих N строк записано одно натуральное число, не превышающее 1000. В последней строке записано контрольное значение. Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б.  Пример входных данных: б 77 14 7 9 499 100 7700 Пример выходных данных для приведённого выше примера входных данных: Вычисленное контрольное значение: 7700 Контроль пройден",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body949123\" width=\"100%\"><p class=\"left_margin\">По каналу связи передаётся последовательность положительных целых чисел, все числа не превышают 1000. Количество чисел известно, но может быть очень велико. Затем передаётся контрольное значение последовательности — наибольшее число <i>R</i>, удовлетворяющее следующим условиям:<p> </p><p class=\"left_margin\">1)\t<i>R</i> — произведение двух различных переданных элементов последовательности («различные» означает, что не рассматриваются квадраты переданных чисел, произведения различных элементов последовательности, равных по величине, допускаются);<p> </p><p class=\"left_margin\">2)\t<i>R</i> делится на 14.<p> </p><p class=\"left_margin\">Если такого числа <i>R</i> нет, то контрольное значение полагается равным 0. В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.<p> </p><p class=\"left_margin\">Напишите программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме:<p> </p><p><i>Вычисленное контрольное значение: ...<p> </p><p class=\"left_margin\">Контроль пройден (</p></i>или<i> — Контроль не пройден)</i><p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите используемый Вами алгоритм решения.<p> </p><p class=\"left_margin\">На вход программе в первой строке подаётся количество чисел N. В каждой из последующих N строк записано одно натуральное число, не превышающее 1000. В последней строке записано контрольное значение.<p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p> </p><p><i>Пример входных данных:<p> </p><p>б<p> </p><p class=\"left_margin\">77 <p class=\"left_margin\">14 <p class=\"left_margin\">7 <p class=\"left_margin\">9<p> </p><p class=\"left_margin\">499 <p class=\"left_margin\">100 <p class=\"left_margin\">7700<p> </p><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p> </p><p class=\"left_margin\">Вычисленное контрольное значение: 7700 <p class=\"left_margin\">Контроль пройден</p></p></p></p></p></p></p></p></p></p></p></i></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 14, если:-\tодин из сомножителей делится на 14 (второй может быть любым) либо-\tни один из сомножителей не делится на 14. причём один из сомножителей делится на 2, а другой - на 7.Поэтому программа, вычисляющая кодовое число, может работать так.Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырех величин:М2 - самое большое чётное число, не кратное 7;М7 - самое большое число, кратное 7. но не кратное 2;М14 - самое большое число, кратное 14;МАХ - самое большое число среди всех элементов последовательности, отличное от M14 (если число М14 встретилось более одного раза и оно же является максимальным, то МАХ = M14).После того как все данные прочитаны, искомое кодовое слово вычисляется как максимум из произведений  M14*МАХ и М2*М7.Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль: var М2, М7, М14, R, MAX, dat, res, i, N: longint;beginM2 := 0; M7 := 0; M14 := 0; MAX := 0;readln(N);for i := 1 to N do beginreadln(dat);if ((dat mod 2) = 0) and ((dat mod 7) >0) and (dat > M2) then M2 := dat;if ((dat mod 7) = 0) and ((dat mod 2) > 0) and (dat > M7) then M7 := dat;if (dat mod 14 = 0) and (dat > M14) then beginif M14 > MAX then MAX := M14;M14 := datendelseif dat > MAX then MAX := dat;end;readln(R);if (M2*M7 < M14 *MAX) thenres := M14*MAXelseres := M2*M7;writeln('Вычисленное контрольное значение: ',res);if R = res then writeln('Контроль пройден')else writeln('Контроль не пройден');end. Пример правильной и эффективной программы на языке Бейсик: М14 = 0М2 = 0М7 = 0 МАХ = 0 INPUT NFOR I = 1 ТО N INPUT DATIF DAT MOD 2=0 AND DAT > M2 THEN M2 = DATELSEIF DAT MOD 7=0 AND DAT > M7 THEN M7 = DAT END IF END IFIF DAT MOD 14 = 0 AND DAT > M14 THENIF M14 > MAX THENMAX = M14END IF M14 = DAT ELSEIF DAT > MAX THENMAX = DAT END IF END IF NEXT I INPUT RIF M7 * M2 < M14 * MAX THEN RES = M14 * MAX ELSE RES = M7 * M2 END IFPRINT \"Вычисленное контрольное значение:\"; RES IF RES = R THENPRINT \"Контроль пройден\" ELSEPRINT \"Контроль не пройден\" END IF END Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];  readln(R);  writeln('Вычисленное контрольное значение: ', max);  if R=max then writeln('Контроль пройден')  else writeln('Контроль не пройден');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5503\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 14, если:<p>-\tодин из сомножителей делится на 14 (второй может быть любым) либо<p>-\tни один из сомножителей не делится на 14. причём один из сомножителей делится на 2, а другой - на 7.<p class=\"left_margin\">Поэтому программа, вычисляющая кодовое число, может работать так.<p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырех величин:<p class=\"left_margin\">М2 - самое большое чётное число, не кратное 7;<p class=\"left_margin\">М7 - самое большое число, кратное 7. но не кратное 2;<p class=\"left_margin\">М14 - самое большое число, кратное 14;<p class=\"left_margin\">МАХ - самое большое число среди всех элементов последовательности, отличное от M14 (если число М14 встретилось более одного раза и оно же является максимальным, то МАХ = M14).<p class=\"left_margin\">После того как все данные прочитаны, искомое кодовое слово вычисляется как максимум из произведений  M14*МАХ и М2*М7.<p class=\"left_margin\">Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.<p class=\"left_margin\">Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы. Допускаются решения, записанные на других языках программирования.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль:</b><p><div class=\"source_code lang_pascal\"> <p>var М2, М7, М14, R, MAX, dat, res, i, N: longint;<p>begin<p class=\"left_margin\">M2 := 0; M7 := 0; M14 := 0; MAX := 0;<p>readln(N);<p>for i := 1 to N do begin<p>readln(dat);<p>if ((dat mod 2) = 0) and ((dat mod 7) &gt;0) and (dat &gt; M2) then M2 := dat;<p>if ((dat mod 7) = 0) and ((dat mod 2) &gt; 0) and (dat &gt; M7) then M7 := dat;<p>if (dat mod 14 = 0) and (dat &gt; M14) then begin<p>if M14 &gt; MAX then MAX := M14;<p class=\"left_margin\">M14 := dat<p>end<p>else<p>if dat &gt; MAX then MAX := dat;<p>end;<p>readln(R);<p>if (M2*M7 &lt; M14 *MAX) then<p>res := M14*MAX<p>else<p>res := M2*M7;<p>writeln('Вычисленное контрольное значение: ',res);<p>if R = res then writeln('Контроль пройден')<p>else writeln('Контроль не пройден');<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div> <p><b>Пример правильной и эффективной программы на языке Бейсик:</b><p><div class=\"source_code lang_basic\"> <p class=\"left_margin\">М14 = 0<p class=\"left_margin\">М2 = 0<p class=\"left_margin\">М7 = 0 <p class=\"left_margin\">МАХ = 0<p> INPUT N<p class=\"left_margin\">FOR I = 1 ТО N<p> INPUT DAT<p class=\"left_margin\">IF DAT MOD 2=0 AND DAT &gt; M2 THEN <p class=\"left_margin\">M2 = DAT<p class=\"left_margin\">ELSE<p class=\"left_margin\">IF DAT MOD 7=0 AND DAT &gt; M7 THEN <p class=\"left_margin\">M7 = DAT <p class=\"left_margin\">END IF <p class=\"left_margin\">END IF<p class=\"left_margin\">IF DAT MOD 14 = 0 AND DAT &gt; M14 THEN<p class=\"left_margin\">IF M14 &gt; MAX <p class=\"left_margin\">THEN<p class=\"left_margin\">MAX = M14<p class=\"left_margin\">END IF <p class=\"left_margin\">M14 = DAT <p class=\"left_margin\">ELSE<p class=\"left_margin\">IF DAT &gt; MAX THEN<p class=\"left_margin\">MAX = DAT <p class=\"left_margin\">END IF <p class=\"left_margin\">END IF <p class=\"left_margin\">NEXT I <p class=\"left_margin\">INPUT R<p class=\"left_margin\">IF M7 * M2 &lt; M14 * MAX THEN <p class=\"left_margin\">RES = M14 * MAX <p class=\"left_margin\">ELSE <p class=\"left_margin\">RES = M7 * M2 <p class=\"left_margin\">END IF<p class=\"left_margin\">PRINT \"Вычисленное контрольное значение:\"; RES <p class=\"left_margin\">IF RES = R THEN<p class=\"left_margin\">PRINT \"Контроль пройден\" <p class=\"left_margin\">ELSE<p class=\"left_margin\">PRINT \"Контроль не пройден\" <p class=\"left_margin\">END IF <p class=\"left_margin\">END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество элементов последовательности}<p>  R: integer; {принимаемое контрольное значение}<p>  max: integer; {вычисляемое контрольное значение}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  max := 0;<p>  for i := 1 to N do read(a[i]);<p>  for i := 1 to N-1 do<p>    for j := i+1 to N do<p>      if (a[i]*a[j] &gt; max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];<p>  readln(R);<p>  writeln('Вычисленное контрольное значение: ', max);<p>  if R=max then writeln('Контроль пройден')<p>  else writeln('Контроль не пройден');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 30.05.2013. Ос­нов­ная волна. Урал. Ва­ри­ант 1.",
            "task_id": "5503"
        },
        {
            "answer": "Решение.Включим во множество все числа, большие единицы. С добавлением каждого нового такого числа произведение будет лишь увеличиваться. Добавлять числа, меньшие единицы, не следует, потому что из-за них произведение будет уменьшаться. Добавлять числа, равные единице, не стоит, потому что на произведение такие числа никак не повлияют, а количество чисел во множестве увеличат, что по условию нам совсем не нужно. Таким образом, выведем количество чисел, больших единицы, и минимальное из таких чисел. Требуется отдельно рассмотреть случай, когда в исходных данных нет чисел, превышающих единицу. В этом случае нужно включить во множество одно число – самое большое из данных. Больше к нему чисел брать нельзя, потому что от добавления новых чисел произведение будет лишь уменьшаться. Ниже приведён код решения на языке Pascal версии 2.6.2.var n, i, cntBig : longint;    cur, minBig, maxLit : real;beginmaxLit:=0;cntBig:=0;minBig := high(longint);readln(n);for i := 1 to n do  begin  readln(cur);  if cur > 1 then    begin    inc(cntBig);    if cur < minBig then      minBig := cur;    end else if cur > maxLit then      maxLit := cur;  end;if cntBig > 0 then  write(cntBig, ' ', minBig :1:1) else    write('1 ', maxLit :1:1);end. Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of real; {исходные данные}  N: integer; {количество элементов}  min: real; {минимальный элемент подмножества}  count: integer; {количество элементов в подмножестве}  i: integer;begin  readln(N);  min := 1000001;  count := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    if a[i] > 1 then count := count + 1;    if (a[i] < min) and (a[i]>1) then min := a[i];  end;  write(count, ' ', min);end.",
            "parsed": "2019-04-29 21:13:19.669235",
            "question": "Радиотелескоп пытается получать и анализировать сигналы, поступающие из различных участков космоса, при этом различные шумы переводятся в последовательность вещественных неотрицательных чисел, заданных с точностью до одного знака после десятичной точки. Чисел может быть очень много, но не может быть меньше трёх. Все числа не превосходят 1000000. В последовательности чисел, полученных из одного участка, выделяется основное подмножество элементов. Это такое непустое подмножество элементов, для которого произведение соответствующих чисел является максимально возможным. Если таких подмножеств несколько, то из них выбирается подмножество, которое содержит наименьшее количество элементов. Основное подмножество может содержать, например, как все элементы последовательности чисел, так и ровно один элемент. Если множество чисел содержит только одно число х, то произведением элементов этого множества считается число х. Напишите программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты, приходящие из одного участка, находя количество элементов в основном множестве и значение минимального элемента в этом множестве. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество сигналов N. В каждой из последующих N строк записано одно неотрицательное вещественное число с точностью до одного знака после десятичной точки.  Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Пример входных данных:6123.4 0.2 200.2 0.0 6.7 218.0 Программа должна вывести в одной строке сначала количество элементов в основном множестве, а затем — его минимальный элемент. Пример выходных данных для приведённого выше примера входных данных: 4 6.7.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948995\" width=\"100%\"><p class=\"left_margin\">Радиотелескоп пытается получать и анализировать сигналы, поступающие из различных участков космоса, при этом различные шумы переводятся в последовательность вещественных неотрицательных чисел, заданных с точностью до одного знака после десятичной точки. Чисел может быть очень много, но не может быть меньше трёх. Все числа не превосходят 1000000.<p> </p><p class=\"left_margin\">В последовательности чисел, полученных из одного участка, выделяется основное подмножество элементов. Это такое непустое подмножество элементов, для которого произведение соответствующих чисел является максимально возможным. Если таких подмножеств несколько, то из них выбирается подмножество, которое содержит наименьшее количество элементов. Основное подмножество может содержать, например, как все элементы последовательности чисел, так и ровно один элемент. Если множество чисел содержит только одно число х, то произведением элементов этого множества считается число <i>х</i>.<p> </p><p class=\"left_margin\">Напишите программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты, приходящие из одного участка, находя количество элементов в основном множестве и значение минимального элемента в этом множестве. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество сигналов N. В каждой из последующих N строк записано одно неотрицательное вещественное число с точностью до одного знака после десятичной точки. <p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p><i>Пример входных данных:</i><p class=\"left_margin\">6<p class=\"left_margin\">123.4 <p class=\"left_margin\">0.2 <p class=\"left_margin\">200.2 <p class=\"left_margin\">0.0 <p class=\"left_margin\">6.7 <p class=\"left_margin\">218.0<p> </p><p class=\"left_margin\">Программа должна вывести в одной строке сначала количество элементов в основном множестве, а затем — его минимальный элемент.<p> </p><p><i>Пример выходных данных для приведённого выше примера входных данных:</i> 4 6.7.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Включим во множество все числа, большие единицы. С добавлением каждого нового такого числа произведение будет лишь увеличиваться. Добавлять числа, меньшие единицы, не следует, потому что из-за них произведение будет уменьшаться. Добавлять числа, равные единице, не стоит, потому что на произведение такие числа никак не повлияют, а количество чисел во множестве увеличат, что по условию нам совсем не нужно. Таким образом, выведем количество чисел, больших единицы, и минимальное из таких чисел. Требуется отдельно рассмотреть случай, когда в исходных данных нет чисел, превышающих единицу. В этом случае нужно включить во множество одно число – самое большое из данных. Больше к нему чисел брать нельзя, потому что от добавления новых чисел произведение будет лишь уменьшаться. Ниже приведён код решения на языке Pascal версии 2.6.2.var n, i, cntBig : longint;    cur, minBig, maxLit : real;beginmaxLit:=0;cntBig:=0;minBig := high(longint);readln(n);for i := 1 to n do  begin  readln(cur);  if cur > 1 then    begin    inc(cntBig);    if cur < minBig then      minBig := cur;    end else if cur > maxLit then      maxLit := cur;  end;if cntBig > 0 then  write(cntBig, ' ', minBig :1:1) else    write('1 ', maxLit :1:1);end. Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of real; {исходные данные}  N: integer; {количество элементов}  min: real; {минимальный элемент подмножества}  count: integer; {количество элементов в подмножестве}  i: integer;begin  readln(N);  min := 1000001;  count := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    if a[i] > 1 then count := count + 1;    if (a[i] < min) and (a[i]>1) then min := a[i];  end;  write(count, ' ', min);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol5631\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Включим во множество все числа, большие единицы. С добавлением каждого нового такого числа произведение будет лишь увеличиваться. Добавлять числа, меньшие единицы, не следует, потому что из-за них произведение будет уменьшаться. Добавлять числа, равные единице, не стоит, потому что на произведение такие числа никак не повлияют, а количество чисел во множестве увеличат, что по условию нам совсем не нужно. Таким образом, выведем количество чисел, больших единицы, и минимальное из таких чисел.<p> </p><p class=\"left_margin\">Требуется отдельно рассмотреть случай, когда в исходных данных нет чисел, превышающих единицу. В этом случае нужно включить во множество одно число – самое большое из данных. Больше к нему чисел брать нельзя, потому что от добавления новых чисел произведение будет лишь уменьшаться.<p> </p><p class=\"left_margin\">Ниже приведён код решения на языке Pascal версии 2.6.2.<p><div class=\"source_code lang_pascal\"><p>var n, i, cntBig : longint;<p>    cur, minBig, maxLit : real;<p>begin<p>maxLit:=0;<p>cntBig:=0;<p>minBig := high(longint);<p>readln(n);<p>for i := 1 to n do<p>  begin<p>  readln(cur);<p>  if cur &gt; 1 then<p>    begin<p>    inc(cntBig);<p>    if cur &lt; minBig then<p>      minBig := cur;<p>    end else if cur &gt; maxLit then<p>      maxLit := cur;<p>  end;<p>if cntBig &gt; 0 then<p>  write(cntBig, ' ', minBig :1:1) else<p>    write('1 ', maxLit :1:1);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\">Пример решения задачи А на языке Паскаль.<pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of real; {исходные данные}<p>  N: integer; {количество элементов}<p>  min: real; {минимальный элемент подмножества}<p>  count: integer; {количество элементов в подмножестве}<p>  i: integer;<p>begin<p>  readln(N);<p>  min := 1000001;<p>  count := 0;<p>  for i := 1 to N do readln(a[i]);<p>  for i := 1 to N do begin<p>    if a[i] &gt; 1 then count := count + 1;<p>    if (a[i] &lt; min) and (a[i]&gt;1) then min := a[i];<p>  end;<p>  write(count, ' ', min);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 30.05.2013. Ос­нов­ная волна. Сибирь. Ва­ри­ант 3.",
            "task_id": "5631"
        },
        {
            "answer": "Решение.Произведение двух чисел будет кратно 7 и не кратно 49 в том и только в том случае, когда один из сомножителей делится на 7 и при этом не делится на 49, а второй — не делится на 7. Произведение будет максимальным, если оба сомножителя будут максимально возможными в своих группах. Искомое произведение не существует (контрольное значение считается равным 1), если в одной из указанных групп не окажется ни одного числа.Программа читает входные данные, не запоминая числа в массиве, и находит два максимальных значения: максимум из чисел, кратных 7 и при этом не кратных 49, и максимум из чисел, не кратных 7. Затем программа вычисляет контрольное значение, равное произведению этих двух максимумов, и сравнивает его с введённым контрольным значением.  Пример правильной и эффективной программы на языке Паскаль. program с4; vark: integer;\t{введенное число}n: integer;\t{количество чисел} pin: integer;{введенное контрольное значение}m: integer;\t{максимум среди чисел, не кратных 7}m7: integer;\t{максимум среди чисел, кратных 7 и не кратных 49}р: integer;\t{вычисленное контрольное значение} beginm:=0; m7:=0;n: =0 ;\t\twhile true do\tbegin\treadln(k);\t\tif k=0 then\tbreak ,n:=n+1;\t\tif (k mod 7 <> 0) and (k>m)\tthen m:=k;if (k mod 7 = 0) and (k mod 49 <> 0) and (k>m7)then m7:= k ;\tend;\t\treadln(pin);\t\tp:=m*m7;\t\tif p=0 then p: = 1;\twriteln('Введено чисел: ',n);\twriteln('Контрольное значение ',pin);writeln('Вычисленное значение ' ,P) ?write ( 'Значения ');if p<>pin then write ('не ') ;\twriteln('совпали') ;\tend.\t\t Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  count: integer; {количество введёных чисел}  i, j: integer;begin  count := 0;  max := 1;  while true do begin    readln(a[count+1]);    if a[count+1] = 0 then break;    count := count + 1;  end;  for i := 1 to count − 1 do    for j := i + 1 to count do      if (a[i]*a[j] mod 7 = 0) and (a[i]*a[j] mod 49 <> 0) and (a[i]*a[j] > max) then max := a[i]*a[j];  readln(R);  writeln('Введено чисел: ', count);  writeln('Принятое контрольное значение: ', R);  writeln('Вычисленное контрольное значение: ', max);  if R=max then writeln('Значения совпали')  else writeln('Значения не совпали');end.",
            "parsed": "2019-04-29 21:13:14.006263",
            "question": "По каналу связи передаются данные в виде последовательности положительных целых чисел. Количество чисел заранее неизвестно, но не менее двух, признаком конца данных считается число 0. После данных передаётся контрольное значение. Оно равно такому максимально возможному произведению двух чисел из переданного набора, которое делится на 7, но не делится на 49. Если такое произведение получить нельзя, контрольное значение считается равным 1. Напишите эффективную, в том числе по памяти, программу, которая будет моделировать процесс приёма данных. Программа должна ввести все числа и контрольное значение и напечатать краткий отчёт, включающий количество принятых чисел, принятое контрольное значение, вычисленное контрольное значение и вывод о совпадении значений. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.  Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б. Описание входных данных. В каждой строке исходных данных содержится одно целое число. Сначала идут строки с основными данными — положительными числами, затем число 0 (признак окончания данных), в последней строке — контрольное значение.  Программа должна вывести отчёт по форме, приведённой ниже в примере.  Пример входных данных:  6 7 8 9 0 64  Пример выходных данных для приведённого выше примера входных данных:  Введено чисел: 4 Контрольное значение: 64 Вычисленное значение: 63 Значения не совпали",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947910\" width=\"100%\"><p class=\"left_margin\">По каналу связи передаются данные в виде последовательности положительных целых чисел. Количество чисел заранее неизвестно, но не менее двух, признаком конца данных считается число 0. После данных передаётся контрольное значение. Оно равно такому максимально возможному произведению двух чисел из переданного набора, которое делится на 7, но не делится на 49. Если такое произведение получить нельзя, контрольное значение считается равным 1. <p class=\"left_margin\">Напишите эффективную, в том числе по памяти, программу, которая будет моделировать процесс приёма данных. Программа должна ввести все числа и контрольное значение и напечатать краткий отчёт, включающий количество принятых чисел, принятое контрольное значение, вычисленное контрольное значение и вывод о совпадении значений. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. <p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p><b>Описание входных данных.</b><p> </p><p class=\"left_margin\">В каждой строке исходных данных содержится одно целое число. Сначала идут строки с основными данными — положительными числами, затем число 0 (признак окончания данных), в последней строке — контрольное значение. <p> </p><p class=\"left_margin\">Программа должна вывести отчёт по форме, приведённой ниже в примере. <p> </p><p class=\"left_margin\">Пример входных данных: <p> </p><p class=\"left_margin\">6 <p class=\"left_margin\">7 <p class=\"left_margin\">8 <p class=\"left_margin\">9 <p class=\"left_margin\">0 <p class=\"left_margin\">64 <p> </p><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных: <p> </p><p class=\"left_margin\">Введено чисел: 4 <p class=\"left_margin\">Контрольное значение: 64 <p class=\"left_margin\">Вычисленное значение: 63 <p class=\"left_margin\">Значения не совпали</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел будет кратно 7 и не кратно 49 в том и только в том случае, когда один из сомножителей делится на 7 и при этом не делится на 49, а второй — не делится на 7. Произведение будет максимальным, если оба сомножителя будут максимально возможными в своих группах. Искомое произведение не существует (контрольное значение считается равным 1), если в одной из указанных групп не окажется ни одного числа.Программа читает входные данные, не запоминая числа в массиве, и находит два максимальных значения: максимум из чисел, кратных 7 и при этом не кратных 49, и максимум из чисел, не кратных 7. Затем программа вычисляет контрольное значение, равное произведению этих двух максимумов, и сравнивает его с введённым контрольным значением.  Пример правильной и эффективной программы на языке Паскаль. program с4; vark: integer;\t{введенное число}n: integer;\t{количество чисел} pin: integer;{введенное контрольное значение}m: integer;\t{максимум среди чисел, не кратных 7}m7: integer;\t{максимум среди чисел, кратных 7 и не кратных 49}р: integer;\t{вычисленное контрольное значение} beginm:=0; m7:=0;n: =0 ;\t\twhile true do\tbegin\treadln(k);\t\tif k=0 then\tbreak ,n:=n+1;\t\tif (k mod 7 <> 0) and (k>m)\tthen m:=k;if (k mod 7 = 0) and (k mod 49 <> 0) and (k>m7)then m7:= k ;\tend;\t\treadln(pin);\t\tp:=m*m7;\t\tif p=0 then p: = 1;\twriteln('Введено чисел: ',n);\twriteln('Контрольное значение ',pin);writeln('Вычисленное значение ' ,P) ?write ( 'Значения ');if p<>pin then write ('не ') ;\twriteln('совпали') ;\tend.\t\t Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  count: integer; {количество введёных чисел}  i, j: integer;begin  count := 0;  max := 1;  while true do begin    readln(a[count+1]);    if a[count+1] = 0 then break;    count := count + 1;  end;  for i := 1 to count − 1 do    for j := i + 1 to count do      if (a[i]*a[j] mod 7 = 0) and (a[i]*a[j] mod 49 <> 0) and (a[i]*a[j] > max) then max := a[i]*a[j];  readln(R);  writeln('Введено чисел: ', count);  writeln('Принятое контрольное значение: ', R);  writeln('Вычисленное контрольное значение: ', max);  if R=max then writeln('Значения совпали')  else writeln('Значения не совпали');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6202\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел будет кратно 7 и не кратно 49 в том и только в том случае, когда один из сомножителей делится на 7 и при этом не делится на 49, а второй — не делится на 7. Произведение будет максимальным, если оба сомножителя будут максимально возможными в своих группах. Искомое произведение не существует (контрольное значение считается равным 1), если в одной из указанных групп не окажется ни одного числа.<p class=\"left_margin\">Программа читает входные данные, не запоминая числа в массиве, и находит два максимальных значения: максимум из чисел, кратных 7 и при этом не кратных 49, и максимум из чисел, не кратных 7. Затем программа вычисляет контрольное значение, равное произведению этих двух максимумов, и сравнивает его с введённым контрольным значением. <p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль.</b><p> </p><p>program с4; <p>var<p>k: integer;\t{введенное число}<p>n: integer;\t{количество чисел} pin: integer;{введенное контрольное значение}<p>m: integer;\t{максимум среди чисел, не кратных 7}<p>m7: integer;\t{максимум среди чисел, кратных 7 и не кратных 49}<p>р: integer;\t{вычисленное контрольное значение}<p> </p><p>begin<p>m:=0; m7:=0;<p>n: =0 ;\t\t<p>while true do\tbegin\t<p>readln(k);\t\t<p>if k=0 then\tbreak ,<p>n:=n+1;\t\t<p>if (k mod 7 &lt;&gt; 0) and (k&gt;m)\tthen m:=k;<p>if (k mod 7 = 0) and (k mod 49 &lt;&gt; 0) and (k&gt;m7)<p>then m7:= k ;\t<p>end;\t\t<p>readln(pin);\t\t<p>p:=m*m7;\t\t<p>if p=0 then p: = 1;\t<p>writeln('Введено чисел: ',n);\t<p>writeln('Контрольное значение ',pin);<p>writeln('Вычисленное значение ' ,P) ?<p>write ( 'Значения ');<p>if p&lt;&gt;pin then write ('не ') ;\t<p>writeln('совпали') ;\t<p>end.\t\t<p> </p><p><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество элементов последовательности}<p>  R: integer; {принимаемое контрольное значение}<p>  max: integer; {вычисляемое контрольное значение}<p>  count: integer; {количество введёных чисел}<p>  i, j: integer;<p>begin<p>  count := 0;<p>  max := 1;<p>  while true do begin<p>    readln(a[count+1]);<p>    if a[count+1] = 0 then break;<p>    count := count + 1;<p>  end;<p>  for i := 1 to count − 1 do<p>    for j := i + 1 to count do<p>      if (a[i]*a[j] mod 7 = 0) and (a[i]*a[j] mod 49 &lt;&gt; 0) and (a[i]*a[j] &gt; max) then max := a[i]*a[j];<p>  readln(R);<p>  writeln('Введено чисел: ', count);<p>  writeln('Принятое контрольное значение: ', R);<p>  writeln('Вычисленное контрольное значение: ', max);<p>  if R=max then writeln('Значения совпали')<p>  else writeln('Значения не совпали');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "6202"
        },
        {
            "answer": "Решение.Основное подмножество состоит из всех значений сигналов, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число. Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное из них. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик:var n,i,j,k,c,min,a: longint; begin  readln(n);  min := 1000000001;  k := 0;  j := 0;  c := 0;  for i := 1 to n do  begin  readln(a);  if a = 0 then j := i;  if a mod 2 <> 0 then  begin  c := c + 1;  if a < min then  begin  min := a;  k := i;  end  end  end;  for i :=1 to n do  if (i <> j) and ((c mod 2 <> 0) or (i <> k)) then  write(i,' '); end.  INPUT n  min = 0  k = 0  j = 0  c = 0  FOR i = 1 TO n  INPUT a  IF a = 0 THEN j = i  IF a MOD 2 <> 0 THEN  c = c + 1  IF (min = 0) OR (a < min) THEN  min = a  k = i  END IF  END IF  NEXT i  FOR i = 1 TO n  IF (i <> j) AND ((c MOD 2 <>0) OR (i <> k)) THEN  PRINT i  NEXT i  END Пример решения задачи A на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  min: integer; {минимальное нечётное число}  N: integer; {количество чисел}  sum: integer; {максимальная сумма}  i: integer;begin  readln(N);  min := 1000000001;  sum := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    sum := sum + a[i];    if (a[i] mod 2 <> 0) and (a[i]      min := a[i];    end;  if sum mod 2 = 0 then    for i := 1 to N do      if (a[i] <> min) and (a[i]<>0) then write(i, ' ');  if sum mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "parsed": "2019-04-29 21:13:20.216383",
            "question": "Радиотелескоп пытается получать и анализировать сигналы, поступающие из различных участков космоса, при этом различные шумы переводятся в последовательность целых неотрицательных чисел. Чисел может быть очень много, но не может быть меньше трёх. Все числа различны. Хотя бы одно из чисел нечётно. В данных, полученных из одного участка, выделяется основное подмножество чисел. Это непустое подмножество чисел (в него могут войти как одно число, так и все поступившие числа), такое, что их сумма нечётна и максимальна среди всех возможных непустых подмножеств с нечётной суммой. Если таких подмножеств несколько, то из них выбирается то подмножество, которое содержит наименьшее количество элементов. Вам предлагается написать программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты, приходящие из одного участка, находя основное подмножество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество сигналов N. В каждой из последующих N строк записано одно целое неотрицательное число, не превышающее 109. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Пример входных данных: 312302 Программа должна вывести в порядке возрастания номера сигналов, которые принадлежат основному подмножеству данного участка. Нумерация элементов последовательности ведётся с единицы. Пример выходных данных для приведённого выше примера входных данных: 1 3.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947835\" width=\"100%\"><p class=\"left_margin\">Радиотелескоп пытается получать и анализировать сигналы, поступающие из различных участков космоса, при этом различные шумы переводятся в последовательность целых неотрицательных чисел. Чисел может быть очень много, но не может быть меньше трёх. Все числа различны. Хотя бы одно из чисел нечётно. <p class=\"left_margin\">В данных, полученных из одного участка, выделяется основное подмножество чисел. Это непустое подмножество чисел (в него могут войти как одно число, так и все поступившие числа), такое, что их сумма нечётна и максимальна среди всех возможных непустых подмножеств с нечётной суммой. Если таких подмножеств несколько, то из них выбирается то подмножество, которое содержит наименьшее количество элементов. <p class=\"left_margin\">Вам предлагается написать программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет обрабатывать результаты, приходящие из одного участка, находя основное подмножество. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество сигналов <i>N</i>. В каждой из последующих <i>N</i> строк записано одно целое неотрицательное число, не превышающее 10<sup>9</sup>.<p> </p><p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание — 0 баллов.<p class=\"left_margin\">Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла.<p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p> </p><p><i>Пример входных данных:</i><p> </p><p class=\"left_margin\">3<p class=\"left_margin\">123<p class=\"left_margin\">0<p class=\"left_margin\">2<p> </p><p class=\"left_margin\">Программа должна вывести в порядке возрастания номера сигналов, которые принадлежат основному подмножеству данного участка. Нумерация элементов последовательности ведётся с единицы. <i>Пример выходных данных для приведённого выше примера входных данных:</i> 1 3.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Основное подмножество состоит из всех значений сигналов, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число. Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное из них. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик:var n,i,j,k,c,min,a: longint; begin  readln(n);  min := 1000000001;  k := 0;  j := 0;  c := 0;  for i := 1 to n do  begin  readln(a);  if a = 0 then j := i;  if a mod 2 <> 0 then  begin  c := c + 1;  if a < min then  begin  min := a;  k := i;  end  end  end;  for i :=1 to n do  if (i <> j) and ((c mod 2 <> 0) or (i <> k)) then  write(i,' '); end.  INPUT n  min = 0  k = 0  j = 0  c = 0  FOR i = 1 TO n  INPUT a  IF a = 0 THEN j = i  IF a MOD 2 <> 0 THEN  c = c + 1  IF (min = 0) OR (a < min) THEN  min = a  k = i  END IF  END IF  NEXT i  FOR i = 1 TO n  IF (i <> j) AND ((c MOD 2 <>0) OR (i <> k)) THEN  PRINT i  NEXT i  END Пример решения задачи A на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  min: integer; {минимальное нечётное число}  N: integer; {количество чисел}  sum: integer; {максимальная сумма}  i: integer;begin  readln(N);  min := 1000000001;  sum := 0;  for i := 1 to N do readln(a[i]);  for i := 1 to N do begin    sum := sum + a[i];    if (a[i] mod 2 <> 0) and (a[i]      min := a[i];    end;  if sum mod 2 = 0 then    for i := 1 to N do      if (a[i] <> min) and (a[i]<>0) then write(i, ' ');  if sum mod 2 <> 0 then    for i := 1 to N do      if (a[i]<>0) then write(i, ' ');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6279\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Основное подмножество состоит из всех значений сигналов, кроме 0, если он встречается, и кроме минимального нечётного значения, если таких значений чётное число. <p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N. Во время чтения данных запоминается номер 0, если он встретится (по условию все значения различны, поэтому 0 встречается не больше одного раза), подсчитывается количество нечётных значений и ищется минимальное из них. После окончания ввода распечатываются все номера, кроме номера 0 и номера минимального нечётного значения, но только в случае, если их количество чётно. <p class=\"left_margin\">Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования.<p> </p><center><p><table style=\"margin:auto\"><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Бейсик:</th><tr><td><div class=\"source_code lang_pascal\"><p>var n,i,j,k,c,min,a: longint; <p>begin <p> readln(n); <p> min := 1000000001; <p> k := 0; <p> j := 0; <p> c := 0; <p> for i := 1 to n do <p> begin <p> readln(a); <p> if a = 0 then j := i; <p> if a mod 2 &lt;&gt; 0 then <p> begin <p> c := c + 1; <p> if a &lt; min then <p> begin <p> min := a; <p> k := i; <p> end <p> end <p> end; <p> for i :=1 to n do <p> if (i &lt;&gt; j) and ((c mod 2 &lt;&gt; 0) or (i &lt;&gt; k)) then <p> write(i,' '); <p>end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> INPUT n <p> min = 0 <p> k = 0 <p> j = 0 <p> c = 0 <p> FOR i = 1 TO n <p> INPUT a <p> IF a = 0 THEN j = i <p> IF a MOD 2 &lt;&gt; 0 THEN <p> c = c + 1 <p> IF (min = 0) OR (a &lt; min) THEN <p> min = a <p> k = i <p> END IF <p> END IF <p> NEXT i <p> FOR i = 1 TO n <p> IF (i &lt;&gt; j) AND ((c MOD 2 &lt;&gt;0) OR (i &lt;&gt; k)) THEN <p> PRINT i <p> NEXT i <p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center><p class=\"left_margin\">Пример решения задачи A на языке Паскаль.<pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  min: integer; {минимальное нечётное число}<p>  N: integer; {количество чисел}<p>  sum: integer; {максимальная сумма}<p>  i: integer;<p>begin<p>  readln(N);<p>  min := 1000000001;<p>  sum := 0;<p>  for i := 1 to N do readln(a[i]);<p>  for i := 1 to N do begin<p>    sum := sum + a[i];<p>    if (a[i] mod 2 &lt;&gt; 0) and (a[i]<min) then<p=\"\">      min := a[i];<p>    end;<p>  if sum mod 2 = 0 then<p>    for i := 1 to N do<p>      if (a[i] &lt;&gt; min) and (a[i]&lt;&gt;0) then write(i, ' ');<p>  if sum mod 2 &lt;&gt; 0 then<p>    for i := 1 to N do<p>      if (a[i]&lt;&gt;0) then write(i, ' ');<p>end.</p></p></p></p></p></p></p></p></min)></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 501.",
            "task_id": "6279"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а подсчитывая в массиве номеров задач, сколько запросов было по каждой из них. После окончания ввода производится одновременная сортировка массивов номеров задач и количества запросов, отданных за них, в порядке убывания количества запросов; затем выводится список задач, которые встретились в списке запросов хотя бы один раз, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer;  Count: array[1..12] of integer;  Names: array[1..12] of integer;  Begin  For i := 1 to 12 do  begin  Count[i] := 0;  Names[i] := i;  end;  ReadLn(N); { Считываем количество запросов}  for i:=1 to N do  begin  ReadLn(t); {считали очередной запрос}  Count[t] := Count[t] + 1;  end; {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=12 downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t;  end;  for i:=1 to 12 do  if Count[i] > 0 then  WriteLn(Names[i], ' ', Count[i]);  end.  DIM N, i, j, t AS INTEGER  DIM Count(12) AS INTEGER   DIM Names(12) AS INTEGER  FOR i = 1 TO 12  Count(i) = 0  Names(i) = i  NEXT i  INPUT N ' Считываем количество запросов  FOR i = 1 TO N  INPUT t ' считали задачу  'Подсчитываем её  Count(t) = Count(t) + 1  NEXT i  'Сортируем массивы Names и Count в порядке убывания 'значений массива Count  FOR i = 12 TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t  END IF  NEXT j  NEXT i  FOR i = 1 TO 12  IF Count(i) > 0 THEN PRINT Names(i), Count(i)   NEXT i  END  ",
            "parsed": "2019-04-29 21:14:22.996945",
            "question": "В командных олимпиадах по программированию для решения предлагается не больше 12 задач. Команда может решать предложенные задачи в любом порядке. Подготовленные решения команда посылает в единую проверяющую систему соревнований. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет статистически обрабатывать пришедшие запросы на проверку, чтобы определить популярность той или иной задачи. Следует учитывать, что количество запросов в списке может быть очень велико, так как многие соревнования проходят с использованием сети Интернет. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших запросов N. В каждой из последующих N строк записан номер задачи от 1 до 12. Пример входных данных: 6 1 2 1 1 5 2 Программа должна напечатать сведения о количестве запросов на проверку для каждой задачи. Сведения о каждой задаче выводятся в отдельной строке: сначала выводится номер задачи, потом — соответствующее количество запросов. Сведения о задачах, которые не поступали на проверку, выводить не нужно. Строки должны быть упорядочены по убыванию количества запросов, при равенстве количества запросов — по возрастанию номеров задач. Пример выходных данных для приведённого выше примера входных данных: 1 3 2 2 5 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947763\" width=\"100%\"><p class=\"left_margin\">В командных олимпиадах по программированию для решения предлагается не больше 12 задач. Команда может решать предложенные задачи в любом порядке. Подготовленные решения команда посылает в единую проверяющую систему соревнований. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет статистически обрабатывать пришедшие запросы на проверку, чтобы определить популярность той или иной задачи. Следует учитывать, что количество запросов в списке может быть очень велико, так как многие соревнования проходят с использованием сети Интернет. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших запросов N. В каждой из последующих N строк записан номер задачи от 1 до 12. <i>Пример входных данных:</i><p> </p><p class=\"left_margin\">6 <p class=\"left_margin\">1 <p class=\"left_margin\">2 <p class=\"left_margin\">1 <p class=\"left_margin\">1 <p class=\"left_margin\">5 <p class=\"left_margin\">2<p> </p><p class=\"left_margin\">Программа должна напечатать сведения о количестве запросов на проверку для каждой задачи. Сведения о каждой задаче выводятся в отдельной строке: сначала выводится номер задачи, потом — соответствующее количество запросов. Сведения о задачах, которые не поступали на проверку, выводить не нужно. Строки должны быть упорядочены по убыванию количества запросов, при равенстве количества запросов — по возрастанию номеров задач. <i>Пример выходных данных для приведённого выше примера входных данных:</i><p> </p><p class=\"left_margin\">1 3 <p class=\"left_margin\">2 2 <p class=\"left_margin\">5 1</p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а подсчитывая в массиве номеров задач, сколько запросов было по каждой из них. После окончания ввода производится одновременная сортировка массивов номеров задач и количества запросов, отданных за них, в порядке убывания количества запросов; затем выводится список задач, которые встретились в списке запросов хотя бы один раз, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer;  Count: array[1..12] of integer;  Names: array[1..12] of integer;  Begin  For i := 1 to 12 do  begin  Count[i] := 0;  Names[i] := i;  end;  ReadLn(N); { Считываем количество запросов}  for i:=1 to N do  begin  ReadLn(t); {считали очередной запрос}  Count[t] := Count[t] + 1;  end; {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=12 downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t;  end;  for i:=1 to 12 do  if Count[i] > 0 then  WriteLn(Names[i], ' ', Count[i]);  end.  DIM N, i, j, t AS INTEGER  DIM Count(12) AS INTEGER   DIM Names(12) AS INTEGER  FOR i = 1 TO 12  Count(i) = 0  Names(i) = i  NEXT i  INPUT N ' Считываем количество запросов  FOR i = 1 TO N  INPUT t ' считали задачу  'Подсчитываем её  Count(t) = Count(t) + 1  NEXT i  'Сортируем массивы Names и Count в порядке убывания 'значений массива Count  FOR i = 12 TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t  END IF  NEXT j  NEXT i  FOR i = 1 TO 12  IF Count(i) > 0 THEN PRINT Names(i), Count(i)   NEXT i  END  ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6351\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а подсчитывая в массиве номеров задач, сколько запросов было по каждой из них. После окончания ввода производится одновременная сортировка массивов номеров задач и количества запросов, отданных за них, в порядке убывания количества запросов; затем выводится список задач, которые встретились в списке запросов хотя бы один раз, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования<p> </p><center><p><table style=\"margin:auto\"><tr><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Бейсик:</th></tr><tr><td><div class=\"source_code lang_pascal\"><p> Var n, Num, i, j, t: integer; <p> Count: array[1..12] of integer; <p> Names: array[1..12] of integer; <p> Begin <p> For i := 1 to 12 do <p> begin <p> Count[i] := 0; <p> Names[i] := i; <p> end; <p> ReadLn(N); { Считываем количество запросов} <p> for i:=1 to N do <p> begin <p> ReadLn(t); {считали очередной запрос} <p> Count[t] := Count[t] + 1; <p> end; <p>{Сортируем массивы Names и Count в порядке убывания значений массива Count} <p> for i:=12 downto 2 do <p> for j:=2 to i do if Count[j-1] &lt; Count[j] then <p> begin <p> t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; <p> t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t; <p> end; <p> for i:=1 to 12 do <p> if Count[i] &gt; 0 then <p> WriteLn(Names[i], ' ', Count[i]); <p> end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> DIM N, i, j, t AS INTEGER <p> DIM Count(12) AS INTEGER  <p> DIM Names(12) AS INTEGER <p> FOR i = 1 TO 12 <p> Count(i) = 0 <p> Names(i) = i <p> NEXT i <p> INPUT N '<p> Считываем количество запросов <p> FOR i = 1 TO N <p> INPUT t '<p> считали задачу <p> 'Подсчитываем её <p> Count(t) = Count(t) + 1 <p> NEXT i <p> 'Сортируем массивы Names и Count в порядке убывания<p> 'значений массива Count <p> FOR i = 12 TO 2 STEP -1 <p> FOR j = 2 TO i <p> IF Count(j - 1) &lt; Count(j) THEN <p> t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t <p> t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t <p> END IF <p> NEXT j <p> NEXT i <p> FOR i = 1 TO 12 <p> IF Count(i) &gt; 0 THEN PRINT Names(i), Count(i)  <p> NEXT i <p> END <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 601.",
            "task_id": "6351"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, i, j, t: integer;  Count, Names: array[1..16] of integer;  Begin  For i := 1 to 16 do  begin  Count[i] := 0;  Names[i] := i;  end;  ReadLn(N); {Считываем количество голосов}  for i:=1 to N do  begin  ReadLn(t); {считали очередную пару}  Count[t] := Count[t] + 1;{подсчитываем её}  end; {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=16 downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t;  end;  for i:=1 to 16 do  if Count[i] > 0 then  writeLn(Names[i], ' ', Count[i]);  end.  DIM N, i, j, t AS INTEGER  DIM Count(16) AS INTEGER  DIM Names(16) AS INTEGER  FOR i = 1 TO 16  Count(i) = 0  Names(i) = i  NEXT i  INPUT N ' Считываем количество голосов  FOR i = 1 TO N  INPUT t 'считали пару  'Подсчитываем её  Count(t) = Count(t) + 1  NEXT i  'Сортируем массивы Names и Count в порядке убывания  'значений массива Count  FOR i = 16 TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t  END IF  NEXT j  NEXT i  FOR i = 1 TO 16  IF Count(i) > 0 THEN PRINT Names(i), Count(i)  NEXT i  END    Приведём решение Даниила Доценко, Pascal ABC. var a:array [1..16] of integer;k,i,n,j:integer;begin  readln(n);  for i:=1 to n do begin    readln(k);    a[k]:=a[k]+1;  end;  k:=0;  for i:=1 to 16 do    if a[i]>k then k:=a[i];    for j:=k downto 1 do      for i:=1 to 16 do        if j=a[i] then writeln(i,' ',a[i]);end.  Приведём решение Сергея Мартынова, Python 3.a=[0 for x in range(0,16)]n=int(input())for i in range(0,n):    k=int(input())-1    a[k]+=1for c in range(0,16):    maxi=a.index(max(a))    if maxi != 0:        print (maxi+1,' ',a[maxi])        a[maxi]=-1Пример решения задачи А на языке Паскаль.var  a: array[1..16] of integer; {исходные данные}  val: integer; {пара}  lenght: integer; {количество голосов за пару}  i, j, k: integer;begin  for i := 1 to 15 do read(a[i]);  for i:=1 to 15-1 do    for j:=1 to 15-i do      if a[j] < a[j+1] then begin        k := a[j];        a[j] := a[j+1];        a[j+1] := k;      end;  lenght := 1;  for i := 1 to 15 do    if a[i]=a[i+1] then      lenght := lenght + 1    else begin    writeln(a[i], ' ', lenght);    lenght := 1;    end;end.",
            "parsed": "2019-04-29 21:13:26.973097",
            "question": "В телевизионном танцевальном марафоне с определением победителя с помощью телезрителей после каждого тура объявляется sms-голосование, в котором зрители указывают наиболее понравившуюся им пару из максимум 16 пар, которые участвуют в проекте. Вам предлагается написать программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде номеров пар (каждый элемент списка соответствует одному sms-сообщению).  Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется набор данных, состоящий из 15 чисел. Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных, состоящий из целых чисел. Набор может быть очень большим.Напишите программу для решения этой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записан номер пары от 1 до 16.Пример входных данных: 4 2 16 3 2 Программа должна вывести список всех пар, встречающихся в списке, в порядке убывания (невозрастания) количества голосов, отданных за ту или иную пару, с указанием количества отданных за неё голосов. При этом каждая пара должна быть выведена ровно один раз вне зависимости от того, сколько раз она встречается в списке. Пример выходных данных для приведённого выше примера входных данных: 2 2 3 1 16 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948184\" width=\"100%\"><p class=\"left_margin\">В телевизионном танцевальном марафоне с определением победителя с помощью телезрителей после каждого тура объявляется sms-голосование, в котором зрители указывают наиболее понравившуюся им пару из максимум 16 пар, которые участвуют в проекте. Вам предлагается написать программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде номеров пар (каждый элемент списка соответствует одному sms-сообщению). <p> </p><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется набор данных, состоящий из 15 чисел. <p class=\"left_margin\">Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных, состоящий из целых чисел. Набор может быть очень большим.<p class=\"left_margin\">Напишите программу для решения этой задачи.<p class=\"left_margin\">Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p class=\"left_margin\">Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записан номер пары от 1 до 16.<i>Пример входных данных:</i><p> </p><p class=\"left_margin\">4 <p class=\"left_margin\">2 <p class=\"left_margin\">16 <p class=\"left_margin\">3 <p class=\"left_margin\">2<p> </p><p class=\"left_margin\">Программа должна вывести список всех пар, встречающихся в списке, в порядке убывания (невозрастания) количества голосов, отданных за ту или иную пару, с указанием количества отданных за неё голосов. При этом каждая пара должна быть выведена ровно один раз вне зависимости от того, сколько раз она встречается в списке. <i>Пример выходных данных для приведённого выше примера входных данных:</i><p> </p><p class=\"left_margin\">2 2 <p class=\"left_margin\">3 1 <p class=\"left_margin\">16 1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, i, j, t: integer;  Count, Names: array[1..16] of integer;  Begin  For i := 1 to 16 do  begin  Count[i] := 0;  Names[i] := i;  end;  ReadLn(N); {Считываем количество голосов}  for i:=1 to N do  begin  ReadLn(t); {считали очередную пару}  Count[t] := Count[t] + 1;{подсчитываем её}  end; {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=16 downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t;  end;  for i:=1 to 16 do  if Count[i] > 0 then  writeLn(Names[i], ' ', Count[i]);  end.  DIM N, i, j, t AS INTEGER  DIM Count(16) AS INTEGER  DIM Names(16) AS INTEGER  FOR i = 1 TO 16  Count(i) = 0  Names(i) = i  NEXT i  INPUT N ' Считываем количество голосов  FOR i = 1 TO N  INPUT t 'считали пару  'Подсчитываем её  Count(t) = Count(t) + 1  NEXT i  'Сортируем массивы Names и Count в порядке убывания  'значений массива Count  FOR i = 16 TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t  END IF  NEXT j  NEXT i  FOR i = 1 TO 16  IF Count(i) > 0 THEN PRINT Names(i), Count(i)  NEXT i  END    Приведём решение Даниила Доценко, Pascal ABC. var a:array [1..16] of integer;k,i,n,j:integer;begin  readln(n);  for i:=1 to n do begin    readln(k);    a[k]:=a[k]+1;  end;  k:=0;  for i:=1 to 16 do    if a[i]>k then k:=a[i];    for j:=k downto 1 do      for i:=1 to 16 do        if j=a[i] then writeln(i,' ',a[i]);end.  Приведём решение Сергея Мартынова, Python 3.a=[0 for x in range(0,16)]n=int(input())for i in range(0,n):    k=int(input())-1    a[k]+=1for c in range(0,16):    maxi=a.index(max(a))    if maxi != 0:        print (maxi+1,' ',a[maxi])        a[maxi]=-1Пример решения задачи А на языке Паскаль.var  a: array[1..16] of integer; {исходные данные}  val: integer; {пара}  lenght: integer; {количество голосов за пару}  i, j, k: integer;begin  for i := 1 to 15 do read(a[i]);  for i:=1 to 15-1 do    for j:=1 to 15-i do      if a[j] < a[j+1] then begin        k := a[j];        a[j] := a[j+1];        a[j+1] := k;      end;  lenght := 1;  for i := 1 to 15 do    if a[i]=a[i+1] then      lenght := lenght + 1    else begin    writeln(a[i], ' ', lenght);    lenght := 1;    end;end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6436\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования<p> </p><center><p><table style=\"margin:auto\"><tr><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Бейсик:</th></tr><tr><td><div class=\"source_code lang_pascal\"><p> Var n, i, j, t: integer; <p> Count, Names: array[1..16] of integer; <p> Begin <p> For i := 1 to 16 do <p> begin <p> Count[i] := 0; <p> Names[i] := i; <p> end; <p> ReadLn(N); {Считываем количество голосов} <p> for i:=1 to N do <p> begin <p> ReadLn(t); {считали очередную пару} <p> Count[t] := Count[t] + 1;{подсчитываем её} <p> end; <p>{Сортируем массивы Names и Count в порядке убывания значений массива Count} <p> for i:=16 downto 2 do <p> for j:=2 to i do if Count[j-1] &lt; Count[j] then <p> begin <p> t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; <p> t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t; <p> end; <p> for i:=1 to 16 do <p> if Count[i] &gt; 0 then <p> writeLn(Names[i], ' ', Count[i]); <p> end. <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> DIM N, i, j, t AS INTEGER <p> DIM Count(16) AS INTEGER <p> DIM Names(16) AS INTEGER <p> FOR i = 1 TO 16 <p> Count(i) = 0 <p> Names(i) = i <p> NEXT i <p> INPUT N ' Считываем количество голосов <p> FOR i = 1 TO N <p> INPUT t 'считали пару <p> 'Подсчитываем её <p> Count(t) = Count(t) + 1 <p> NEXT i <p> 'Сортируем массивы Names и Count в порядке убывания <p> 'значений массива Count <p> FOR i = 16 TO 2 STEP -1 <p> FOR j = 2 TO i <p> IF Count(j - 1) &lt; Count(j) THEN <p> t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t <p> t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t <p> END IF <p> NEXT j <p> NEXT i <p> FOR i = 1 TO 16 <p> IF Count(i) &gt; 0 THEN PRINT Names(i), Count(i) <p> NEXT i <p> END  <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center><p> </p><p><b>Приведём решение Даниила Доценко, Pascal ABC.</b><p> </p><p>var a:array [1..16] of integer;<p>k,i,n,j:integer;<p>begin<p>  readln(n);<p>  for i:=1 to n do begin<p>    readln(k);<p>    a[k]:=a[k]+1;<p>  end;<p>  k:=0;<p>  for i:=1 to 16 do<p>    if a[i]&gt;k then k:=a[i];<p>    for j:=k downto 1 do<p>      for i:=1 to 16 do<p>        if j=a[i] then writeln(i,' ',a[i]);<p>end.<p> </p><p> </p><p><b>Приведём решение Сергея Мартынова, Python 3.</b><pre><p>a=[0 for x in range(0,16)]<p>n=int(input())<p>for i in range(0,n):<p>    k=int(input())-1<p>    a[k]+=1<p>for c in range(0,16):<p>    maxi=a.index(max(a))<p>    if maxi != 0:<p>        print (maxi+1,' ',a[maxi])<p>        a[maxi]=-1<p></p></p></p></p></p></p></p></p></p></p></p></pre><p class=\"left_margin\"><b>Пример решения задачи А на языке Паскаль.</b><pre>var<p>  a: array[1..16] of integer; {исходные данные}<p>  val: integer; {пара}<p>  lenght: integer; {количество голосов за пару}<p>  i, j, k: integer;<p>begin<p>  for i := 1 to 15 do read(a[i]);<p>  for i:=1 to 15-1 do<p>    for j:=1 to 15-i do<p>      if a[j] &lt; a[j+1] then begin<p>        k := a[j];<p>        a[j] := a[j+1];<p>        a[j+1] := k;<p>      end;<p>  lenght := 1;<p>  for i := 1 to 15 do<p>    if a[i]=a[i+1] then<p>      lenght := lenght + 1<p>    else begin<p>    writeln(a[i], ' ', lenght);<p>    lenght := 1;<p>    end;<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 602.",
            "task_id": "6436"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся актёров и количества голосов, отданных за каждого из них. Во время чтения данных об очередном актёре просматривается список ранее сохранённых актеров. Если он уже есть в списке, то количество голосов, отданных за него, увеличивается на 1, иначе актёр добавляется в массив упомянутых в голосовании актёров (при корректных данных размер массива не может быть больше 6). После окончания ввода производится сортировка массивов актёров и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список актёров с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будут считаны не фамилия и имя, а только фамилия, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer;  Count: array[1..6] of integer;  s: string;  Names: array[1..6] of string;  Begin  Num:=0; {Число различных актеров в списке голосов}  ReadLn(N); {Считываем количество голосов}  for i:=1 to N do  begin  ReadLn(S); {считали очередного актера}  {Осуществляем его поиск в списке уже встретившихся}  j:=1;  while (j<=Num) and (s<>Names[j]) do j:=j+1;  {Если он найден}  if j<=Num then {Увеличиваем счетчик числа голосов, отданных за этого актера}  Count[j]:=Count[j]+1  else begin {Иначе добавляем актера в конец списка}  Names[j]:=s;  Count[j]:=1;  Num:=Num+1; end  end;  {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=Num downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s;  end;  for i:=1 to Num do  WriteLn(Names[i], ' ', Count[i]);  end. DIM N, Num, i, j, t AS INTEGER  DIM Count(6) AS INTEGER  DIM Names$(6)  Num = 0 'Число различных актеров в списке голосов  INPUT N 'Считываем количество голосов  FOR i = 1 TO N  LINE INPUT s$ 'считали актера  'Осуществляем поиск названия в списке уже встретившихся  j = 1  WHILE (j <= Num) AND (s$ <> Names$(j))  j = j + 1  WEND  'Если актер найден  IF j <= Num THEN 'Увеличиваем счетчик числа голосов, отданных за  'этого актера  Count(j) = Count(j) + 1  ELSE ' Иначе добавляем актера в конец списка  Names$(j) = s$  Count(j) = 1  Num = Num + 1  END IF  NEXT i  'Сортируем массивы Names и Count в порядке убывания значений  'массива Count  FOR i = Num TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$  END IF  NEXT j  NEXT i  FOR i = 1 TO Num  PRINT Names$(i), Count(i)  NEXT i  END  ",
            "parsed": "2019-04-29 21:14:00.318542",
            "question": "В еженедельном выпуске популярной газеты было объявлено голосование по выбору актёра, который, по мнению читателей, должен сняться в продолжении фильма «Белое солнце пустыни». На выбор был предложен список из шести актеров. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде списка актёров (каждый элемент списка соответствует одному sms-сообщению). Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записаны фамилия и имя актера (сначала фамилия, а потом через пробел имя). Длина строки не превосходит 50 символов. Пример входных данных: 5 Меньшиков Олег Миронов Евгений Меньшиков Олег Машков Владимир Меньшиков Олег Программа должна вывести список всех актёров, встречающихся в списке, в порядке убывания (невозрастания) количества голосов, отданных за того или иного актёра, с указанием количества отданных за него голосов. При этом каждый актёр должен быть выведен ровно один раз вне зависимости от того, сколько голосов было отдано за него.Пример выходных данных для приведённого выше примера входных данных: Меньшиков Олег 3 Миронов Евгений 1 Машков Владимир 1 ",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948148\" width=\"100%\"><p class=\"left_margin\">В еженедельном выпуске популярной газеты было объявлено голосование по выбору актёра, который, по мнению читателей, должен сняться в продолжении фильма «Белое солнце пустыни». На выбор был предложен список из шести актеров. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде списка актёров (каждый элемент списка соответствует одному sms-сообщению). Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записаны фамилия и имя актера (сначала фамилия, а потом через пробел имя). Длина строки не превосходит 50 символов. <i>Пример входных данных:</i><p> </p><p class=\"left_margin\">5 <p class=\"left_margin\">Меньшиков Олег <p class=\"left_margin\">Миронов Евгений <p class=\"left_margin\">Меньшиков Олег <p class=\"left_margin\">Машков Владимир <p class=\"left_margin\">Меньшиков Олег<p> </p><p class=\"left_margin\">Программа должна вывести список всех актёров, встречающихся в списке, в порядке убывания (невозрастания) количества голосов, отданных за того или иного актёра, с указанием количества отданных за него голосов. При этом каждый актёр должен быть выведен ровно один раз вне зависимости от того, сколько голосов было отдано за него.<i>Пример выходных данных для приведённого выше примера входных данных:</i><p> </p><p class=\"left_margin\">Меньшиков Олег 3 <p class=\"left_margin\">Миронов Евгений 1 <p class=\"left_margin\">Машков Владимир 1 </p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся актёров и количества голосов, отданных за каждого из них. Во время чтения данных об очередном актёре просматривается список ранее сохранённых актеров. Если он уже есть в списке, то количество голосов, отданных за него, увеличивается на 1, иначе актёр добавляется в массив упомянутых в голосовании актёров (при корректных данных размер массива не может быть больше 6). После окончания ввода производится сортировка массивов актёров и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список актёров с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будут считаны не фамилия и имя, а только фамилия, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer;  Count: array[1..6] of integer;  s: string;  Names: array[1..6] of string;  Begin  Num:=0; {Число различных актеров в списке голосов}  ReadLn(N); {Считываем количество голосов}  for i:=1 to N do  begin  ReadLn(S); {считали очередного актера}  {Осуществляем его поиск в списке уже встретившихся}  j:=1;  while (j<=Num) and (s<>Names[j]) do j:=j+1;  {Если он найден}  if j<=Num then {Увеличиваем счетчик числа голосов, отданных за этого актера}  Count[j]:=Count[j]+1  else begin {Иначе добавляем актера в конец списка}  Names[j]:=s;  Count[j]:=1;  Num:=Num+1; end  end;  {Сортируем массивы Names и Count в порядке убывания значений массива Count}  for i:=Num downto 2 do  for j:=2 to i do if Count[j-1] < Count[j] then  begin  t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;  s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s;  end;  for i:=1 to Num do  WriteLn(Names[i], ' ', Count[i]);  end. DIM N, Num, i, j, t AS INTEGER  DIM Count(6) AS INTEGER  DIM Names$(6)  Num = 0 'Число различных актеров в списке голосов  INPUT N 'Считываем количество голосов  FOR i = 1 TO N  LINE INPUT s$ 'считали актера  'Осуществляем поиск названия в списке уже встретившихся  j = 1  WHILE (j <= Num) AND (s$ <> Names$(j))  j = j + 1  WEND  'Если актер найден  IF j <= Num THEN 'Увеличиваем счетчик числа голосов, отданных за  'этого актера  Count(j) = Count(j) + 1  ELSE ' Иначе добавляем актера в конец списка  Names$(j) = s$  Count(j) = 1  Num = Num + 1  END IF  NEXT i  'Сортируем массивы Names и Count в порядке убывания значений  'массива Count  FOR i = Num TO 2 STEP -1  FOR j = 2 TO i  IF Count(j - 1) < Count(j) THEN  t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t  s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$  END IF  NEXT j  NEXT i  FOR i = 1 TO Num  PRINT Names$(i), Count(i)  NEXT i  END  ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6472\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся актёров и количества голосов, отданных за каждого из них. Во время чтения данных об очередном актёре просматривается список ранее сохранённых актеров. Если он уже есть в списке, то количество голосов, отданных за него, увеличивается на 1, иначе актёр добавляется в массив упомянутых в голосовании актёров (при корректных данных размер массива не может быть больше 6). После окончания ввода производится сортировка массивов актёров и количества голосов, отданных за них, в порядке убывания количества голосов; затем выводится список актёров с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будут считаны не фамилия и имя, а только фамилия, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си.<p> </p><center><p><table style=\"margin:auto\"><tr><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Бейсик:</th></tr><tr><td><div class=\"source_code lang_pascal\"><p> Var n, Num, i, j, t: integer; <p> Count: array[1..6] of integer; <p> s: string; <p> Names: array[1..6] of string; <p> Begin <p> Num:=0; {Число различных актеров в списке голосов} <p> ReadLn(N); {Считываем количество голосов} <p> for i:=1 to N do <p> begin <p> ReadLn(S); {считали очередного актера} <p> {Осуществляем его поиск в списке уже встретившихся} <p> j:=1; <p> while (j&lt;=Num) and (s&lt;&gt;Names[j]) do j:=j+1; <p> {Если он найден} <p> if j&lt;=Num then {Увеличиваем счетчик числа голосов, отданных за этого актера} <p> Count[j]:=Count[j]+1 <p> else begin {Иначе добавляем актера в конец списка} <p> Names[j]:=s; <p> Count[j]:=1; <p> Num:=Num+1;<p> end <p> end; <p> {Сортируем массивы Names и Count в порядке убывания значений массива Count} <p> for i:=Num downto 2 do <p> for j:=2 to i do if Count[j-1] &lt; Count[j] then <p> begin <p> t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; <p> s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s; <p> end; <p> for i:=1 to Num do <p> WriteLn(Names[i], ' ', Count[i]); <p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> DIM N, Num, i, j, t AS INTEGER <p> DIM Count(6) AS INTEGER <p> DIM Names$(6) <p> Num = 0 'Число различных актеров в списке голосов <p> INPUT N 'Считываем количество голосов <p> FOR i = 1 TO N <p> LINE INPUT s$ 'считали актера <p> 'Осуществляем поиск названия в списке уже встретившихся <p> j = 1 <p> WHILE (j &lt;= Num) AND (s$ &lt;&gt; Names$(j)) <p> j = j + 1 <p> WEND <p> 'Если актер найден <p> IF j &lt;= Num THEN 'Увеличиваем счетчик числа голосов, отданных за <p> 'этого актера <p> Count(j) = Count(j) + 1 <p> ELSE ' Иначе добавляем актера в конец списка <p> Names$(j) = s$ <p> Count(j) = 1 <p> Num = Num + 1 <p> END IF <p> NEXT i <p> 'Сортируем массивы Names и Count в порядке убывания значений <p> 'массива Count <p> FOR i = Num TO 2 STEP -1 <p> FOR j = 2 TO i <p> IF Count(j - 1) &lt; Count(j) THEN <p> t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t <p> s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$ <p> END IF <p> NEXT j <p> NEXT i <p> FOR i = 1 TO Num <p> PRINT Names$(i), Count(i) <p> NEXT i <p> END <p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 603.",
            "task_id": "6472"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся задач и количества запросов по каждой из них. Во время чтения данных об очередной задаче просматривается список ранее сохранённых задач; если она уже есть в списке, то количество запросов по ней увеличивается на 1, иначе задача добавляется в массив упомянутых в запросах задач (при корректных данных размер массива не может быть больше 12). После окончания ввода производится сортировка массивов задач и количества запросов, отданных за них, в порядке возрастания количества запросов; затем выводится список из трёх первых задач с указанием частоты встречаемости (или весь список, если его длина меньше трёх). Вместо сортировки можно применить и алгоритм поиска трёх минимальных элементов в массиве или три первых итерации сортировки. Затем выводятся три первые (или найденные наименее популярные) задачи. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будет считано не всё название задачи, а только его первое слово, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer; Count: array[1..12] of integer; s: string; Names: array[1..12] of string; Begin Num:=0; {Число различных задач в списке запросов}  ReadLn(N); {Считываем количество запросов} for i:=1 to N do begin  ReadLn(S); {считали очередную задачу} {Осуществляем её поиск в списке уже встретившихся} j:=1; while (j<=Num) and (s<>Names[j]) do j:=j+1; {Если она найдена} if j<=Num then {Увеличиваем счетчик числа запросов}  Count[j]:=Count[j]+1 else begin {Иначе добавляем задачу в конец списка} Names[j]:=s; Count[j]:=1;  Num:=Num+1 end end; {Сортируем массивы Names и Count в порядке возрастания значений массива Count} for i:=Num downto 2 do for j:=2 to i do if Count[j-1]>Count[j] then begin t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s; end; if Num >= 3 then Num := 3; for i:=1 to Num do WriteLn(Names[i], ' ', Count[i]); end. DIM N, Num, i, j, t AS INTEGER DIM Count(12) AS INTEGER DIM Names$(12)  Num = 0 'Число различных задач в списке запросов INPUT N 'Считываем количество запросов FOR i = 1 TO N LINE INPUT s$ 'считали задачу 'Осуществляем поиск задачи в списке уже встретившихся j = 1 WHILE (j <= Num) AND (s$ <> Names$(j)) j = j + 1  WEND 'Если задача найдена IF j <= Num THEN 'Увеличиваем счетчик числа запросов  Count(j) = Count(j) + 1 ELSE ' Иначе добавляем задачу в конец списка Names$(j) = s$ Count(j) = 1  Num = Num + 1 END IF  NEXT i 'Сортируем массивы Names и Count в порядке возрастания значений 'массива Count FOR i = Num TO 2 STEP -1 FOR j = 2 TO i IF Count(j - 1) > Count(j) THEN t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$ END IF NEXT j  NEXT i IF Num >= 3 THEN Num = 3 FOR i = 1 TO Num PRINT Names$(i), Count(i)  NEXT i END ",
            "parsed": "2019-04-29 21:14:00.796184",
            "question": "В командных олимпиадах по программированию для решения предлагается не больше 12 задач. Команда может решать предложенные задачи в любом порядке. Подготовленные решения команда посылает в единую проверяющую систему соревнований. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет статистически обрабатывать пришедшие запросы, чтобы определить наименее популярные задачи. Следует учитывать, что количество запросов в списке может быть очень велико, так как многие соревнования проходят с использованием сети Интернет. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших запросов N. В каждой из последующих N строк записано название задачи в виде текстовой строки. Длина строки не превосходит 100 символов, название может содержать буквы, цифры, пробелы и знаки препинания. Пример входных данных: 6А+BКрестики-НоликиА+ВПростой делительА+ВПростой делитель Программа должна вывести список из трёх задач, встречающихся в запросах наименьшее число раз, с указанием количества запросов по ним. Если в запросах упоминается менее трёх задач, то выведите информацию об имеющихся задачах. Если несколько задач имеют ту же частоту встречаемости, что и третья по частоте встречаемости задача, то выведите только одну из них. Пример выходных данных для приведённого выше примера входных данных: Крестики-Нолики 1Простой делитель 2А+В 3",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948110\" width=\"100%\"><p class=\"left_margin\">В командных олимпиадах по программированию для решения предлагается не больше 12 задач. Команда может решать предложенные задачи в любом порядке. Подготовленные решения команда посылает в единую проверяющую систему соревнований. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет статистически обрабатывать пришедшие запросы, чтобы определить наименее популярные задачи. Следует учитывать, что количество запросов в списке может быть очень велико, так как многие соревнования проходят с использованием сети Интернет. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших запросов N. В каждой из последующих N строк записано название задачи в виде текстовой строки. Длина строки не превосходит 100 символов, название может содержать буквы, цифры, пробелы и знаки препинания. <i>Пример входных данных:</i><p> </p><p class=\"left_margin\">6<p class=\"left_margin\">А+B<p class=\"left_margin\">Крестики-Нолики<p class=\"left_margin\">А+В<p class=\"left_margin\">Простой делитель<p class=\"left_margin\">А+В<p class=\"left_margin\">Простой делитель<p> </p><p class=\"left_margin\">Программа должна вывести список из трёх задач, встречающихся в запросах наименьшее число раз, с указанием количества запросов по ним. Если в запросах упоминается менее трёх задач, то выведите информацию об имеющихся задачах. Если несколько задач имеют ту же частоту встречаемости, что и третья по частоте встречаемости задача, то выведите только одну из них. <i>Пример выходных данных для приведённого выше примера входных данных:</i><p> </p><p class=\"left_margin\">Крестики-Нолики 1<p class=\"left_margin\">Простой делитель 2<p class=\"left_margin\">А+В 3</p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся задач и количества запросов по каждой из них. Во время чтения данных об очередной задаче просматривается список ранее сохранённых задач; если она уже есть в списке, то количество запросов по ней увеличивается на 1, иначе задача добавляется в массив упомянутых в запросах задач (при корректных данных размер массива не может быть больше 12). После окончания ввода производится сортировка массивов задач и количества запросов, отданных за них, в порядке возрастания количества запросов; затем выводится список из трёх первых задач с указанием частоты встречаемости (или весь список, если его длина меньше трёх). Вместо сортировки можно применить и алгоритм поиска трёх минимальных элементов в массиве или три первых итерации сортировки. Затем выводятся три первые (или найденные наименее популярные) задачи. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будет считано не всё название задачи, а только его первое слово, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, Num, i, j, t: integer; Count: array[1..12] of integer; s: string; Names: array[1..12] of string; Begin Num:=0; {Число различных задач в списке запросов}  ReadLn(N); {Считываем количество запросов} for i:=1 to N do begin  ReadLn(S); {считали очередную задачу} {Осуществляем её поиск в списке уже встретившихся} j:=1; while (j<=Num) and (s<>Names[j]) do j:=j+1; {Если она найдена} if j<=Num then {Увеличиваем счетчик числа запросов}  Count[j]:=Count[j]+1 else begin {Иначе добавляем задачу в конец списка} Names[j]:=s; Count[j]:=1;  Num:=Num+1 end end; {Сортируем массивы Names и Count в порядке возрастания значений массива Count} for i:=Num downto 2 do for j:=2 to i do if Count[j-1]>Count[j] then begin t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s; end; if Num >= 3 then Num := 3; for i:=1 to Num do WriteLn(Names[i], ' ', Count[i]); end. DIM N, Num, i, j, t AS INTEGER DIM Count(12) AS INTEGER DIM Names$(12)  Num = 0 'Число различных задач в списке запросов INPUT N 'Считываем количество запросов FOR i = 1 TO N LINE INPUT s$ 'считали задачу 'Осуществляем поиск задачи в списке уже встретившихся j = 1 WHILE (j <= Num) AND (s$ <> Names$(j)) j = j + 1  WEND 'Если задача найдена IF j <= Num THEN 'Увеличиваем счетчик числа запросов  Count(j) = Count(j) + 1 ELSE ' Иначе добавляем задачу в конец списка Names$(j) = s$ Count(j) = 1  Num = Num + 1 END IF  NEXT i 'Сортируем массивы Names и Count в порядке возрастания значений 'массива Count FOR i = Num TO 2 STEP -1 FOR j = 2 TO i IF Count(j - 1) > Count(j) THEN t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$ END IF NEXT j  NEXT i IF Num >= 3 THEN Num = 3 FOR i = 1 TO Num PRINT Names$(i), Count(i)  NEXT i END ",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6514\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая их в массиве, размер которого равен N, а составляя только список встретившихся задач и количества запросов по каждой из них. Во время чтения данных об очередной задаче просматривается список ранее сохранённых задач; если она уже есть в списке, то количество запросов по ней увеличивается на 1, иначе задача добавляется в массив упомянутых в запросах задач (при корректных данных размер массива не может быть больше 12). После окончания ввода производится сортировка массивов задач и количества запросов, отданных за них, в порядке возрастания количества запросов; затем выводится список из трёх первых задач с указанием частоты встречаемости (или весь список, если его длина меньше трёх). Вместо сортировки можно применить и алгоритм поиска трёх минимальных элементов в массиве или три первых итерации сортировки. Затем выводятся три первые (или найденные наименее популярные) задачи. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Так, на языке C++ при считывании строковой переменной будет считано не всё название задачи, а только его первое слово, поэтому следует использовать функцию getline(cin,s); аналогичная проблема возникает и в языке Си<p> </p><center><p><table style=\"margin:auto\"><tr><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\" width=\"400\">Пример правильной и эффективной программы на языке Бейсик:</th></tr><tr><td><div class=\"source_code lang_pascal\"><p> Var n, Num, i, j, t: integer;<p> Count: array[1..12] of integer;<p> s: string;<p> Names: array[1..12] of string;<p> Begin<p> Num:=0; {Число различных задач в списке запросов} <p> ReadLn(N); {Считываем количество запросов}<p> for i:=1 to N do<p> begin <p> ReadLn(S); {считали очередную задачу}<p> {Осуществляем её поиск в списке уже встретившихся}<p> j:=1;<p> while (j&lt;=Num) and (s&lt;&gt;Names[j]) do j:=j+1;<p> {Если она найдена}<p> if j&lt;=Num then {Увеличиваем счетчик числа запросов} <p> Count[j]:=Count[j]+1<p> else begin {Иначе добавляем задачу в конец списка}<p> Names[j]:=s;<p> Count[j]:=1; <p> Num:=Num+1<p> end<p> end;<p> {Сортируем массивы Names и Count в порядке возрастания значений массива Count}<p> for i:=Num downto 2 do<p> for j:=2 to i do if Count[j-1]&gt;Count[j] then<p> begin<p> t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;<p> s:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=s;<p> end;<p> if Num &gt;= 3 then Num := 3;<p> for i:=1 to Num do<p> WriteLn(Names[i], ' ', Count[i]);<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> DIM N, Num, i, j, t AS INTEGER<p> DIM Count(12) AS INTEGER<p> DIM Names$(12) <p> Num = 0 'Число различных задач в списке запросов<p> INPUT N 'Считываем количество запросов<p> FOR i = 1 TO N<p> LINE INPUT s$ 'считали задачу<p> 'Осуществляем поиск задачи в списке уже встретившихся<p> j = 1<p> WHILE (j &lt;= Num) AND (s$ &lt;&gt; Names$(j))<p> j = j + 1 <p> WEND<p> 'Если задача найдена<p> IF j &lt;= Num THEN 'Увеличиваем счетчик числа запросов <p> Count(j) = Count(j) + 1<p> ELSE ' Иначе добавляем задачу в конец списка<p> Names$(j) = s$<p> Count(j) = 1 <p> Num = Num + 1<p> END IF <p> NEXT i<p> 'Сортируем массивы Names и Count в порядке возрастания значений<p> 'массива Count<p> FOR i = Num TO 2 STEP -1<p> FOR j = 2 TO i<p> IF Count(j - 1) &gt; Count(j) THEN<p> t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t<p> s$ = Names$(j): Names$(j) = Names$(j - 1): Names$(j - 1) = s$<p> END IF<p> NEXT j <p> NEXT i<p> IF Num &gt;= 3 THEN Num = 3<p> FOR i = 1 TO Num<p> PRINT Names$(i), Count(i) <p> NEXT i<p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 801.",
            "task_id": "6514"
        },
        {
            "answer": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке возрастания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, i, j, t: integer; Count, Names: array[1..10] of integer; Begin For i := 1 to 10 do begin Count[i] := 0; Names[i] := i; end; ReadLn(N); {Считываем количество голосов} for i:=1 to N do begin ReadLn(t); {считали очередную пару} Count[t] := Count[t] + 1;{учитываем поданный голос} end; {Сортируем массивы Names и Count в порядке возрастания значений массива Count} for i:=10 downto 2 do for j:=2 to i do if Count[j-1]>Count[j] then begin t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t; end; for i:=1 to 10 do if Count[i] > 0 then writeLn(Names[i], ' ', Count[i]); end. DIM Count(10) AS INTEGER DIM Names(10) AS INTEGER FOR i = 1 TO 10 Count(i) = 0 Names(i) = i NEXT i INPUT N 'Считываем количество голосов FOR i = 1 TO N INPUT t 'считали пару 'Учитываем поданный голос Count(t) = Count(t) + 1 NEXT i 'Сортируем массивы Names и Count в порядке возрастания 'значений массива Count FOR i = 10 TO 2 STEP -1  FOR j = 2 TO i IF Count(j - 1) > Count(j) THEN t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t END IF NEXT j NEXT i FOR i = 1 TO 10 IF Count(i) > 0 THEN PRINT Names(i), Count(i) NEXT i END",
            "parsed": "2019-04-29 21:14:23.459584",
            "question": "В телевизионном танцевальном марафоне с определением победителя с помощью телезрителей после каждого тура объявляется sms-голосование, в котором зрители указывают наиболее понравившуюся им пару из максимум 10 пар, которые участвуют в проекте. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде номеров пар (каждый элемент списка соответствует одному sms-сообщению). Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записан номер пары от 1 до 10.Пример входных данных: 421032 Программа должна вывести список всех пар, встречающихся в списке, в порядке возрастания (неубывания) количества голосов, отданных за ту или иную пару, с указанием количества отданных за неё голосов. При этом каждая пара должна быть выведена ровно один раз вне зависимости от того, сколько раз она встречается в списке.Пример выходных данных для приведённого выше примера входных данных: 3 110 12 2",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body948034\" width=\"100%\"><p class=\"left_margin\">В телевизионном танцевальном марафоне с определением победителя с помощью телезрителей после каждого тура объявляется sms-голосование, в котором зрители указывают наиболее понравившуюся им пару из максимум 10 пар, которые участвуют в проекте. Вам предлагается написать эффективную, в том числе по используемой памяти, программу, которая будет обрабатывать результаты sms-голосования по данному вопросу. Результаты голосования получены в виде номеров пар (каждый элемент списка соответствует одному sms-сообщению). Следует учитывать, что количество голосов в списке может быть очень велико. Перед текстом программы кратко опишите используемый Вами алгоритм решения задачи. На вход программе в первой строке подаётся количество пришедших sms-сообщений N. В каждой из последующих N строк записан номер пары от 1 до 10.<i>Пример входных данных:</i><p> </p><p class=\"left_margin\">4<p class=\"left_margin\">2<p class=\"left_margin\">10<p class=\"left_margin\">3<p class=\"left_margin\">2<p> </p><p class=\"left_margin\">Программа должна вывести список всех пар, встречающихся в списке, в порядке возрастания (неубывания) количества голосов, отданных за ту или иную пару, с указанием количества отданных за неё голосов. При этом каждая пара должна быть выведена ровно один раз вне зависимости от того, сколько раз она встречается в списке.<i>Пример выходных данных для приведённого выше примера входных данных:</i><p> </p><p class=\"left_margin\">3 1<p class=\"left_margin\">10 1<p class=\"left_margin\">2 2</p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке возрастания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования. Пример правильной и эффективной программы на языке Паскаль:Пример правильной и эффективной программы на языке Бейсик: Var n, i, j, t: integer; Count, Names: array[1..10] of integer; Begin For i := 1 to 10 do begin Count[i] := 0; Names[i] := i; end; ReadLn(N); {Считываем количество голосов} for i:=1 to N do begin ReadLn(t); {считали очередную пару} Count[t] := Count[t] + 1;{учитываем поданный голос} end; {Сортируем массивы Names и Count в порядке возрастания значений массива Count} for i:=10 downto 2 do for j:=2 to i do if Count[j-1]>Count[j] then begin t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t; t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t; end; for i:=1 to 10 do if Count[i] > 0 then writeLn(Names[i], ' ', Count[i]); end. DIM Count(10) AS INTEGER DIM Names(10) AS INTEGER FOR i = 1 TO 10 Count(i) = 0 Names(i) = i NEXT i INPUT N 'Считываем количество голосов FOR i = 1 TO N INPUT t 'считали пару 'Учитываем поданный голос Count(t) = Count(t) + 1 NEXT i 'Сортируем массивы Names и Count в порядке возрастания 'значений массива Count FOR i = 10 TO 2 STEP -1  FOR j = 2 TO i IF Count(j - 1) > Count(j) THEN t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t END IF NEXT j NEXT i FOR i = 1 TO 10 IF Count(i) > 0 THEN PRINT Names(i), Count(i) NEXT i END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6590\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все входные данные в массиве, размер которого равен N, а сразу подсчитывая в массиве пар, сколько голосов отдано за каждую из них. После окончания ввода производится одновременная сортировка массивов номеров пар и количества голосов, отданных за них, в порядке возрастания количества голосов; затем выводится список пар, за которые подано ненулевое число голосов, с указанием частоты встречаемости. Баллы начисляются только за программу, которая решает задачу хотя бы для одного частного случая. Ниже приведены примеры решения задания на языках Паскаль и Бейсик. Допускаются решения, записанные на других языках программирования. При оценивании решений на других языках программирования необходимо учитывать особенности этих языков программирования.<p> </p><center><p><table style=\"margin:auto\"><tr><th style=\"text-align:center\">Пример правильной и эффективной программы на языке Паскаль:</th><th style=\"text-align:center\">Пример правильной и эффективной программы на языке Бейсик:</th></tr><tr><td><div class=\"source_code lang_pascal\"><p> Var n, i, j, t: integer;<p> Count, Names: array[1..10] of integer;<p> Begin<p> For i := 1 to 10 do<p> begin<p> Count[i] := 0;<p> Names[i] := i;<p> end;<p> ReadLn(N); {Считываем количество голосов}<p> for i:=1 to N do<p> begin<p> ReadLn(t); {считали очередную пару}<p> Count[t] := Count[t] + 1;{учитываем поданный голос}<p> end;<p> {Сортируем массивы Names и Count в порядке возрастания значений массива Count}<p> for i:=10 downto 2 do<p> for j:=2 to i do if Count[j-1]&gt;Count[j] then<p> begin<p> t:=Count[j]; Count[j]:=Count[j-1]; Count[j-1]:=t;<p> t:=Names[j]; Names[j]:=Names[j-1]; Names[j-1]:=t;<p> end;<p> for i:=1 to 10 do<p> if Count[i] &gt; 0 then<p> writeLn(Names[i], ' ', Count[i]);<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_basic\"><p> DIM Count(10) AS INTEGER<p> DIM Names(10) AS INTEGER<p> FOR i = 1 TO 10<p> Count(i) = 0<p> Names(i) = i<p> NEXT i<p> INPUT N 'Считываем количество голосов<p> FOR i = 1 TO N<p> INPUT t 'считали пару<p> 'Учитываем поданный голос<p> Count(t) = Count(t) + 1<p> NEXT i<p> 'Сортируем массивы Names и Count в порядке возрастания<p> 'значений массива Count<p> FOR i = 10 TO 2 STEP -1 <p> FOR j = 2 TO i<p> IF Count(j - 1) &gt; Count(j) THEN<p> t = Count(j): Count(j) = Count(j - 1): Count(j - 1) = t<p> t = Names(j): Names(j) = Names(j - 1): Names(j - 1) = t<p> END IF<p> NEXT j<p> NEXT i<p> FOR i = 1 TO 10<p> IF Count(i) &gt; 0 THEN PRINT Names(i), Count(i)<p> NEXT i<p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table></p></center></p></div>",
            "source": "Источник: ЕГЭ по информатике 08.07.2013. Вторая волна. Ва­ри­ант 802.",
            "task_id": "6590"
        },
        {
            "answer": "Решение.Поскольку количество детей не превышает 100, остаться может не больше 99 конфет. Можно создать массив из 99 элементов и использовать их в качестве счётчиков, хранящих информацию о количестве записейкаждого числа. Программа читает исходные данные, не запоминая их в массиве. Для каждой пары (D, K) количество оставшихся конфет определяется как остаток от деления K на D. Если этот остаток положителен, надо увеличить соответствующий счётчик. По окончании ввода и обработки данных надо найти индекс максимального элемента в массиве счётчиков. При этом нужно правильно (в соответствии с условием) обработать ситуации равенства максимумов и отсутствия ненулевых счётчиков. Пример правильной и эффективной программы на языке Паскаль program c4;const DMAX=100; {максимально возможное количество детей}varN: integer; {количество утренников}D: integer; {количество детей на утреннике}K: integer; {количество конфет}r: integer; {остаток}c: array[1..DMAX-1] of integer; {счетчики остатков}i: integer;imax: integer;begin{предварительная очистка счетчиков}for i:=1 to DMAX-1 do c[i]:=0;readln(N);{ввод данных, подсчет количества каждого остатка}for i:=1 to N do beginreadln(D, K);r := K mod D;if r>0 then c[r]:=c[r]+1;end;{выбор самого частого остатка}imax:=1;for i:=2 to DMAX-1 do beginif c[i]>=c[imax] then imax:=i;end;if c[imax]=0 then imax:=0;writeln(imax);end. Пример решения задачи А на языке Паскаль. var  D: integer; {количество детей на утреннике}  K: integer; {количество конфет}  r: array[1..10] of integer; {остатки}  inf: array[1..10, 1..2] of integer; {исходные данные}  val: integer; {самый частый остаток}  max_lenght: integer;  i, j, c, lenght: integer;begin  for i := 1 to 10 do begin    read(D, K);    inf[i, 1] := D;    inf[i, 2] := K;  end;  for i := 1 to 10 do r[i] := inf[i, 2] mod inf[i, 1];  for i := 1 to 10 do    for j := 1 to 10-i do      if r[j]      c := r[j];      r[j] := r[j+1];      r[j+1] := c;    end;  max_lenght := 0;  lenght := 1;  val := r[1];  for i := 1 to 9 do    if r[i]=r[i+1] then      lenght := lenght + 1    else begin      if lenght>max_lenght then begin        max_lenght := lenght;        val := r[i];      end;      lenght := 1;    end;  writeln(val);end.",
            "parsed": "2019-04-29 21:13:27.351951",
            "question": "Дед Мороз и Снегурочка приходят на детские утренники с мешком конфет. Дед Мороз делит конфеты поровну между всеми присутствующими детьми (детей на утреннике никогда не бывает больше 100), а оставшиеся конфеты отдает Снегурочке. Снегурочка каждый раз записывает в блокнот количество полученных конфет. Если конфеты разделились между всеми детьми без остатка, Снегурочка ничего не получает и ничего не записывает. Когда утренники закончились, Деду Морозу стало интересно, какое число чаще всего записывала Снегурочка. Дед Мороз и Снегурочка — волшебные, поэтому число утренников N, на которых они побывали, может быть очень большим. Напишите программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется набор чисел, состоящий из 10 пар положительных целых чисел. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных, состоящий из пар положительных целых чисел. Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Описание входных данныхВ первой строке вводится одно целое положительное число — количество утренников N. Каждая из следующих N строк содержит два целых числа: сначала D — количество пришедших на очередной утренник детей, а затем K – количество конфет в мешке Деда Мороза на этом утреннике. Гарантируется выполнение следующих соотношений:1 ≤ N ≤ 100001 ≤ D ≤ 100 (для каждого D)D ≤ K ≤ 1000 (для каждой пары D, K)Описание выходных данныхПрограмма должна вывести одно число — то, которое Снегурочка записывала чаще всего. Если несколько чисел записывались одинаково часто, надо вывести большее из них. Если Снегурочка ни разу ничего не записывала, надо вывести ноль.Пример входных данных:710 5815 31520 408100 100032 6332 6311 121Пример выходных данных для приведённого выше примера входных данных:31",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947316\" width=\"100%\"><p class=\"left_margin\">Дед Мороз и Снегурочка приходят на детские утренники с мешком конфет. Дед Мороз делит конфеты поровну между всеми присутствующими детьми (детей на утреннике никогда не бывает больше 100), а оставшиеся конфеты отдает Снегурочке. Снегурочка каждый раз записывает в блокнот количество полученных конфет. Если конфеты разделились между всеми детьми без остатка, Снегурочка ничего не получает и ничего не записывает. Когда утренники закончились, Деду Морозу стало интересно, какое число чаще всего записывала Снегурочка. Дед Мороз и Снегурочка — волшебные, поэтому число утренников N, на которых они побывали, может быть очень большим. Напишите программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию.<p> </p><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется набор чисел, состоящий из 10 пар положительных целых чисел. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных, состоящий из пар положительных целых чисел. Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p><i>Описание входных данных</i><p class=\"left_margin\">В первой строке вводится одно целое положительное число — количество утренников N. Каждая из следующих N строк содержит два целых числа: сначала D — количество пришедших на очередной утренник детей, а затем K – количество конфет в мешке Деда Мороза на этом утреннике. Гарантируется выполнение следующих соотношений:<p class=\"left_margin\">1 ≤ N ≤ 10000<p class=\"left_margin\">1 ≤ D ≤ 100 (для каждого D)<p class=\"left_margin\">D ≤ K ≤ 1000 (для каждой пары D, K)<p><i>Описание выходных данных</i><p class=\"left_margin\">Программа должна вывести одно число — то, которое Снегурочка записывала чаще всего. Если несколько чисел записывались одинаково часто, надо вывести большее из них. Если Снегурочка ни разу ничего не записывала, надо вывести ноль.<p><i>Пример входных данных:</i><p class=\"left_margin\">7<p class=\"left_margin\">10 58<p class=\"left_margin\">15 315<p class=\"left_margin\">20 408<p class=\"left_margin\">100 1000<p class=\"left_margin\">32 63<p class=\"left_margin\">32 63<p class=\"left_margin\">11 121<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">31</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Поскольку количество детей не превышает 100, остаться может не больше 99 конфет. Можно создать массив из 99 элементов и использовать их в качестве счётчиков, хранящих информацию о количестве записейкаждого числа. Программа читает исходные данные, не запоминая их в массиве. Для каждой пары (D, K) количество оставшихся конфет определяется как остаток от деления K на D. Если этот остаток положителен, надо увеличить соответствующий счётчик. По окончании ввода и обработки данных надо найти индекс максимального элемента в массиве счётчиков. При этом нужно правильно (в соответствии с условием) обработать ситуации равенства максимумов и отсутствия ненулевых счётчиков. Пример правильной и эффективной программы на языке Паскаль program c4;const DMAX=100; {максимально возможное количество детей}varN: integer; {количество утренников}D: integer; {количество детей на утреннике}K: integer; {количество конфет}r: integer; {остаток}c: array[1..DMAX-1] of integer; {счетчики остатков}i: integer;imax: integer;begin{предварительная очистка счетчиков}for i:=1 to DMAX-1 do c[i]:=0;readln(N);{ввод данных, подсчет количества каждого остатка}for i:=1 to N do beginreadln(D, K);r := K mod D;if r>0 then c[r]:=c[r]+1;end;{выбор самого частого остатка}imax:=1;for i:=2 to DMAX-1 do beginif c[i]>=c[imax] then imax:=i;end;if c[imax]=0 then imax:=0;writeln(imax);end. Пример решения задачи А на языке Паскаль. var  D: integer; {количество детей на утреннике}  K: integer; {количество конфет}  r: array[1..10] of integer; {остатки}  inf: array[1..10, 1..2] of integer; {исходные данные}  val: integer; {самый частый остаток}  max_lenght: integer;  i, j, c, lenght: integer;begin  for i := 1 to 10 do begin    read(D, K);    inf[i, 1] := D;    inf[i, 2] := K;  end;  for i := 1 to 10 do r[i] := inf[i, 2] mod inf[i, 1];  for i := 1 to 10 do    for j := 1 to 10-i do      if r[j]      c := r[j];      r[j] := r[j+1];      r[j+1] := c;    end;  max_lenght := 0;  lenght := 1;  val := r[1];  for i := 1 to 9 do    if r[i]=r[i+1] then      lenght := lenght + 1    else begin      if lenght>max_lenght then begin        max_lenght := lenght;        val := r[i];      end;      lenght := 1;    end;  writeln(val);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6792\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Поскольку количество детей не превышает 100, остаться может не больше 99 конфет. Можно создать массив из 99 элементов и использовать их в качестве счётчиков, хранящих информацию о количестве записей<p>каждого числа. Программа читает исходные данные, не запоминая их в массиве. Для каждой пары (D, K) количество оставшихся конфет определяется как остаток от деления K на D. Если этот остаток положителен, надо увеличить соответствующий счётчик. По окончании ввода и обработки данных надо найти индекс максимального элемента в массиве счётчиков. При этом нужно правильно (в соответствии с условием) обработать ситуации равенства максимумов и отсутствия ненулевых счётчиков.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль<p> </p><p>program c4;<p>const DMAX=100; {максимально возможное количество детей}<p>var<p class=\"left_margin\">N: integer; {количество утренников}<p class=\"left_margin\">D: integer; {количество детей на утреннике}<p class=\"left_margin\">K: integer; {количество конфет}<p>r: integer; {остаток}<p>c: array[1..DMAX-1] of integer; {счетчики остатков}<p>i: integer;<p>imax: integer;<p>begin<p>{предварительная очистка счетчиков}<p>for i:=1 to DMAX-1 do c[i]:=0;<p>readln(N);<p>{ввод данных, подсчет количества каждого остатка}<p>for i:=1 to N do begin<p>readln(D, K);<p>r := K mod D;<p>if r&gt;0 then c[r]:=c[r]+1;<p>end;<p>{выбор самого частого остатка}<p>imax:=1;<p>for i:=2 to DMAX-1 do begin<p>if c[i]&gt;=c[imax] then imax:=i;<p>end;<p>if c[imax]=0 then imax:=0;<p>writeln(imax);<p>end.<p> </p><p class=\"left_margin\">Пример решения задачи А на языке Паскаль.<p> </p><pre>var<p>  D: integer; {количество детей на утреннике}<p>  K: integer; {количество конфет}<p>  r: array[1..10] of integer; {остатки}<p>  inf: array[1..10, 1..2] of integer; {исходные данные}<p>  val: integer; {самый частый остаток}<p>  max_lenght: integer;<p>  i, j, c, lenght: integer;<p>begin<p>  for i := 1 to 10 do begin<p>    read(D, K);<p>    inf[i, 1] := D;<p>    inf[i, 2] := K;<p>  end;<p>  for i := 1 to 10 do r[i] := inf[i, 2] mod inf[i, 1];<p>  for i := 1 to 10 do<p>    for j := 1 to 10-i do<p>      if r[j]<r[j+1] begin<p=\"\" then=\"\">      c := r[j];<p>      r[j] := r[j+1];<p>      r[j+1] := c;<p>    end;<p>  max_lenght := 0;<p>  lenght := 1;<p>  val := r[1];<p>  for i := 1 to 9 do<p>    if r[i]=r[i+1] then<p>      lenght := lenght + 1<p>    else begin<p>      if lenght&gt;max_lenght then begin<p>        max_lenght := lenght;<p>        val := r[i];<p>      end;<p>      lenght := 1;<p>    end;<p>  writeln(val);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></r[j+1]></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "6792"
        },
        {
            "answer": "Решение.Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси Ox, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси Ox будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси Ox (условие y=0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга – они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты x. Среди точек, не лежащих на оси Ox, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным инаименьшим отрицательным значением координаты y.Таким образом, задача сводится к нахождению максимального и минимального x среди точек, у которых y=0, максимального и минимального y среди остальных точек и нахождению площади четырёхугольника на основе этих данных.Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника. Пример правильной и эффективной программы на языке Паскальprogram c4;varn: integer;x, y: integer;xmin, xmax: integer;xsearch: boolean;ymin, ymax: integer;i: integer;s: real;beginxsearch := true;xmin := 0; xmax := 0;ymin:=0; ymax := 0;readln(n);for i:=1 to n do beginreadln(x,y);if y=0 then beginif xsearch or (x < xmin) then xmin:=x;if xsearch or (x > xmax) then xmax:=x;xsearch:=false;endelse if y < ymin then ymin:=yelse if y > ymax then ymax:=yend;if (xmax>xmin) and (ymin<0) and (ymax>0)then s := (xmax-xmin)*(ymax-ymin)/2else s := 0;writeln(s);end.  Пример правильной и эффективной программы на языке Бейсик DIM n AS INTEGER DIM x, y AS INTEGER DIM xmin, xmax AS INTEGER DIM xsearch AS INTEGER DIM ymin, ymax AS INTEGER DIM i AS INTEGER DIM s AS DOUBLE xsearch = 1 xmin = 0: xmax = 0 ymin = 0: ymax = 0 INPUT n FOR i = 1 TO n INPUT x, y IF y = 0 THEN IF xsearch = 1 OR x < xmin THEN xmin = x IF xsearch = 1 OR x > xmax THEN xmax = x xsearch = 0 ELSEIF y < ymin THEN ymin = y ELSEIF y > ymax THEN ymax = y END IF NEXT i IF xmax > xmin AND ymin < 0 AND ymax > 0 THEN s = (xmax - xmin) * (ymax – ymin) / 2 ELSE s = 0 END IF PRINT s Пример правильной и эффективной программы на Алгоритмическом языкеалг c4начцел nцел x,yцел xmin=0, xmax=0лог xsearch=дацел ymin=0, ymax=0цел iвещ sввод nнц для i от 1 до nввод x, yесли y=0тоесли xsearch или xесли xsearch или x>xmax то xmax:=x всеxsearch:=нетиначеесли yесли y>ymax то ymax:=y всевсекцесли xmax > xmin и ymin < 0 и ymax > 0то s:=(xmax-xmin)*(ymax-ymin)/2иначе s:=0всевывод sкон Пример решения задачи А на языке Паскаль. var  coord: array[1..10, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}  s: real; {площадь четырёхугольника}  i, j: integer;begin  xminpos := MaxInt; xmaxpos := -(MaxInt-1);  yminpos := MaxInt; ymaxpos := -(MaxInt-1);  for i := 1 to 10 do begin  read(x, y);  coord[i, 1] := x; coord[i, 2] := y;  end;  for i := 1 to 10 do begin    if (coord[i, 2] = 0) and (coord[i, 1] < xminpos) then xminpos := coord[i, 1];    if (coord[i, 2] = 0) and (coord[i, 1] > xmaxpos) then xmaxpos := coord[i, 1];    if (coord[i, 2] <> 0) and (coord[i, 2] < yminpos) then yminpos := coord[i, 2];    if (coord[i, 2] <> 0) and (coord[i, 2] > ymaxpos) then ymaxpos := coord[i, 2];  end;  if (xminpos = xmaxpos) or (yminpos = ymaxpos) or (xminpos = MaxInt) then      s := 0  else s := (xmaxpos - xminpos)*(ymaxpos-yminpos)/2;  writeln(s);end.",
            "parsed": "2019-04-29 21:13:27.768118",
            "question": "На плоскости дан набор точек с целочисленными координатами. Необходимо найти четырёхугольник наибольшей площади с вершинами в этих точках, две вершины которого лежат на оси Ox, а две оставшиеся – по разные стороны от оси Ox. Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется набор данных, состоящий из 10 пар координат. Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных, состоящий из пар координат. Пар может быть много. Напишите программу для решения этой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данных.В первой строке вводится одно целое положительное число — количество точек N. Каждая из следующих N строк содержит два целых числа: сначала координата x, затем координата y очередной точки.Описание выходных данных.Программа должна вывести одно число — максимальную площадь четырёхгольника, удовлетворяющего условиям задачи. Если такого четырёхугольника не существует, программа должна вывести ноль. Пример входных данных:60 02 00 23 -35 -56 6Пример выходных данных для приведённого выше примера входных данных:11 Рассматривайте только четырёхугольники со сторонами лежащими не на оси Ox. Комментарий.В оригинальной формулировке задачи последнего условия нет, что создаёт дополнительные трудности при поиске необходимых четырёхугольников.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947206\" width=\"100%\"><p class=\"left_margin\">На плоскости дан набор точек с целочисленными координатами. Необходимо найти четырёхугольник наибольшей площади с вершинами в этих точках, две вершины которого лежат на оси Ox, а две оставшиеся – по разные стороны от оси <i>Ox</i>.<p> </p><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется набор данных, состоящий из 10 пар координат. <p class=\"left_margin\">Напишите программу для решения такой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных, состоящий из пар координат. Пар может быть много. <p class=\"left_margin\">Напишите программу для решения этой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. <i>Описание входных данных</i>.<p class=\"left_margin\">В первой строке вводится одно целое положительное число — количество точек <i>N</i>. Каждая из следующих <i>N</i> строк содержит два целых числа: сначала координата <i>x</i>, затем координата <i>y</i> очередной точки.<p><i>Описание выходных данных</i>.<p class=\"left_margin\">Программа должна вывести одно число — максимальную площадь четырёхгольника, удовлетворяющего условиям задачи. Если такого четырёхугольника не существует, программа должна вывести ноль. <p><i>Пример входных данных:</i><p class=\"left_margin\">6<p class=\"left_margin\">0 0<p class=\"left_margin\">2 0<p class=\"left_margin\">0 2<p class=\"left_margin\">3 -3<p class=\"left_margin\">5 -5<p class=\"left_margin\">6 6<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">11<p> </p><p><i>Рассматривайте только четырёхугольники со сторонами лежащими <b>не</b> на оси Ox.</i><p> </p><p><b>Комментарий.</b><p class=\"left_margin\">В оригинальной формулировке задачи последнего условия нет, что создаёт дополнительные трудности при поиске необходимых четырёхугольников.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси Ox, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси Ox будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси Ox (условие y=0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга – они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты x. Среди точек, не лежащих на оси Ox, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным инаименьшим отрицательным значением координаты y.Таким образом, задача сводится к нахождению максимального и минимального x среди точек, у которых y=0, максимального и минимального y среди остальных точек и нахождению площади четырёхугольника на основе этих данных.Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника. Пример правильной и эффективной программы на языке Паскальprogram c4;varn: integer;x, y: integer;xmin, xmax: integer;xsearch: boolean;ymin, ymax: integer;i: integer;s: real;beginxsearch := true;xmin := 0; xmax := 0;ymin:=0; ymax := 0;readln(n);for i:=1 to n do beginreadln(x,y);if y=0 then beginif xsearch or (x < xmin) then xmin:=x;if xsearch or (x > xmax) then xmax:=x;xsearch:=false;endelse if y < ymin then ymin:=yelse if y > ymax then ymax:=yend;if (xmax>xmin) and (ymin<0) and (ymax>0)then s := (xmax-xmin)*(ymax-ymin)/2else s := 0;writeln(s);end.  Пример правильной и эффективной программы на языке Бейсик DIM n AS INTEGER DIM x, y AS INTEGER DIM xmin, xmax AS INTEGER DIM xsearch AS INTEGER DIM ymin, ymax AS INTEGER DIM i AS INTEGER DIM s AS DOUBLE xsearch = 1 xmin = 0: xmax = 0 ymin = 0: ymax = 0 INPUT n FOR i = 1 TO n INPUT x, y IF y = 0 THEN IF xsearch = 1 OR x < xmin THEN xmin = x IF xsearch = 1 OR x > xmax THEN xmax = x xsearch = 0 ELSEIF y < ymin THEN ymin = y ELSEIF y > ymax THEN ymax = y END IF NEXT i IF xmax > xmin AND ymin < 0 AND ymax > 0 THEN s = (xmax - xmin) * (ymax – ymin) / 2 ELSE s = 0 END IF PRINT s Пример правильной и эффективной программы на Алгоритмическом языкеалг c4начцел nцел x,yцел xmin=0, xmax=0лог xsearch=дацел ymin=0, ymax=0цел iвещ sввод nнц для i от 1 до nввод x, yесли y=0тоесли xsearch или xесли xsearch или x>xmax то xmax:=x всеxsearch:=нетиначеесли yесли y>ymax то ymax:=y всевсекцесли xmax > xmin и ymin < 0 и ymax > 0то s:=(xmax-xmin)*(ymax-ymin)/2иначе s:=0всевывод sкон Пример решения задачи А на языке Паскаль. var  coord: array[1..10, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}  s: real; {площадь четырёхугольника}  i, j: integer;begin  xminpos := MaxInt; xmaxpos := -(MaxInt-1);  yminpos := MaxInt; ymaxpos := -(MaxInt-1);  for i := 1 to 10 do begin  read(x, y);  coord[i, 1] := x; coord[i, 2] := y;  end;  for i := 1 to 10 do begin    if (coord[i, 2] = 0) and (coord[i, 1] < xminpos) then xminpos := coord[i, 1];    if (coord[i, 2] = 0) and (coord[i, 1] > xmaxpos) then xmaxpos := coord[i, 1];    if (coord[i, 2] <> 0) and (coord[i, 2] < yminpos) then yminpos := coord[i, 2];    if (coord[i, 2] <> 0) and (coord[i, 2] > ymaxpos) then ymaxpos := coord[i, 2];  end;  if (xminpos = xmaxpos) or (yminpos = ymaxpos) or (xminpos = MaxInt) then      s := 0  else s := (xmaxpos - xminpos)*(ymaxpos-yminpos)/2;  writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6906\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси <i>Ox</i>, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси <i>Ox</i> будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси <i>Ox</i> (условие y=0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга – они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты x. Среди точек, не лежащих на оси <i>Ox</i>, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным и<p>наименьшим отрицательным значением координаты <i>y</i>.<p class=\"left_margin\">Таким образом, задача сводится к нахождению максимального и минимального x среди точек, у которых y=0, максимального и минимального y среди остальных точек и нахождению площади четырёхугольника на основе этих данных.<p class=\"left_margin\">Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p>program c4;<p>var<p>n: integer;<p>x, y: integer;<p>xmin, xmax: integer;<p>xsearch: boolean;<p>ymin, ymax: integer;<p>i: integer;<p>s: real;<p>begin<p>xsearch := true;<p>xmin := 0; xmax := 0;<p>ymin:=0; ymax := 0;<p>readln(n);<p>for i:=1 to n do begin<p>readln(x,y);<p>if y=0 then begin<p>if xsearch or (x &lt; xmin) then xmin:=x;<p>if xsearch or (x &gt; xmax) then xmax:=x;<p>xsearch:=false;<p>end<p>else if y &lt; ymin then ymin:=y<p>else if y &gt; ymax then ymax:=y<p>end;<p>if (xmax&gt;xmin) and (ymin&lt;0) and (ymax&gt;0)<p>then s := (xmax-xmin)*(ymax-ymin)/2<p>else s := 0;<p>writeln(s);<p>end.<p> </p><p> </p><p><b>Пример правильной и эффективной программы на языке Бейсик</b><p> DIM n AS INTEGER<p> DIM x, y AS INTEGER<p> DIM xmin, xmax AS INTEGER<p> DIM xsearch AS INTEGER<p> DIM ymin, ymax AS INTEGER<p> DIM i AS INTEGER<p> DIM s AS DOUBLE<p> xsearch = 1<p> xmin = 0: xmax = 0<p> ymin = 0: ymax = 0<p> INPUT n<p> FOR i = 1 TO n<p> INPUT x, y<p> IF y = 0 THEN<p> IF xsearch = 1 OR x &lt; xmin THEN xmin = x<p> IF xsearch = 1 OR x &gt; xmax THEN xmax = x<p> xsearch = 0<p> ELSEIF y &lt; ymin THEN ymin = y<p> ELSEIF y &gt; ymax THEN ymax = y<p> END IF<p> NEXT i<p> IF xmax &gt; xmin AND ymin &lt; 0 AND ymax &gt; 0 THEN<p> s = (xmax - xmin) * (ymax – ymin) / 2<p> ELSE<p> s = 0<p> END IF<p> PRINT s<p> </p><p><b>Пример правильной и эффективной программы на Алгоритмическом языке</b><p>алг c4<p>нач<p>цел n<p>цел x,y<p>цел xmin=0, xmax=0<p>лог xsearch=да<p>цел ymin=0, ymax=0<p>цел i<p>вещ s<p>ввод n<p>нц для i от 1 до n<p>ввод x, y<p>если y=0<p>то<p>если xsearch или x<xmin xmin:=\"x\" все<p=\"\" то=\"\">если xsearch или x&gt;xmax то xmax:=x все<p>xsearch:=нет<p>иначе<p>если y<ymin ymin:=\"y\" все<p=\"\" то=\"\">если y&gt;ymax то ymax:=y все<p>все<p>кц<p>если xmax &gt; xmin и ymin &lt; 0 и ymax &gt; 0<p>то s:=(xmax-xmin)*(ymax-ymin)/2<p>иначе s:=0<p>все<p>вывод s<p>кон<p> </p><p class=\"left_margin\">Пример решения задачи А на языке Паскаль.<p> </p><pre>var<p>  coord: array[1..10, 1..2] of integer; {исходные данные}<p>  x, y: integer; {координаты очередной точки}<p>  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}<p>  s: real; {площадь четырёхугольника}<p>  i, j: integer;<p>begin<p>  xminpos := MaxInt; xmaxpos := -(MaxInt-1);<p>  yminpos := MaxInt; ymaxpos := -(MaxInt-1);<p>  for i := 1 to 10 do begin<p>  read(x, y);<p>  coord[i, 1] := x; coord[i, 2] := y;<p>  end;<p>  for i := 1 to 10 do begin<p>    if (coord[i, 2] = 0) and (coord[i, 1] &lt; xminpos) then xminpos := coord[i, 1];<p>    if (coord[i, 2] = 0) and (coord[i, 1] &gt; xmaxpos) then xmaxpos := coord[i, 1];<p>    if (coord[i, 2] &lt;&gt; 0) and (coord[i, 2] &lt; yminpos) then yminpos := coord[i, 2];<p>    if (coord[i, 2] &lt;&gt; 0) and (coord[i, 2] &gt; ymaxpos) then ymaxpos := coord[i, 2];<p>  end;<p>  if (xminpos = xmaxpos) or (yminpos = ymaxpos) or (xminpos = MaxInt) then<p>      s := 0<p>  else s := (xmaxpos - xminpos)*(ymaxpos-yminpos)/2;<p>  writeln(s);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></p></p></p></p></p></p></ymin></p></p></p></xmin></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "6906"
        },
        {
            "answer": "Решение.Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси Oy, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси Oy будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси Oy (условие x = 0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга — они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты y. Среди точек, не лежащих на оси Oy, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным и наименьшим отрицательным значением координаты x. Таким образом, задача сводится к нахождению максимального и минимального y среди точек, у которых x = 0, максимального и минимального x среди остальных точек и нахождению площади четырёхугольника на основе этих данных. Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника. Пример правильной и эффективной программы на языке Паскаль program c4; var n: integer; x, y: integer; ymin, ymax: integer; ysearch: boolean; xmin, xmax: integer; i: integer; s: real; begin ysearch := true; ymin:=0; ymax := 0; xmin := 0; xmax := 0; readln(n); for i:=1 to n do begin readln(x,y); if x=0 then begin if ysearch or (y < ymin) then ymin:=y; if ysearch or (y > ymax) then ymax:=y; ysearch:=false; end else if x < xmin then xmin:=x else if x > xmax then xmax:=x end; if (ymax>ymin) and (xmin < 0) and (xmax>0) then s := (xmax-xmin)*(ymax-ymin)/2 else s := 0; writeln(s); end. Пример правильной и эффективной программы на языке Бейсик DIM n AS INTEGER DIM x, y AS INTEGER DIM ymin, ymax AS INTEGER DIM ysearch AS INTEGER DIM xmin, xmax AS INTEGER DIM i AS INTEGER DIM s AS DOUBLE ysearch = 1 ymin = 0: ymax = 0 xmin = 0: xmax = 0 INPUT n FOR i = 1 TO n INPUT x, y IF x = 0 THEN IF ysearch = 1 OR y < ymin THEN ymin = y IF ysearch = 1 OR y > ymax THEN ymax = y ysearch = 0 ELSEIF x < xmin THEN xmin = x ELSEIF x > xmax THEN xmax = x END IF  NEXT i IF ymax > ymin AND xmin < 0 AND xmax > 0 THEN s = (xmax - xmin) * (ymax – ymin) / 2 ELSE s = 0 END IF PRINT s Пример правильной, но неэффективной программы на языке Паскаль.var  coord: array[1..10000, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}  s: real; {площадь четырёхугольника}  N: integer; {количество точек}  i, j: integer;begin  readln(N);  xminpos := MaxInt; xmaxpos := -(MaxInt-1);  yminpos := MaxInt; ymaxpos := -(MaxInt-1);  for i := 1 to N do begin  read(x, y);  coord[i, 1] := x; coord[i, 2] := y;  end;  for i := 1 to N do begin    if (coord[i, 1] = 0) and (coord[i, 2]    if (coord[i, 1] = 0) and (coord[i, 2]>ymaxpos) then ymaxpos := coord[i, 2];    if (coord[i, 1] <> 0) and (coord[i, 1]    if (coord[i, 1] <> 0) and (coord[i, 1]>xmaxpos) then xmaxpos := coord[i, 1];  end;  if (yminpos = ymaxpos) or (xminpos = xmaxpos) or (yminpos = MaxInt) then      s := 0  else s := (ymaxpos - yminpos)*(xmaxpos-xminpos)/2;  writeln(s);end.",
            "parsed": "2019-04-29 21:13:20.602624",
            "question": "На плоскости дан набор точек с целочисленными координатами. Необходимо найти четырёхугольник наибольшей площади с вершинами в этих точках, две вершины которого лежат на оси Oy, а две оставшиеся — по разные стороны от оси Oy.Напишите эффективную, в том числе по памяти, программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. Описание входных данных.В первой строке вводится одно целое положительное число — количество точек N. Каждая из следующих N строк содержит два целых числа: сначала координата x, затем координата y очередной точки.Описание выходных данных.Программа должна вывести одно число — максимальную площадь четырёхугольника, удовлетворяющего условиям задачи. Если такого четырёхугольника не существует, программа должна вывести ноль.Пример входных данных: 6 0 0 2 0 0 2 3 −3 −5 −5 6 6Пример выходных данных для приведённого выше примера входных данных:11",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947686\" width=\"100%\"><p class=\"left_margin\">На плоскости дан набор точек с целочисленными координатами. Необходимо найти четырёхугольник наибольшей площади с вершинами в этих точках, две вершины которого лежат на оси <i>Oy</i>, а две оставшиеся — по разные стороны от оси <i>Oy</i>.<p class=\"left_margin\">Напишите эффективную, в том числе по памяти, программу, которая будет решать эту задачу. Перед текстом программы кратко опишите алгоритм решения задачи и укажите используемый язык программирования и его версию. <p><i>Описание входных данных</i>.<p class=\"left_margin\">В первой строке вводится одно целое положительное число — количество точек <i>N</i>. Каждая из следующих <i>N</i> строк содержит два целых числа: сначала координата x, затем координата y очередной точки.<p><i>Описание выходных данных</i>.<p class=\"left_margin\">Программа должна вывести одно число — максимальную площадь четырёхугольника, удовлетворяющего условиям задачи. Если такого четырёхугольника не существует, программа должна вывести ноль.<p><i>Пример входных данных:</i><p> 6<p> 0 0<p> 2 0<p> 0 2<p> 3 −3<p> −5 −5<p> 6 6<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">11</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси Oy, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси Oy будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси Oy (условие x = 0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга — они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты y. Среди точек, не лежащих на оси Oy, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным и наименьшим отрицательным значением координаты x. Таким образом, задача сводится к нахождению максимального и минимального y среди точек, у которых x = 0, максимального и минимального x среди остальных точек и нахождению площади четырёхугольника на основе этих данных. Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника. Пример правильной и эффективной программы на языке Паскаль program c4; var n: integer; x, y: integer; ymin, ymax: integer; ysearch: boolean; xmin, xmax: integer; i: integer; s: real; begin ysearch := true; ymin:=0; ymax := 0; xmin := 0; xmax := 0; readln(n); for i:=1 to n do begin readln(x,y); if x=0 then begin if ysearch or (y < ymin) then ymin:=y; if ysearch or (y > ymax) then ymax:=y; ysearch:=false; end else if x < xmin then xmin:=x else if x > xmax then xmax:=x end; if (ymax>ymin) and (xmin < 0) and (xmax>0) then s := (xmax-xmin)*(ymax-ymin)/2 else s := 0; writeln(s); end. Пример правильной и эффективной программы на языке Бейсик DIM n AS INTEGER DIM x, y AS INTEGER DIM ymin, ymax AS INTEGER DIM ysearch AS INTEGER DIM xmin, xmax AS INTEGER DIM i AS INTEGER DIM s AS DOUBLE ysearch = 1 ymin = 0: ymax = 0 xmin = 0: xmax = 0 INPUT n FOR i = 1 TO n INPUT x, y IF x = 0 THEN IF ysearch = 1 OR y < ymin THEN ymin = y IF ysearch = 1 OR y > ymax THEN ymax = y ysearch = 0 ELSEIF x < xmin THEN xmin = x ELSEIF x > xmax THEN xmax = x END IF  NEXT i IF ymax > ymin AND xmin < 0 AND xmax > 0 THEN s = (xmax - xmin) * (ymax – ymin) / 2 ELSE s = 0 END IF PRINT s Пример правильной, но неэффективной программы на языке Паскаль.var  coord: array[1..10000, 1..2] of integer; {исходные данные}  x, y: integer; {координаты очередной точки}  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}  s: real; {площадь четырёхугольника}  N: integer; {количество точек}  i, j: integer;begin  readln(N);  xminpos := MaxInt; xmaxpos := -(MaxInt-1);  yminpos := MaxInt; ymaxpos := -(MaxInt-1);  for i := 1 to N do begin  read(x, y);  coord[i, 1] := x; coord[i, 2] := y;  end;  for i := 1 to N do begin    if (coord[i, 1] = 0) and (coord[i, 2]    if (coord[i, 1] = 0) and (coord[i, 2]>ymaxpos) then ymaxpos := coord[i, 2];    if (coord[i, 1] <> 0) and (coord[i, 1]    if (coord[i, 1] <> 0) and (coord[i, 1]>xmaxpos) then xmaxpos := coord[i, 1];  end;  if (yminpos = ymaxpos) or (xminpos = xmaxpos) or (yminpos = MaxInt) then      s := 0  else s := (ymaxpos - yminpos)*(xmaxpos-xminpos)/2;  writeln(s);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6938\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Искомый четырёхугольник состоит из двух треугольников с общим основанием, лежащим на оси <i>Oy</i>, при этом один треугольник лежит выше этой оси, другой – ниже. Площадь четырёхугольника будет максимальной, если вершины на оси <i>Oy</i> будут расположены как можно дальше друг от друга, а вершины, не лежащие на этой оси, — как можно дальше от неё. Программа читает исходные данные, не запоминая все точки в массиве. Для каждой точки проверяется её принадлежность оси <i>Oy</i> (условие x = 0). Среди точек, лежащих на оси, необходимо найти наиболее далеко отстоящие друг от друга — они дадут наибольшее возможное общее основание двух треугольников. Это будут точки с наименьшим и наибольшим значением координаты y. Среди точек, не лежащих на оси <i>Oy</i>, надо найти две точки, расположенные по разные стороны от оси и как можно дальше от неё, — они дадут наибольшие возможные значения высот треугольников. Это будут точки с наибольшим положительным и наименьшим отрицательным значением координаты x. Таким образом, задача сводится к нахождению максимального и минимального y среди точек, у которых x = 0, максимального и минимального x среди остальных точек и нахождению площади четырёхугольника на основе этих данных. Перед выводом результата необходимо убедиться в существовании искомого четырёхугольника.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p> program c4;<p> var<p> n: integer;<p> x, y: integer;<p> ymin, ymax: integer;<p> ysearch: boolean;<p> xmin, xmax: integer;<p> i: integer;<p> s: real;<p> begin<p> ysearch := true;<p> ymin:=0; ymax := 0;<p> xmin := 0; xmax := 0;<p> readln(n);<p> for i:=1 to n do begin<p> readln(x,y);<p> if x=0 then begin<p> if ysearch or (y &lt; ymin) then ymin:=y;<p> if ysearch or (y &gt; ymax) then ymax:=y;<p> ysearch:=false;<p> end<p> else if x &lt; xmin then xmin:=x<p> else if x &gt; xmax then xmax:=x<p> end;<p> if (ymax&gt;ymin) and (xmin &lt; 0) and (xmax&gt;0)<p> then s := (xmax-xmin)*(ymax-ymin)/2<p> else s := 0;<p> writeln(s);<p> end.<p> </p><p><b>Пример правильной и эффективной программы на языке Бейсик</b><p> DIM n AS INTEGER<p> DIM x, y AS INTEGER<p> DIM ymin, ymax AS INTEGER<p> DIM ysearch AS INTEGER<p> DIM xmin, xmax AS INTEGER<p> DIM i AS INTEGER<p> DIM s AS DOUBLE<p> ysearch = 1<p> ymin = 0: ymax = 0<p> xmin = 0: xmax = 0<p> INPUT n<p> FOR i = 1 TO n<p> INPUT x, y<p> IF x = 0 THEN<p> IF ysearch = 1 OR y &lt; ymin THEN ymin = y<p> IF ysearch = 1 OR y &gt; ymax THEN ymax = y<p> ysearch = 0<p> ELSEIF x &lt; xmin THEN xmin = x<p> ELSEIF x &gt; xmax THEN xmax = x<p> END IF <p> NEXT i<p> IF ymax &gt; ymin AND xmin &lt; 0 AND xmax &gt; 0 THEN<p> s = (xmax - xmin) * (ymax – ymin) / 2<p> ELSE<p> s = 0<p> END IF<p> PRINT s<p> </p><p class=\"left_margin\"><b>Пример правильной, но неэффективной программы на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  coord: array[1..10000, 1..2] of integer; {исходные данные}<p>  x, y: integer; {координаты очередной точки}<p>  xminpos, xmaxpos, yminpos, ymaxpos: integer; {координаты точек четырёхугольника с наибольшей площадью}<p>  s: real; {площадь четырёхугольника}<p>  N: integer; {количество точек}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  xminpos := MaxInt; xmaxpos := -(MaxInt-1);<p>  yminpos := MaxInt; ymaxpos := -(MaxInt-1);<p>  for i := 1 to N do begin<p>  read(x, y);<p>  coord[i, 1] := x; coord[i, 2] := y;<p>  end;<p>  for i := 1 to N do begin<p>    if (coord[i, 1] = 0) and (coord[i, 2]<yminpos) 2];<p=\"\" :=\"coord[i,\" then=\"\" yminpos=\"\">    if (coord[i, 1] = 0) and (coord[i, 2]&gt;ymaxpos) then ymaxpos := coord[i, 2];<p>    if (coord[i, 1] &lt;&gt; 0) and (coord[i, 1]<xminpos) 1];<p=\"\" :=\"coord[i,\" then=\"\" xminpos=\"\">    if (coord[i, 1] &lt;&gt; 0) and (coord[i, 1]&gt;xmaxpos) then xmaxpos := coord[i, 1];<p>  end;<p>  if (yminpos = ymaxpos) or (xminpos = xmaxpos) or (yminpos = MaxInt) then<p>      s := 0<p>  else s := (ymaxpos - yminpos)*(xmaxpos-xminpos)/2;<p>  writeln(s);<p>end.</p></p></p></p></p></p></xminpos)></p></yminpos)></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "6938"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 10, если один из сомножителей делится на 10 (второй может быть любым), либо если ни один из сомножителей не делится на 10, но один из сомножителей делится на 2, а другой — на 5.Чтобы получить произведение, не делящееся на 10, нужно взять два сомножителя так, чтобы эти условия не выполнялись. Чтобы добиться этого, можно разбить все элементы входной последовательности на 4 непересекающихся класса чисел:- кратные 10 (класс 10);- кратные 2, но не кратные 5 (класс 2);- кратные 5, но не кратные 2 (класс 5);- не кратные ни 2, ни 5 (класс 0). Числа, кратные 10, можно сразу отбросить: они не могут участвовать в итоговом произведении. Произведение двух чисел не будет делиться на 10, если оба числа принадлежат одному классу, либо если числа принадлежатразным классам, но не классам 2 и 5. При этом для получения максимального значения следует брать максимально возможное число из каждого класса. Пусть a2 — максимальное число в классе 2, b2 — второе по величине число в классе 2, аналогичным образом обозначим два наибольших числа в классах 5 и 0. Тогда контрольным значением будет наибольшее из следующих произведений: a2*b2, a5*b5, a0*b0, a0*a2, a0*a5.Программа читает все входные данные один раз, не запоминая все данные в массиве, для каждого входного числа определяет его класс, отбрасывает числа класса 10 и хранит два наибольших числа для каждого из остальных классов. После ввода всей последовательности программа вычисляет 5 перечисленных выше произведений, выбирает из них наибольшее и сравнивает его с введённым контрольным значением. Пример правильной и эффективной программы на языке Паскальprogram c4;varN: integer; {количество чисел на входе}x: integer; {исходные данные}a2, b2: integer; {макс. числа, кратные 2, но не кратные 5}a5, b5: integer; {макс. числа, кратные 5, но не кратные 2}a0, b0: integer; {максимальные числа, не кратные 5 и 2}R: integer; {введенное контрольное значение}m: integer; {вычисленное контрольное значение}i: integer;beginreadln(N);a2:=0; b2:=0;a5:=0; b5:=0;a0:=0; b0:=0;for i:=1 to N do beginreadln(x);if x mod 10 = 0 then {ничего не делать}else if x mod 2 = 0 then beginif x>a2 then begin b2:=a2; a2:=x endelse if x>b2 then b2:=xendelse if x mod 5 = 0 then beginif x>a5 then begin b5:=a5; a5:=x endelse if x>b5 then b5:=xendelse beginif x>a0 then begin b0:=a0; a0:=x endelse if x>b0 then b0:=xendend;readln(R);m := a0*a2;if a0*a5>m then m:=a0*a5;if a0*b0>m then m:=a0*b0;if a2*b2>m then m:=a2*b2;if a5*b5>m then m:=a5*b5;writeln('Получено чисел: ', N);writeln('Принятое контрольное значение: ', R);if m>0 then writeln('Вычисленное контрольное значение: ', m);if (R>0) and (R=m)then writeln('Контроль пройден')else writeln('Контроль не пройден')end. Пример правильной и эффективной программы на языке Си#include <stdio.h>void main (){int N; /*количество чисел на входе*/int x; /*исходные данные*/int a2=0, b2=0; /*макс. числа, кратные 2, но не кратные 5*/int a5=0, b5=0; /*макс. числа, кратные 5, но не кратные 2*/int a0=0, b0=0; /*максимальные числа, не кратные 5 и 2*/int R; /*введенное контрольное значение*/int m; /*вычисленное контрольное значение*/int i;cin >> N;for (i=1; i<=N; ++i) {cin >> x;if (x % 10 == 0) continue; /*ничего не делать*/if (x % 2 == 0) {if (x>a2) {b2=a2; a2=x;}else if (x>b2) b2=x;}else if (x % 5 == 0) {if (x>a5) {b5=a5; a5=x;}else if (x>b5) b5=x;}else {if (x>a0) {b0=a0; a0=x;}else if (x>b0) b0=x;}}cin >> R;m = a0*a2;if (a0*a5>m) m=a0*a5;if (a0*b0>m) m=a0*b0;if (a2*b2>m) m=a2*b2;if (a5*b5>m) m=a5*b5;printf(\"Получено чисел: %d\\n\", N);printf(\"Принятое контрольное значение: %d\\n\", R);if (m>0) printf(\"Вычисленное контрольное значение: %d\\n\", m);if (R>0 && R==m) cout << \"Контроль пройден\\n\";else cout << \"Контроль не пройден\\n\";} Пример правильной и эффективной программы на языке БейсикDIM N AS INTEGER 'количество чисел на входеDIM x AS INTEGER 'исходные данныеDIM a2, b2 AS INTEGER 'макс. числа, кратные 2, но не кратные 5DIM a5, b5 AS INTEGER 'макс. числа, кратные 5, но не кратные 2DIM a0, b0 AS INTEGER 'максимальные числа, не кратные 5 и 2DIM R AS INTEGER 'введенное контрольное значениеDIM m AS INTEGER 'вычисленное контрольное значениеDIM i AS INTEGERINPUT NFOR i = 1 TO NINPUT xIF x MOD 10 = 0 THEN 'ничего не делатьELSEIF x MOD 2 = 0 THENIF x > a2 THENb2 = a2: a2 = xELSEIF x > b2 THEN b2 = xEND IFELSEIF x MOD 5 = 0 THENIF x > a5 THENb5 = a5: a5 = xELSEIF x > b5 THEN b5 = xEND IFELSEIF x > a0 THENb0 = a0: a0 = xELSEIF x > b0 THEN b0 = xEND IFEND IFNEXT iINPUT Rm = a0 * a2IF a0 * a5 > m THEN m = a0 * a5IF a0 * b0 > m THEN m = a0 * b0IF a2 * b2 > m THEN m = a2 * b2IF a5 * b5 > m THEN m = a5 * b5PRINT \"Получено чисел: \"; NPRINT \"Принятое контрольное значение: \"; RIF m > 0 THEN PRINT \"Вычисленное контрольное значение: \"; mIF (R > 0) AND (R = m) THENPRINT \"Контроль пройден\"ELSEPRINT \"Контроль не пройден\"END IF  Пример правильной и эффективной программы на Алгоритмическом языкеалгначцел N | количество чисел на входецел x | исходные данныецел a2=0, b2=0 | макс. числа, кратные 2, но не кратные 5цел a5=0, b5=0 | макс. числа, кратные 5, но не кратные 2цел a0=0, b0=0 | максимальные числа, не кратные 5 и 2цел R | введенное контрольное значениецел m | вычисленное контрольное значениеввод Nнц N разввод xвыборпри mod(x, 10) = 0: | ничего не делатьпри mod(x, 2) = 0:выборпри x>a2: b2:=a2; a2:=xпри x>b2: b2:=xвсепри mod(x, 5) = 0:выборпри x>a5: b5:=a5; a5:=xпри x>b5: b5:=xвсеиначевыборпри x>a0: b0:=a0; a0:=xпри x>b0: b0:=xвсевсекцввод Rm := a0*a2если a0*a5>m то m:=a0*a5 всеесли a0*b0>m то m:=a0*b0 всеесли a2*b2>m то m:=a2*b2 всеесли a5*b5>m то m:=a5*b5 всевывод \"Получено чисел: \", Nвывод нс, \"Принятое контрольное значение: \", Rесли m>0то вывод нс, \"Вычисленное контрольное значение: \", mвсеесли R>0 и R=mто вывод нс, \"Контроль пройден\"иначе вывод нс, \"Контроль не пройден\"всекон Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 10 <> 0) then max := a[i] * a[j];  readln(R);  writeln('Получено чисел: ', N);  writeln('Принятое контрольное значение: ', R);  if max>0 then writeln('Вычисленное контрольное значение: ', max);  if (R>0) and (R=max) then writeln('Контроль пройден')  else writeln('Контроль не пройден');end.",
            "parsed": "2019-04-29 21:13:14.311349",
            "question": "По каналу связи передаётся последовательность положительных целых чисел. Все числа не превышают 1000, их количество известно, но может быть очень велико. Затем передаётся контрольное значение — наибольшее число R, удовлетворяющее следующим условиям: 1) R — произведение двух различных переданных элементов последовательности («различные» означает, что не рассматриваются квадраты переданных чисел, произведения различных, но равных по величине элементов допускаются);2) R не делится на 10. В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.Напишите программу которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме: Получено чисел: …Принятое контрольное значение: …Вычисленное контрольное значение: …Контроль пройден (или Контроль не пройден) Если удовлетворяющее условию контрольное значение определить невозможно, вычисленное контрольное значение не выводится, но выводится фраза «Контроль не пройден».Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию. Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б. Входные данныеВ первой строке указывается количество чисел N. В каждой из последующихN строк записано одно натуральное число, не превышающее 1000.В последней строке записано контрольное значение.Пример входных данных:560781520105 Выходные данныеПрограмма должна напечатать отчёт по образцу, приведённому в условии.Пример выходных данных для приведённого выше примера входных данных:Получено чисел: 5Принятое контрольное значение: 105Вычисленное контрольное значение: 105Контроль пройден",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947655\" width=\"100%\"><p class=\"left_margin\">По каналу связи передаётся последовательность положительных целых чисел. Все числа не превышают 1000, их количество известно, но может быть очень велико. Затем передаётся контрольное значение — наибольшее число R, удовлетворяющее следующим условиям: <p class=\"left_margin\">1) R — произведение двух различных переданных элементов последовательности («различные» означает, что не рассматриваются квадраты переданных чисел, произведения различных, но равных по величине элементов допускаются);<p class=\"left_margin\">2) R не делится на 10.<p> </p><p class=\"left_margin\">В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.<p class=\"left_margin\">Напишите программу которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме:<p> </p><p class=\"left_margin\">Получено чисел: …<p class=\"left_margin\">Принятое контрольное значение: …<p class=\"left_margin\">Вычисленное контрольное значение: …<p class=\"left_margin\">Контроль пройден (или Контроль не пройден)<p> </p><p class=\"left_margin\">Если удовлетворяющее условию контрольное значение определить невозможно, вычисленное контрольное значение не выводится, но выводится фраза «Контроль не пройден».<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p><b>Входные данные</b><p class=\"left_margin\">В первой строке указывается количество чисел N. В каждой из последующих<p class=\"left_margin\">N строк записано одно натуральное число, не превышающее 1000.<p class=\"left_margin\">В последней строке записано контрольное значение.<p><i>Пример входных данных:</i><p class=\"left_margin\">5<p class=\"left_margin\">60<p class=\"left_margin\">7<p class=\"left_margin\">8<p class=\"left_margin\">15<p class=\"left_margin\">20<p class=\"left_margin\">105<p> </p><p><b>Выходные данные</b><p class=\"left_margin\">Программа должна напечатать отчёт по образцу, приведённому в условии.<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">Получено чисел: 5<p class=\"left_margin\">Принятое контрольное значение: 105<p class=\"left_margin\">Вычисленное контрольное значение: 105<p class=\"left_margin\">Контроль пройден</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 10, если один из сомножителей делится на 10 (второй может быть любым), либо если ни один из сомножителей не делится на 10, но один из сомножителей делится на 2, а другой — на 5.Чтобы получить произведение, не делящееся на 10, нужно взять два сомножителя так, чтобы эти условия не выполнялись. Чтобы добиться этого, можно разбить все элементы входной последовательности на 4 непересекающихся класса чисел:- кратные 10 (класс 10);- кратные 2, но не кратные 5 (класс 2);- кратные 5, но не кратные 2 (класс 5);- не кратные ни 2, ни 5 (класс 0). Числа, кратные 10, можно сразу отбросить: они не могут участвовать в итоговом произведении. Произведение двух чисел не будет делиться на 10, если оба числа принадлежат одному классу, либо если числа принадлежатразным классам, но не классам 2 и 5. При этом для получения максимального значения следует брать максимально возможное число из каждого класса. Пусть a2 — максимальное число в классе 2, b2 — второе по величине число в классе 2, аналогичным образом обозначим два наибольших числа в классах 5 и 0. Тогда контрольным значением будет наибольшее из следующих произведений: a2*b2, a5*b5, a0*b0, a0*a2, a0*a5.Программа читает все входные данные один раз, не запоминая все данные в массиве, для каждого входного числа определяет его класс, отбрасывает числа класса 10 и хранит два наибольших числа для каждого из остальных классов. После ввода всей последовательности программа вычисляет 5 перечисленных выше произведений, выбирает из них наибольшее и сравнивает его с введённым контрольным значением. Пример правильной и эффективной программы на языке Паскальprogram c4;varN: integer; {количество чисел на входе}x: integer; {исходные данные}a2, b2: integer; {макс. числа, кратные 2, но не кратные 5}a5, b5: integer; {макс. числа, кратные 5, но не кратные 2}a0, b0: integer; {максимальные числа, не кратные 5 и 2}R: integer; {введенное контрольное значение}m: integer; {вычисленное контрольное значение}i: integer;beginreadln(N);a2:=0; b2:=0;a5:=0; b5:=0;a0:=0; b0:=0;for i:=1 to N do beginreadln(x);if x mod 10 = 0 then {ничего не делать}else if x mod 2 = 0 then beginif x>a2 then begin b2:=a2; a2:=x endelse if x>b2 then b2:=xendelse if x mod 5 = 0 then beginif x>a5 then begin b5:=a5; a5:=x endelse if x>b5 then b5:=xendelse beginif x>a0 then begin b0:=a0; a0:=x endelse if x>b0 then b0:=xendend;readln(R);m := a0*a2;if a0*a5>m then m:=a0*a5;if a0*b0>m then m:=a0*b0;if a2*b2>m then m:=a2*b2;if a5*b5>m then m:=a5*b5;writeln('Получено чисел: ', N);writeln('Принятое контрольное значение: ', R);if m>0 then writeln('Вычисленное контрольное значение: ', m);if (R>0) and (R=m)then writeln('Контроль пройден')else writeln('Контроль не пройден')end. Пример правильной и эффективной программы на языке Си#include <stdio.h>void main (){int N; /*количество чисел на входе*/int x; /*исходные данные*/int a2=0, b2=0; /*макс. числа, кратные 2, но не кратные 5*/int a5=0, b5=0; /*макс. числа, кратные 5, но не кратные 2*/int a0=0, b0=0; /*максимальные числа, не кратные 5 и 2*/int R; /*введенное контрольное значение*/int m; /*вычисленное контрольное значение*/int i;cin >> N;for (i=1; i<=N; ++i) {cin >> x;if (x % 10 == 0) continue; /*ничего не делать*/if (x % 2 == 0) {if (x>a2) {b2=a2; a2=x;}else if (x>b2) b2=x;}else if (x % 5 == 0) {if (x>a5) {b5=a5; a5=x;}else if (x>b5) b5=x;}else {if (x>a0) {b0=a0; a0=x;}else if (x>b0) b0=x;}}cin >> R;m = a0*a2;if (a0*a5>m) m=a0*a5;if (a0*b0>m) m=a0*b0;if (a2*b2>m) m=a2*b2;if (a5*b5>m) m=a5*b5;printf(\"Получено чисел: %d\\n\", N);printf(\"Принятое контрольное значение: %d\\n\", R);if (m>0) printf(\"Вычисленное контрольное значение: %d\\n\", m);if (R>0 && R==m) cout << \"Контроль пройден\\n\";else cout << \"Контроль не пройден\\n\";} Пример правильной и эффективной программы на языке БейсикDIM N AS INTEGER 'количество чисел на входеDIM x AS INTEGER 'исходные данныеDIM a2, b2 AS INTEGER 'макс. числа, кратные 2, но не кратные 5DIM a5, b5 AS INTEGER 'макс. числа, кратные 5, но не кратные 2DIM a0, b0 AS INTEGER 'максимальные числа, не кратные 5 и 2DIM R AS INTEGER 'введенное контрольное значениеDIM m AS INTEGER 'вычисленное контрольное значениеDIM i AS INTEGERINPUT NFOR i = 1 TO NINPUT xIF x MOD 10 = 0 THEN 'ничего не делатьELSEIF x MOD 2 = 0 THENIF x > a2 THENb2 = a2: a2 = xELSEIF x > b2 THEN b2 = xEND IFELSEIF x MOD 5 = 0 THENIF x > a5 THENb5 = a5: a5 = xELSEIF x > b5 THEN b5 = xEND IFELSEIF x > a0 THENb0 = a0: a0 = xELSEIF x > b0 THEN b0 = xEND IFEND IFNEXT iINPUT Rm = a0 * a2IF a0 * a5 > m THEN m = a0 * a5IF a0 * b0 > m THEN m = a0 * b0IF a2 * b2 > m THEN m = a2 * b2IF a5 * b5 > m THEN m = a5 * b5PRINT \"Получено чисел: \"; NPRINT \"Принятое контрольное значение: \"; RIF m > 0 THEN PRINT \"Вычисленное контрольное значение: \"; mIF (R > 0) AND (R = m) THENPRINT \"Контроль пройден\"ELSEPRINT \"Контроль не пройден\"END IF  Пример правильной и эффективной программы на Алгоритмическом языкеалгначцел N | количество чисел на входецел x | исходные данныецел a2=0, b2=0 | макс. числа, кратные 2, но не кратные 5цел a5=0, b5=0 | макс. числа, кратные 5, но не кратные 2цел a0=0, b0=0 | максимальные числа, не кратные 5 и 2цел R | введенное контрольное значениецел m | вычисленное контрольное значениеввод Nнц N разввод xвыборпри mod(x, 10) = 0: | ничего не делатьпри mod(x, 2) = 0:выборпри x>a2: b2:=a2; a2:=xпри x>b2: b2:=xвсепри mod(x, 5) = 0:выборпри x>a5: b5:=a5; a5:=xпри x>b5: b5:=xвсеиначевыборпри x>a0: b0:=a0; a0:=xпри x>b0: b0:=xвсевсекцввод Rm := a0*a2если a0*a5>m то m:=a0*a5 всеесли a0*b0>m то m:=a0*b0 всеесли a2*b2>m то m:=a2*b2 всеесли a5*b5>m то m:=a5*b5 всевывод \"Получено чисел: \", Nвывод нс, \"Принятое контрольное значение: \", Rесли m>0то вывод нс, \"Вычисленное контрольное значение: \", mвсеесли R>0 и R=mто вывод нс, \"Контроль пройден\"иначе вывод нс, \"Контроль не пройден\"всекон Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  R: integer; {принимаемое контрольное значение}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 10 <> 0) then max := a[i] * a[j];  readln(R);  writeln('Получено чисел: ', N);  writeln('Принятое контрольное значение: ', R);  if max>0 then writeln('Вычисленное контрольное значение: ', max);  if (R>0) and (R=max) then writeln('Контроль пройден')  else writeln('Контроль не пройден');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol6971\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 10, если один из сомножителей делится на 10 (второй может быть любым), либо если ни один из сомножителей не делится на 10, но один из сомножителей делится на 2, а другой — на 5.<p class=\"left_margin\">Чтобы получить произведение, не делящееся на 10, нужно взять два сомножителя так, чтобы эти условия не выполнялись. Чтобы добиться этого, можно разбить все элементы входной последовательности на 4 непересекающихся класса чисел:<p>- кратные 10 (класс 10);<p>- кратные 2, но не кратные 5 (класс 2);<p>- кратные 5, но не кратные 2 (класс 5);<p>- не кратные ни 2, ни 5 (класс 0).<p> </p><p class=\"left_margin\">Числа, кратные 10, можно сразу отбросить: они не могут участвовать в итоговом произведении. Произведение двух чисел не будет делиться на 10, если оба числа принадлежат одному классу, либо если числа принадлежат<p>разным классам, но не классам 2 и 5. При этом для получения максимального значения следует брать максимально возможное число из каждого класса. Пусть a2 — максимальное число в классе 2, b2 — второе по величине число в классе 2, аналогичным образом обозначим два наибольших числа в классах 5 и 0. Тогда контрольным значением будет наибольшее из следующих произведений: a2*b2, a5*b5, a0*b0, a0*a2, a0*a5.<p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все данные в массиве, для каждого входного числа определяет его класс, отбрасывает числа класса 10 и хранит два наибольших числа для каждого из остальных классов. После ввода всей последовательности программа вычисляет 5 перечисленных выше произведений, выбирает из них наибольшее и сравнивает его с введённым контрольным значением.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль</b><p><div class=\"source_code lang_pascal\"><p>program c4;<p>var<p class=\"left_margin\">N: integer; {количество чисел на входе}<p>x: integer; {исходные данные}<p>a2, b2: integer; {макс. числа, кратные 2, но не кратные 5}<p>a5, b5: integer; {макс. числа, кратные 5, но не кратные 2}<p>a0, b0: integer; {максимальные числа, не кратные 5 и 2}<p class=\"left_margin\">R: integer; {введенное контрольное значение}<p>m: integer; {вычисленное контрольное значение}<p>i: integer;<p>begin<p>readln(N);<p>a2:=0; b2:=0;<p>a5:=0; b5:=0;<p>a0:=0; b0:=0;<p>for i:=1 to N do begin<p>readln(x);<p>if x mod 10 = 0 then {ничего не делать}<p>else if x mod 2 = 0 then begin<p>if x&gt;a2 then begin b2:=a2; a2:=x end<p>else if x&gt;b2 then b2:=x<p>end<p>else if x mod 5 = 0 then begin<p>if x&gt;a5 then begin b5:=a5; a5:=x end<p>else if x&gt;b5 then b5:=x<p>end<p>else begin<p>if x&gt;a0 then begin b0:=a0; a0:=x end<p>else if x&gt;b0 then b0:=x<p>end<p>end;<p>readln(R);<p>m := a0*a2;<p>if a0*a5&gt;m then m:=a0*a5;<p>if a0*b0&gt;m then m:=a0*b0;<p>if a2*b2&gt;m then m:=a2*b2;<p>if a5*b5&gt;m then m:=a5*b5;<p>writeln('Получено чисел: ', N);<p>writeln('Принятое контрольное значение: ', R);<p>if m&gt;0 then writeln('Вычисленное контрольное значение: ', m);<p>if (R&gt;0) and (R=m)<p>then writeln('Контроль пройден')<p>else writeln('Контроль не пройден')<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример правильной и эффективной программы на языке Си</b><p><div class=\"source_code lang_c\"><p>#include &lt;stdio.h&gt;<p>void main ()<p>{<p>int N; /*количество чисел на входе*/<p>int x; /*исходные данные*/<p>int a2=0, b2=0; /*макс. числа, кратные 2, но не кратные 5*/<p>int a5=0, b5=0; /*макс. числа, кратные 5, но не кратные 2*/<p>int a0=0, b0=0; /*максимальные числа, не кратные 5 и 2*/<p>int R; /*введенное контрольное значение*/<p>int m; /*вычисленное контрольное значение*/<p>int i;<p>cin &gt;&gt; N;<p>for (i=1; i&lt;=N; ++i) {<p>cin &gt;&gt; x;<p>if (x % 10 == 0) continue; /*ничего не делать*/<p>if (x % 2 == 0) {<p>if (x&gt;a2) {b2=a2; a2=x;}<p>else if (x&gt;b2) b2=x;<p>}<p>else if (x % 5 == 0) {<p>if (x&gt;a5) {b5=a5; a5=x;}<p>else if (x&gt;b5) b5=x;<p>}<p>else {<p>if (x&gt;a0) {b0=a0; a0=x;}<p>else if (x&gt;b0) b0=x;<p>}<p>}<p>cin &gt;&gt; R;<p>m = a0*a2;<p>if (a0*a5&gt;m) m=a0*a5;<p>if (a0*b0&gt;m) m=a0*b0;<p>if (a2*b2&gt;m) m=a2*b2;<p>if (a5*b5&gt;m) m=a5*b5;<p>printf(\"Получено чисел: %d\\n\", N);<p>printf(\"Принятое контрольное значение: %d\\n\", R);<p>if (m&gt;0) printf(\"Вычисленное контрольное значение: %d\\n\", m);<p>if (R&gt;0 &amp;&amp; R==m) cout &lt;&lt; \"Контроль пройден\\n\";<p>else cout &lt;&lt; \"Контроль не пройден\\n\";<p>}<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример правильной и эффективной программы на языке Бейсик</b><p><div class=\"source_code lang_basic\"><p class=\"left_margin\">DIM N AS INTEGER 'количество чисел на входе<p class=\"left_margin\">DIM x AS INTEGER 'исходные данные<p class=\"left_margin\">DIM a2, b2 AS INTEGER 'макс. числа, кратные 2, но не кратные 5<p class=\"left_margin\">DIM a5, b5 AS INTEGER 'макс. числа, кратные 5, но не кратные 2<p class=\"left_margin\">DIM a0, b0 AS INTEGER 'максимальные числа, не кратные 5 и 2<p class=\"left_margin\">DIM R AS INTEGER 'введенное контрольное значение<p class=\"left_margin\">DIM m AS INTEGER 'вычисленное контрольное значение<p class=\"left_margin\">DIM i AS INTEGER<p class=\"left_margin\">INPUT N<p class=\"left_margin\">FOR i = 1 TO N<p class=\"left_margin\">INPUT x<p class=\"left_margin\">IF x MOD 10 = 0 THEN 'ничего не делать<p class=\"left_margin\">ELSEIF x MOD 2 = 0 THEN<p class=\"left_margin\">IF x &gt; a2 THEN<p>b2 = a2: a2 = x<p class=\"left_margin\">ELSEIF x &gt; b2 THEN b2 = x<p class=\"left_margin\">END IF<p class=\"left_margin\">ELSEIF x MOD 5 = 0 THEN<p class=\"left_margin\">IF x &gt; a5 THEN<p>b5 = a5: a5 = x<p class=\"left_margin\">ELSEIF x &gt; b5 THEN b5 = x<p class=\"left_margin\">END IF<p class=\"left_margin\">ELSE<p class=\"left_margin\">IF x &gt; a0 THEN<p>b0 = a0: a0 = x<p class=\"left_margin\">ELSEIF x &gt; b0 THEN b0 = x<p class=\"left_margin\">END IF<p class=\"left_margin\">END IF<p class=\"left_margin\">NEXT i<p class=\"left_margin\">INPUT R<p>m = a0 * a2<p class=\"left_margin\">IF a0 * a5 &gt; m THEN m = a0 * a5<p class=\"left_margin\">IF a0 * b0 &gt; m THEN m = a0 * b0<p class=\"left_margin\">IF a2 * b2 &gt; m THEN m = a2 * b2<p class=\"left_margin\">IF a5 * b5 &gt; m THEN m = a5 * b5<p class=\"left_margin\">PRINT \"Получено чисел: \"; N<p class=\"left_margin\">PRINT \"Принятое контрольное значение: \"; R<p class=\"left_margin\">IF m &gt; 0 THEN PRINT \"Вычисленное контрольное значение: \"; m<p class=\"left_margin\">IF (R &gt; 0) AND (R = m) THEN<p class=\"left_margin\">PRINT \"Контроль пройден\"<p class=\"left_margin\">ELSE<p class=\"left_margin\">PRINT \"Контроль не пройден\"<p class=\"left_margin\">END IF</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p> </p><p><b>Пример правильной и эффективной программы на Алгоритмическом языке</b><p><div class=\"source_code lang_alg\"><p>алг<p>нач<p>цел N | количество чисел на входе<p>цел x | исходные данные<p>цел a2=0, b2=0 | макс. числа, кратные 2, но не кратные 5<p>цел a5=0, b5=0 | макс. числа, кратные 5, но не кратные 2<p>цел a0=0, b0=0 | максимальные числа, не кратные 5 и 2<p>цел R | введенное контрольное значение<p>цел m | вычисленное контрольное значение<p>ввод N<p>нц N раз<p>ввод x<p>выбор<p>при mod(x, 10) = 0: | ничего не делать<p>при mod(x, 2) = 0:<p>выбор<p>при x&gt;a2: b2:=a2; a2:=x<p>при x&gt;b2: b2:=x<p>все<p>при mod(x, 5) = 0:<p>выбор<p>при x&gt;a5: b5:=a5; a5:=x<p>при x&gt;b5: b5:=x<p>все<p>иначе<p>выбор<p>при x&gt;a0: b0:=a0; a0:=x<p>при x&gt;b0: b0:=x<p>все<p>все<p>кц<p>ввод R<p>m := a0*a2<p>если a0*a5&gt;m то m:=a0*a5 все<p>если a0*b0&gt;m то m:=a0*b0 все<p>если a2*b2&gt;m то m:=a2*b2 все<p>если a5*b5&gt;m то m:=a5*b5 все<p>вывод \"Получено чисел: \", N<p>вывод нс, \"Принятое контрольное значение: \", R<p>если m&gt;0<p>то вывод нс, \"Вычисленное контрольное значение: \", m<p>все<p>если R&gt;0 и R=m<p>то вывод нс, \"Контроль пройден\"<p>иначе вывод нс, \"Контроль не пройден\"<p>все<p>кон<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество элементов последовательности}<p>  R: integer; {принимаемое контрольное значение}<p>  max: integer; {вычисляемое контрольное значение}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  max := 0;<p>  for i := 1 to N do read(a[i]);<p>  for i := 1 to N-1 do<p>    for j := i+1 to N do<p>      if (a[i]*a[j] &gt; max) and (a[i]*a[j] mod 10 &lt;&gt; 0) then max := a[i] * a[j];<p>  readln(R);<p>  writeln('Получено чисел: ', N);<p>  writeln('Принятое контрольное значение: ', R);<p>  if max&gt;0 then writeln('Вычисленное контрольное значение: ', max);<p>  if (R&gt;0) and (R=max) then writeln('Контроль пройден')<p>  else writeln('Контроль не пройден');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "6971"
        },
        {
            "answer": "Решение.Считываем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.При каждом считывании данных сравниваем количество баллов с максимальным, если оно меньше или равно 200, то это то количество баллов, которое имеется у искомых школьников. Иначе, ищем тот результат, который меньше максимального, но при этом наиболее близок к нему. Найдя такой результат сохраним имя и фамилию школьника в специально отведённых для этого переменных. Если же такой результат уже есть будем увеличивать счёт в переменной, предназначенной для подсчёта участников с одинаковым количеством баллов. Пример правильной и эффективной программы на языке Паскаль: var n, i, j, spaces, max, next, cnt, points: integer;    s, name, lastName, nameNext, lastNameNext: string; var n, i, j, spaces, max, next, cnt, points, cntMax,: integer;    s, name, lastName, nameNext, lastNameNext,  nameMax, lastNameMax: string; Beginmax:= 0;cnt:=1;for i := 1 to n do    begin    readLn(s);    spaces := 0;    name := '';    lastName := '';    points := 0;    for j := 1 to length(s) do        begin        if s[j] = ' ' then            inc(spaces)        else            begin            if spaces = 0 then                name := name + s[j];            if spaces = 1 then                lastName := lastName+ s[j];            if spaces = 3 then                points := points * 10 + ord(s[j]) - 48;            end;            if points > max then             begin            next:=max;            nameNext:=nameMax;            lastNameNext:=lastNameMax;            cnt:=cntMax;            max := points;            nameMax:= name;            lastNameMax:= lastName;            cntMax:=1            if max < 201 then           begin           next:=max;           nameNext:= name;           lastNameNext:= lastName;                 cnt:=1           endelse   if (points <> max) and (points > next) then  begin  next:=points;  nameNext:= name;  lastNameNext:= lastName;  cnt:=1;  end    else if points = next then cnt:=cnt+1              else if points = max the cntMax:=cntMax+1;           end;    end;if cnt = 1 thenwrite(nameNext, ' ', lastNameNext)else  write(cnt);End.",
            "parsed": "2019-04-29 21:14:19.803687",
            "question": "Муниципальный этап олимпиады по информатике проводился для учеников 7–11-х классов. Все ученики участвовали в общем конкурсе. Каждый участник олимпиады мог набрать от 0 до 400 баллов. По положению об олимпиаде победителем признаётся участник, набравший наибольшее количество баллов, при условии, что им набрано больше половины возможных баллов. Победителей может быть несколько, если это количество баллов наберут несколько человек; а может и не быть совсем, если никто не наберёт больше половины.Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет определять фамилию и имя лучшего участника, не ставшего победителем олимпиады. Если следующий за баллом победителей один и тот же балл набрали несколько человек или если победителей нет, а лучших участников несколько (в этом случае они же являются искомыми), то должно выдаваться только число искомых участников. Гарантируется, что искомые участники (участник) имеются. На вход программе сначала подаётся число участников олимпиады N (N<10000).В каждой из следующих N строк находится результат одного из участников олимпиады в следующем формате: <Фамилия> <Имя> <класс> <баллы>, где <Фамилия> — строка, состоящая не более чем из 20 непробельных символов; <Имя> — строка, состоящая не более чем из 15 непробельных символов; <класс> — число от 7 до 11; <баллы> — целое число от 0 до 400 набранных участником баллов. <Фамилия> и <Имя>, <Имя> и <класс>, а также <класс> и <баллы> разделены одним пробелом. Пример входной строки:Иванов Пётр 10 275Программа должна выводить через пробел Фамилию и Имя искомого участника или их число. Пример выходных данных:Кузнецов ИванВторой вариант выходных данных:4",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946892\" width=\"100%\"><p class=\"left_margin\">Муниципальный этап олимпиады по информатике проводился для учеников 7–11-х классов. Все ученики участвовали в общем конкурсе. Каждый участник олимпиады мог набрать от 0 до 400 баллов. По положению об олимпиаде победителем признаётся участник, набравший наибольшее количество баллов, при условии, что им набрано больше половины возможных баллов. Победителей может быть несколько, если это количество баллов наберут несколько человек; а может и не быть совсем, если никто не наберёт больше половины.<p class=\"left_margin\">Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет определять фамилию и имя лучшего участника, не ставшего победителем олимпиады. Если следующий за баллом победителей один и тот же балл набрали несколько человек или если победителей нет, а лучших участников несколько (в этом случае они же являются искомыми), то должно выдаваться только число искомых участников. Гарантируется, что искомые участники (участник) имеются. На вход программе сначала подаётся число участников олимпиады N (N&lt;10000).<p class=\"left_margin\">В каждой из следующих N строк находится результат одного из участников олимпиады в следующем формате:<p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;класс&gt; &lt;баллы&gt;,<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 непробельных символов; &lt;Имя&gt; — строка, состоящая не более чем из 15 непробельных символов; &lt;класс&gt; — число от 7 до 11; &lt;баллы&gt; — целое число от 0 до 400 набранных участником баллов. &lt;Фамилия&gt; и &lt;Имя&gt;, &lt;Имя&gt; и &lt;класс&gt;, а также &lt;класс&gt; и &lt;баллы&gt; разделены одним пробелом. <p class=\"left_margin\">Пример входной строки:<p class=\"left_margin\">Иванов Пётр 10 275<p class=\"left_margin\">Программа должна выводить через пробел Фамилию и Имя искомого участника или их число. Пример выходных данных:<p class=\"left_margin\">Кузнецов Иван<p class=\"left_margin\">Второй вариант выходных данных:<p class=\"left_margin\">4</p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Считываем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.При каждом считывании данных сравниваем количество баллов с максимальным, если оно меньше или равно 200, то это то количество баллов, которое имеется у искомых школьников. Иначе, ищем тот результат, который меньше максимального, но при этом наиболее близок к нему. Найдя такой результат сохраним имя и фамилию школьника в специально отведённых для этого переменных. Если же такой результат уже есть будем увеличивать счёт в переменной, предназначенной для подсчёта участников с одинаковым количеством баллов. Пример правильной и эффективной программы на языке Паскаль: var n, i, j, spaces, max, next, cnt, points: integer;    s, name, lastName, nameNext, lastNameNext: string; var n, i, j, spaces, max, next, cnt, points, cntMax,: integer;    s, name, lastName, nameNext, lastNameNext,  nameMax, lastNameMax: string; Beginmax:= 0;cnt:=1;for i := 1 to n do    begin    readLn(s);    spaces := 0;    name := '';    lastName := '';    points := 0;    for j := 1 to length(s) do        begin        if s[j] = ' ' then            inc(spaces)        else            begin            if spaces = 0 then                name := name + s[j];            if spaces = 1 then                lastName := lastName+ s[j];            if spaces = 3 then                points := points * 10 + ord(s[j]) - 48;            end;            if points > max then             begin            next:=max;            nameNext:=nameMax;            lastNameNext:=lastNameMax;            cnt:=cntMax;            max := points;            nameMax:= name;            lastNameMax:= lastName;            cntMax:=1            if max < 201 then           begin           next:=max;           nameNext:= name;           lastNameNext:= lastName;                 cnt:=1           endelse   if (points <> max) and (points > next) then  begin  next:=points;  nameNext:= name;  lastNameNext:= lastName;  cnt:=1;  end    else if points = next then cnt:=cnt+1              else if points = max the cntMax:=cntMax+1;           end;    end;if cnt = 1 thenwrite(nameNext, ' ', lastNameNext)else  write(cnt);End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7216\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Считываем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.<p class=\"left_margin\">При каждом считывании данных сравниваем количество баллов с максимальным, если оно меньше или равно 200, то это то количество баллов, которое имеется у искомых школьников. Иначе, ищем тот результат, который меньше максимального, но при этом наиболее близок к нему. Найдя такой результат сохраним имя и фамилию школьника в специально отведённых для этого переменных. Если же такой результат уже есть будем увеличивать счёт в переменной, предназначенной для подсчёта участников с одинаковым количеством баллов.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p> </p><p>var n, i, j, spaces, max, next, cnt, points: integer;<p>    s, name, lastName, nameNext, lastNameNext: string;<p> </p><p>var n, i, j, spaces, max, next, cnt, points, cntMax,: integer;<p>    s, name, lastName, nameNext, lastNameNext,  nameMax, lastNameMax: string;<p> </p><p class=\"left_margin\">Begin<p>max:= 0;<p>cnt:=1;<p>for i := 1 to n do<p>    begin<p>    readLn(s);<p>    spaces := 0;<p>    name := '';<p>    lastName := '';<p>    points := 0;<p>    for j := 1 to length(s) do<p>        begin<p>        if s[j] = ' ' then<p>            inc(spaces)<p>        else<p>            begin<p>            if spaces = 0 then<p>                name := name + s[j];<p>            if spaces = 1 then<p>                lastName := lastName+ s[j];<p>            if spaces = 3 then<p>                points := points * 10 + ord(s[j]) - 48;<p>            end;<p>            if points &gt; max then <p>            begin<p>            next:=max;<p>            nameNext:=nameMax;<p>            lastNameNext:=lastNameMax;<p>            cnt:=cntMax;<p>            max := points;<p>            nameMax:= name;<p>            lastNameMax:= lastName;<p>            cntMax:=1<p>            if max &lt; 201 then<p>           begin<p>           next:=max;<p>           nameNext:= name;<p>           lastNameNext:= lastName;<p>                 cnt:=1<p>           end<p>else <p>  if (points &lt;&gt; max) and (points &gt; next) then<p>  begin<p>  next:=points;<p>  nameNext:= name;<p>  lastNameNext:= lastName;<p>  cnt:=1;<p>  end<p>    else if points = next then cnt:=cnt+1<p>              else if points = max the cntMax:=cntMax+1;  <p>         end;<p>    end;<p>if cnt = 1 then<p>write(nameNext, ' ', lastNameNext)<p>else<p>  write(cnt);<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 05.05.2014. До­сроч­ная волна. Ва­ри­ант 1.",
            "task_id": "7216"
        },
        {
            "answer": "Решение.Пусть Xi – минимально возможное время движения от A0 до Ai, а Yi — минимально возможное время движения от A0 до Bi. В точку Ai можно попасть только из точки Ai-1, поэтому Xi = Xi-1 + ai. В точку Bi можно попасть двумя способами: из точки Bi-1 и из точки Ai. Чтобы найти минимальное время, нужно вычислить время движения каждым из этих способов и выбрать из них минимальное. Получается, что Yi = min(Yi-1 + bi, Xi + t). Кроме того, очевидно, что X0 = 0, Y0 = t. Используя эти соотношения, можно найти значения Xi и Yi для всех i от 1 до N, не сохраняя всех значений asub>i",
            "parsed": "2019-04-29 21:13:28.190688",
            "question": "Гоночная трасса состоит из двух основных дорог и нескольких переездов, позволяющих перейти с одной дороги на другую. На всех участках, включая переезды, движение разрешено только в одну сторону, поэтому переезд возможен только с дороги A на дорогу B. Гонщик стартует в точке A0 и должен финишировать в точке BN. Он знает, за какое время сможет пройти каждый участок пути по каждой дороге, то есть время прохождения участков A0A1, A1A2, …, AN-1AN, B0B1, B1B2, …, BN-1BN. Время прохождения всех переездов A0B0, A1B1, …, ANBN одинаково и известно гонщику. Необходимо определить, за какое минимальное время гонщик сможет пройти трассу. Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Задание А. Имеется 10 пунктов Аi и 10 пунктов Вi, время прохождения всех переездов известно. Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеется набор данных о пунктах Ai и Bi. Напишите программу для решения этой задачи.Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся количество участков трассы N. Во второй строке задаётся целое число t — время (в секундах) прохождения каждого из переездов A0B0, A1B1, …, ANBN. В каждой из последующих N строк записано два целых числа ai и bi, задающих время (в секундах) прохождения очередного участка на каждой из дорог. В первой из этих строк указывается время прохождения участков A0A1 и B0B1, во второй — A1A2 и B1B2 и т. д.Пример входных данных320320 150200 440300 210Выходные данныеПрограмма должна напечатать одно целое число: минимально возможное время прохождения трассы (в секундах).Пример выходных данных для приведённого выше примера входных данных750",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946789\" width=\"100%\"><p class=\"left_margin\"><img src=\"/get_file?id=13479\" style=\"margin:10px auto;display:block\"/><p class=\"left_margin\">Гоночная трасса состоит из двух основных дорог и нескольких переездов, позволяющих перейти с одной дороги на другую. На всех участках, включая переезды, движение разрешено только в одну сторону, поэтому переезд возможен только с дороги A на дорогу B. Гонщик стартует в точке A<sub>0</sub> и должен финишировать в точке B<sub>N</sub>. Он знает, за какое время сможет пройти каждый участок пути по каждой дороге, то есть время прохождения участков A<sub>0</sub>A<sub>1</sub>, A<sub>1</sub>A<sub>2</sub>, …, A<sub>N-1</sub>A<sub>N</sub>, B<sub>0</sub>B<sub>1</sub>, B<sub>1</sub>B<sub>2</sub>, …, B<sub>N-1</sub>B<i>N</i>. Время прохождения всех переездов A<sub>0</sub>B<sub>0</sub>, A<sub>1</sub>B<sub>1</sub>, …, A<sub>N</sub>B<sub>N</sub> одинаково и известно гонщику. Необходимо определить, за какое минимальное время гонщик сможет пройти трассу.<p> </p><p class=\"left_margin\">Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.<p> </p><p class=\"left_margin\">Задание А. Имеется 10 пунктов А<sub>i</sub> и 10 пунктов В<sub>i</sub>, время прохождения всех переездов известно. Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> </p><p class=\"left_margin\">Задание Б. Имеется набор данных о пунктах A<sub>i</sub> и B<sub>i</sub>. Напишите программу для решения этой задачи.<p class=\"left_margin\">Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел <i>N</i>, т. е. при увеличении <i>N</i> в <i>k</i> раз время работы программы должно увеличиваться не более чем в <i>k</i> раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа <i>N</i> и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p><b><p class=\"left_margin\">Входные данные</p></b><p class=\"left_margin\">В первой строке задаётся количество участков трассы N. Во второй строке задаётся целое число t — время (в секундах) прохождения каждого из переездов A<sub>0</sub>B<sub>0</sub>, A<sub>1</sub>B<sub>1</sub>, …, A<sub>N</sub>B<sub>N</sub>. В каждой из последующих N строк записано два целых числа ai и bi, задающих время (в секундах) прохождения очередного участка на каждой из дорог. В первой из этих строк указывается время прохождения участков A<sub>0</sub>A<sub>1</sub> и B<sub>0</sub>B<sub>1</sub>, во второй — A<sub>1</sub>A<sub>2</sub> и B<sub>1</sub>B<sub>2</sub> и т. д.<p><b><p class=\"left_margin\">Пример входных данных</p></b><p class=\"left_margin\">3<p class=\"left_margin\">20<p class=\"left_margin\">320 150<p class=\"left_margin\">200 440<p class=\"left_margin\">300 210<p><b><p class=\"left_margin\">Выходные данные</p></b><p class=\"left_margin\">Программа должна напечатать одно целое число: минимально возможное время прохождения трассы (в секундах).<p><b><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных</p></b><p class=\"left_margin\">750</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Пусть Xi – минимально возможное время движения от A0 до Ai, а Yi — минимально возможное время движения от A0 до Bi. В точку Ai можно попасть только из точки Ai-1, поэтому Xi = Xi-1 + ai. В точку Bi можно попасть двумя способами: из точки Bi-1 и из точки Ai. Чтобы найти минимальное время, нужно вычислить время движения каждым из этих способов и выбрать из них минимальное. Получается, что Yi = min(Yi-1 + bi, Xi + t). Кроме того, очевидно, что X0 = 0, Y0 = t. Используя эти соотношения, можно найти значения Xi и Yi для всех i от 1 до N, не сохраняя всех значений asub>i",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7321\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Пусть X<sub>i</sub> – минимально возможное время движения от A<sub>0</sub> до A<sub>i</sub>, а Y<sub>i</sub> — минимально возможное время движения от A<sub>0</sub> до B<sub>i</sub>. В точку A<sub>i</sub> можно попасть только из точки A<sub>i-1</sub>, поэтому X<sub>i</sub> = X<sub>i-1</sub> + a<sub>i</sub>. В точку B<sub>i</sub> можно попасть двумя способами: из точки B<sub>i-1</sub> и из точки A<sub>i</sub>. Чтобы найти минимальное время, нужно вычислить время движения каждым из этих способов и выбрать из них минимальное. Получается, что Y<sub>i</sub> = min(Y<sub>i-1</sub> + b<sub>i</sub>, X<sub>i</sub> + t). Кроме того, очевидно, что X<sub>0</sub> = 0, Y<sub>0</sub> = t. Используя эти соотношения, можно найти значения X<sub>i</sub> и Y<sub>i</sub> для всех i от 1 до N, не сохраняя всех значений asub&gt;i</p></div>",
            "source": "",
            "task_id": "7321"
        },
        {
            "answer": "Решение.Пусть P0 — точка старта, P1 — первая станция, P2 — вторая, …, PN — финиш. Пусть Xi — минимально возможное время от старта до отправления из Pi, при условии, что автомобиль отправляется из Pi с колесами A, а Yi — минимально возможное время от старта до отправления из Pi, при условии, что автомобиль отправляется из Pi с колесами B. С колесами A можно выехать из Pi только при условии, что с этими же колесами автомобиль прибыл на этот пункт (установить колеса A в ходе гонки нельзя), поэтому Xi = Xi-1 + ai. Если автомобиль выехал из Pi с колесами B, они могли быть установлены либо на станции в этом пункте, либо ранее. Для нахождения Yi нужно вычислить время для каждого из этих случаев и выбрать из них меньшее. Получается, что Yi = min(Xi + t, Yi-1 + bi). Кроме того, очевидно, что X0 = 0, Y0 = 0.Используя эти соотношения, можно найти значения Xi и Yi для всех i от 1 до N, помня лишь текущие значения ai и bi. Окончательным ответом задачи будет меньшее из значений XN и YN. Примеры правильных и эффективных программ на различных языках программирования. БейсикПаскаль  INPUT N INPUT t x = 0: y = 0 FOR i = 1 TO N INPUT a, bx = x + ay1 = x + ty2 = y + b IF y1 < y2 THENy = y1 ELSEy = y2 END IF NEXT i IF x < y THEN PRINT x ELSE PRINT y END IF ENDprogram c4;varN: integer; {количество участков}t: integer; {время замены}a, b: integer; {время прохождения участков}x: integer; {текущее значение X}y: integer; {текущее значение Y}y1, y2: integer;i: integer;beginreadln(N);readln(t);x := 0; y := 0;for i := 1 to N do beginreadln(a, b);x := x + a;y1 := x + t;y2 := y + b;if y1 < y2 then y := y1else y := y2;end;if x < y then writeln(x)else writeln(y);end.СиАлгоритмический язык#include <stdio.h>void main (){int N; /* количество участков */int t; /* время замены */int a, b; /* время прохождения участков */int x; /* текущее значение X */int y; /* текущее значение Y */int y1, y2;int i;cin >> N);scanf(\"%d\" >> t;x = 0; y = 0;for (i=1; i<=N; ++i) {cin >> a >> b;x = x + a;y1 = x + t;y2 = y + b;if (y1 < y2) y = y1;else y = y2;}if (xelse printf(\"%d\\n\",y);}алгначцел N | количество участковцел t | время заменыцел a, b | время прохождения участковцел x | текущее значение Xцел y | текущее значение Yцел x, yцел y1, y2цел iввод Nввод tx:=0; y:=0нц для i от 1 до Nввод a,bx := x + ay1 := x + ty2 := y + bесли y1 < y2то y := y1иначе y := y2всекцесли x < yто вывод xиначе вывод yвсекон Пример решения задачи A на языке Паскаль. var  t: integer; {время замены}  a, b: integer; {время прохождения участков}  times: array [1..10, 1..2] of integer; {исходные данные об участках трассы}  min_time: integer; {минимальное время прохождения трассы}  val: array [1..11] of integer;  x: integer;  i, j, k: integer;begin  readln(t);  for i := 1 to 10 do begin    read(a, b);    times[i,1] := a;    times[i,2] := b;       end;  x := 3;  k := 11;  for i := 3 to 11 do begin    val[i] := t;    for j := 1 to 10 do begin      if x>k then        val[i] := val[i] + times[j, 2]      else val[i] := val[i] + times[j, 1];      x := x + 1;    end;    x := 3;    k := k-1;  end;  val[1] := 0;  val[2] := 0;  for i := 1 to 10 do begin    val[1] := val[1] + times[i,1];    val[2] := val[2] + times[i,2];  end;  min_time := MaxInt;  for i := 1 to 11 do    if val[i] < min_time then min_time := val[i];  writeln(min_time);end.",
            "parsed": "2019-04-29 21:13:28.723947",
            "question": "Автомобиль, участвующий в гонке, может быть оснащен двумя разными типами колес (A и B). Вдоль трассы расположены станции, на которых можно выполнить замену колес A на B, эта операция занимает t секунд. Замена колес B на A в ходе гонки технически невозможна. На старт можно выйти с любым комплектом. Для каждого участка между станциями известно, за какое время можно пройти этот участок с каждым из комплектов колес. Необходимо определить, за какое минимальное время можно пройти всю трассу.Напишите программу для решения этой задачи.Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию. Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.  Задание А. Имеются данные о времени прохождения участков трассы с различными типами колёс. Всего пунктов 10 штук. Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.Максимальная оценка за правильную программу – 2 балла. Задание Б. Имеются данные о времени прохождения участков трассы с различными типами колёс. Пунктов может быть очень много. Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Входные данныеВ первой строке задается количество участков трассы N. Во второй строке задается целое число t — время (в секундах) на замену колес A на B. В каждой из последующих N строк записано два целых числа ai и bi, задающих время (в секундах) прохождения очередного участка с каждым из комплектов. В первой из этих строк указывается время прохождения участка от старта до первой станции, во второй – от первой станции до второй и т. д.Пример входных данных310130 210320 140100 120Выходные данныеПрограмма должна напечатать одно целое число: минимально возможное время прохождения трассы (в секундах).Пример выходных данных для приведённого выше примера входных данных400",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946757\" width=\"100%\"><p class=\"left_margin\">Автомобиль, участвующий в гонке, может быть оснащен двумя разными типами колес (A и B). Вдоль трассы расположены станции, на которых можно выполнить замену колес A на B, эта операция занимает <i>t</i> секунд. Замена колес B на A в ходе гонки технически невозможна. На старт можно выйти с любым комплектом. Для каждого участка между станциями известно, за какое время можно пройти этот участок с каждым из комплектов колес. Необходимо определить, за какое минимальное время можно пройти всю трассу.<p class=\"left_margin\">Напишите программу для решения этой задачи.<p class=\"left_margin\">Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p> </p><p><i>Вам предлагается два задания с похожими условиями: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Задание Б более сложное, его решение оценивается выше. Итоговая оценка выставляется как максимальная из оценок за задания А и Б.</i><p> <p> </p><p class=\"left_margin\">Задание А. Имеются данные о времени прохождения участков трассы с различными типами колёс. Всего пунктов 10 штук. Напишите программу для решения этой задачи. В этом варианте задания оценивается только правильность программы, время работы и размер использованной памяти не имеют значения.<p class=\"left_margin\">Максимальная оценка за правильную программу – 2 балла.<p> <p class=\"left_margin\">Задание Б. Имеются данные о времени прохождения участков трассы с различными типами колёс. Пунктов может быть очень много. Постарайтесь сделать программу эффективной по времени и используемой памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству пар чисел N, т. е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и памяти, — 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p> </p><p><b><p class=\"left_margin\">Входные данные</p></b><p class=\"left_margin\">В первой строке задается количество участков трассы N. Во второй строке задается целое число t — время (в секундах) на замену колес A на B. В каждой из последующих N строк записано два целых числа a<sub>i</sub> и b<sub>i</sub>, задающих время (в секундах) прохождения очередного участка с каждым из комплектов. В первой из этих строк указывается время прохождения участка от старта до первой станции, во второй – от первой станции до второй и т. д.<p><b><p class=\"left_margin\">Пример входных данных</p></b><p class=\"left_margin\">3<p class=\"left_margin\">10<p class=\"left_margin\">130 210<p class=\"left_margin\">320 140<p class=\"left_margin\">100 120<p><b><p class=\"left_margin\">Выходные данные</p></b><p class=\"left_margin\">Программа должна напечатать одно целое число: минимально возможное время прохождения трассы (в секундах).<p><b><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных</p></b><p class=\"left_margin\">400</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Пусть P0 — точка старта, P1 — первая станция, P2 — вторая, …, PN — финиш. Пусть Xi — минимально возможное время от старта до отправления из Pi, при условии, что автомобиль отправляется из Pi с колесами A, а Yi — минимально возможное время от старта до отправления из Pi, при условии, что автомобиль отправляется из Pi с колесами B. С колесами A можно выехать из Pi только при условии, что с этими же колесами автомобиль прибыл на этот пункт (установить колеса A в ходе гонки нельзя), поэтому Xi = Xi-1 + ai. Если автомобиль выехал из Pi с колесами B, они могли быть установлены либо на станции в этом пункте, либо ранее. Для нахождения Yi нужно вычислить время для каждого из этих случаев и выбрать из них меньшее. Получается, что Yi = min(Xi + t, Yi-1 + bi). Кроме того, очевидно, что X0 = 0, Y0 = 0.Используя эти соотношения, можно найти значения Xi и Yi для всех i от 1 до N, помня лишь текущие значения ai и bi. Окончательным ответом задачи будет меньшее из значений XN и YN. Примеры правильных и эффективных программ на различных языках программирования. БейсикПаскаль  INPUT N INPUT t x = 0: y = 0 FOR i = 1 TO N INPUT a, bx = x + ay1 = x + ty2 = y + b IF y1 < y2 THENy = y1 ELSEy = y2 END IF NEXT i IF x < y THEN PRINT x ELSE PRINT y END IF ENDprogram c4;varN: integer; {количество участков}t: integer; {время замены}a, b: integer; {время прохождения участков}x: integer; {текущее значение X}y: integer; {текущее значение Y}y1, y2: integer;i: integer;beginreadln(N);readln(t);x := 0; y := 0;for i := 1 to N do beginreadln(a, b);x := x + a;y1 := x + t;y2 := y + b;if y1 < y2 then y := y1else y := y2;end;if x < y then writeln(x)else writeln(y);end.СиАлгоритмический язык#include <stdio.h>void main (){int N; /* количество участков */int t; /* время замены */int a, b; /* время прохождения участков */int x; /* текущее значение X */int y; /* текущее значение Y */int y1, y2;int i;cin >> N);scanf(\"%d\" >> t;x = 0; y = 0;for (i=1; i<=N; ++i) {cin >> a >> b;x = x + a;y1 = x + t;y2 = y + b;if (y1 < y2) y = y1;else y = y2;}if (xelse printf(\"%d\\n\",y);}алгначцел N | количество участковцел t | время заменыцел a, b | время прохождения участковцел x | текущее значение Xцел y | текущее значение Yцел x, yцел y1, y2цел iввод Nввод tx:=0; y:=0нц для i от 1 до Nввод a,bx := x + ay1 := x + ty2 := y + bесли y1 < y2то y := y1иначе y := y2всекцесли x < yто вывод xиначе вывод yвсекон Пример решения задачи A на языке Паскаль. var  t: integer; {время замены}  a, b: integer; {время прохождения участков}  times: array [1..10, 1..2] of integer; {исходные данные об участках трассы}  min_time: integer; {минимальное время прохождения трассы}  val: array [1..11] of integer;  x: integer;  i, j, k: integer;begin  readln(t);  for i := 1 to 10 do begin    read(a, b);    times[i,1] := a;    times[i,2] := b;       end;  x := 3;  k := 11;  for i := 3 to 11 do begin    val[i] := t;    for j := 1 to 10 do begin      if x>k then        val[i] := val[i] + times[j, 2]      else val[i] := val[i] + times[j, 1];      x := x + 1;    end;    x := 3;    k := k-1;  end;  val[1] := 0;  val[2] := 0;  for i := 1 to 10 do begin    val[1] := val[1] + times[i,1];    val[2] := val[2] + times[i,2];  end;  min_time := MaxInt;  for i := 1 to 11 do    if val[i] < min_time then min_time := val[i];  writeln(min_time);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7353\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Пусть P<sub>0</sub> — точка старта, P<sub>1</sub> — первая станция, P<sub>2</sub> — вторая, …, P<sub>N</sub> — финиш. Пусть X<sub>i</sub> — минимально возможное время от старта до отправления из P<sub>i</sub>, при условии, что автомобиль отправляется из P<sub>i</sub> с колесами A, а Y<sub>i</sub> — минимально возможное время от старта до отправления из P<sub>i</sub>, при условии, что автомобиль отправляется из P<sub>i</sub> с колесами B. С колесами A можно выехать из P<sub>i</sub> только при условии, что с этими же колесами автомобиль прибыл на этот пункт (установить колеса A в ходе гонки нельзя), поэтому X<sub>i</sub> = X<sub>i-1</sub> + a<sub>i</sub>. Если автомобиль выехал из P<sub>i</sub> с колесами B, они могли быть установлены либо на станции в этом пункте, либо ранее. Для нахождения Y<sub>i</sub> нужно вычислить время для каждого из этих случаев и выбрать из них меньшее. Получается, что <nobr>Y<sub>i</sub> = min(X<sub>i</sub> + t, Y<sub>i-1</sub> + b<sub>i</sub>).</nobr> Кроме того, очевидно, что X<sub>0</sub> = 0, Y<sub>0</sub> = 0.<p class=\"left_margin\">Используя эти соотношения, можно найти значения X<sub>i</sub> и Y<sub>i</sub> для всех <sub>i</sub> от 1 до N, помня лишь текущие значения a<sub>i</sub> и b<sub>i</sub>. Окончательным ответом задачи будет меньшее из значений X<sub>N</sub> и Y<sub>N</sub>.<p> </p><center><p><b><p class=\"left_margin\">Примеры правильных и эффективных программ на различных языках программирования.</p></b></p></center><p> </p><center><p><table border=\"\" width=\"60%\"><tr><th><b>Бейсик</b></th><th><b>Паскаль</b></th></tr><tr><td valign=\"top\"><div class=\"source_code lang_basic\"> <p> INPUT N<p> INPUT t<p> x = 0: y = 0<p> FOR i = 1 TO N<p> INPUT a, b<p>x = x + a<p>y1 = x + t<p>y2 = y + b<p> IF y1 &lt; y2 THEN<p>y = y1<p> ELSE<p>y = y2<p> END IF<p> NEXT i<p> IF x &lt; y THEN<p> PRINT x<p> ELSE<p> PRINT y<p> END IF<p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_pascal\"><p>program c4;<p>var<p class=\"left_margin\">N: integer; {количество участков}<p>t: integer; {время замены}<p>a, b: integer; {время прохождения участков}<p>x: integer; {текущее значение X}<p>y: integer; {текущее значение Y}<p>y1, y2: integer;<p>i: integer;<p>begin<p>readln(N);<p>readln(t);<p>x := 0; y := 0;<p>for i := 1 to N do begin<p>readln(a, b);<p>x := x + a;<p>y1 := x + t;<p>y2 := y + b;<p>if y1 &lt; y2 then y := y1<p>else y := y2;<p>end;<p>if x &lt; y then writeln(x)<p>else writeln(y);<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr><tr><th><b>Си</b></th><th><b>Алгоритмический язык</b></th></tr><tr><td valign=\"top\"><div class=\"source_code lang_c\"><p>#include &lt;stdio.h&gt;<p>void main ()<p>{<p>int N; /* количество участков */<p>int t; /* время замены */<p>int a, b; /* время прохождения участков */<p>int x; /* текущее значение X */<p>int y; /* текущее значение Y */<p>int y1, y2;<p>int i;<p>cin &gt;&gt; N);<p>scanf(\"%d\" &gt;&gt; t;<p>x = 0; y = 0;<p>for (i=1; i&lt;=N; ++i) {<p>cin &gt;&gt; a &gt;&gt; b;<p>x = x + a;<p>y1 = x + t;<p>y2 = y + b;<p>if (y1 &lt; y2) y = y1;<p>else y = y2;<p>}<p>if (x<y) printf(\"%d\\n\",x);<p=\"\">else printf(\"%d\\n\",y);<p>}<p></p></p></y)></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td><td><div class=\"source_code lang_alg\"><p>алг<p>нач<p>цел N | количество участков<p>цел t | время замены<p>цел a, b | время прохождения участков<p>цел x | текущее значение X<p>цел y | текущее значение Y<p>цел x, y<p>цел y1, y2<p>цел i<p>ввод N<p>ввод t<p>x:=0; y:=0<p>нц для i от 1 до N<p>ввод a,b<p>x := x + a<p>y1 := x + t<p>y2 := y + b<p>если y1 &lt; y2<p>то y := y1<p>иначе y := y2<p>все<p>кц<p>если x &lt; y<p>то вывод x<p>иначе вывод y<p>все<p>кон<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></td></tr></table><p> </p></p></center><p class=\"left_margin\">Пример решения задачи A на языке Паскаль.<p> </p><pre>var<p>  t: integer; {время замены}<p>  a, b: integer; {время прохождения участков}<p>  times: array [1..10, 1..2] of integer; {исходные данные об участках трассы}<p>  min_time: integer; {минимальное время прохождения трассы}<p>  val: array [1..11] of integer;<p>  x: integer;<p>  i, j, k: integer;<p>begin<p>  readln(t);<p>  for i := 1 to 10 do begin<p>    read(a, b);<p>    times[i,1] := a;<p>    times[i,2] := b;     <p>  end;<p>  x := 3;<p>  k := 11;<p>  for i := 3 to 11 do begin<p>    val[i] := t;<p>    for j := 1 to 10 do begin<p>      if x&gt;k then<p>        val[i] := val[i] + times[j, 2]<p>      else val[i] := val[i] + times[j, 1];<p>      x := x + 1;<p>    end;<p>    x := 3;<p>    k := k-1;<p>  end;<p>  val[1] := 0;<p>  val[2] := 0;<p>  for i := 1 to 10 do begin<p>    val[1] := val[1] + times[i,1];<p>    val[2] := val[2] + times[i,2];<p>  end;<p>  min_time := MaxInt;<p>  for i := 1 to 11 do<p>    if val[i] &lt; min_time then min_time := val[i];<p>  writeln(min_time);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></pre></p></p></p></div>",
            "source": "",
            "task_id": "7353"
        },
        {
            "answer": "Решение.Считаем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.При каждом считывании данных сравниваем количество баллов с максимальным, если текущий результат больше максимального, то записываем его вместо максимального, если он равен максимальному, увеличиваем счётчик в переменной, предназначенной для подсчёта участников с одинаковым максимальным количеством баллов. Если таких людей меньше 25% объявляем их победителями, если их больше 25% и они набрали более 300 баллов, также объявляем их победителями, если максимальны балл меньше 300, то выводим 0, показывая, что победителей нет. Пример правильной и эффективной программы на языке Паскаль.  var n, i, j, spaces, max, next, cntWinner, cntNext, points : integer;    s, name, lastName, nameWinner, lastNameWinner, nameNext, lastNameNext : string;Beginmax := 0;cntWinner:= 0;next:=0;cntNext:=0;readLn(n);for i := 1 to n do    begin    readLn(s);    spaces := 0;    name := '';    lastName := '';    points := 0;    for j := 1 to length(s) do        if s[j] = ' ' then            inc(spaces)        else            begin            if spaces = 0 then                name:= name + s[j];            if spaces = 1 then                lastName:= lastName + s[j];            if spaces = 3 then                points:= points * 10 + ord(s[j]) - 48;            end;if points > max thenbeginnameNext:=nameWinner;lastNameNext:=lastNameWinner;next:=max;cntNext:=cntMax;nameWinner:= name;lastNameWinner:= lastName;max := points;cntWinner := 1;end;if points = max then cntWinner:=cntWinner+1;else if points > next then beginnameNext:=name;lastNameNext:=lastName;next:=points;cntNext:=1;end;else if points=next then cntNext:=cntNext+1;end;if (cntWinner * 4 > n) and (max <= 300) and (cntWinner=1) then write(nameWinner,' ',lastNameWinner);if (cntWinner * 4 > n) and (max <= 300) and (cntWinner>1) then write(cntWinner);if (cntWinner * 4 > n) and (max > 300) and (cntNext=1) then write(nameNext,' ',lastNameNext);if (cntWinner * 4 > n) and (max > 300) and (cntNext>1) then write(cntNext);if (cntWinner * 4 < n) and (cntNext = 1) then write(nameNext,' ',lastNameNext);if (cntWinner * 4 < n) and (cntNext > 1) then write(cntNext);End.",
            "parsed": "2019-04-29 21:14:20.227812",
            "question": "Региональный этап олимпиады по информатике проводился для учеников 9–11-х классов. Все ученики участвовали в общем конкурсе. Каждый участник олимпиады мог набрать от 0 до 600 баллов. По положению об олимпиаде победители определяются следующим образом.1. Определяются все участники, набравшие наибольшее среди всех участников количество баллов. Они объявляются кандидатами в победители.2. Если число кандидатов составляет не более 25% всех участников олимпиады, все кандидаты считаются победителями.3. Если кандидатов в победители более 25%, то рассматривается количество баллов, набранное кандидатами в победители. Если кандидаты набрали более 300 баллов, все они объявляются победителями. Если балл, набранный кандидатами, не превышает 300 баллов, победителем не признаётся никто.Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет определять фамилию и имя лучшего участника, не ставшего победителем олимпиады. Если следующий за баллом победителей один и тот же балл набрали несколько человек или если победителей нет, а лучших участников несколько (в этом случае они же являются искомыми), то выдаётся только число искомых участников. Гарантируется, что искомые участники (участник) имеются.На вход программе сначала подаётся число участников олимпиады N(N<10000).В каждой из следующих N строк находится результат одного из участников олимпиады в следующем формате: <Фамилия> <Имя> <класс> <баллы>, где <Фамилия> — строка, состоящая не более чем из 20 непробельных символов; <Имя> — строка, состоящая не более чем из 15 непробельных символов; <класс> — число от 9 до 11; <баллы> — целое число от 0 до 600 набранных участником баллов. <Фамилия> и <Имя>, <Имя> и <класс>, а также <класс> и <баллы> разделены одним пробелом. Пример входной строки:Иванов Пётр 10 275Программа должна выводить через пробел Фамилию и Имя искомого участника или их число. Пример выходных данных:Кузнецов ИванВторой вариант выходных данных:4",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946725\" width=\"100%\"><p class=\"left_margin\">Региональный этап олимпиады по информатике проводился для учеников 9–11-х классов. Все ученики участвовали в общем конкурсе. Каждый участник олимпиады мог набрать от 0 до 600 баллов. По положению об олимпиаде победители определяются следующим образом.<p class=\"left_margin\">1. Определяются все участники, набравшие наибольшее среди всех участников количество баллов. Они объявляются кандидатами в победители.<p class=\"left_margin\">2. Если число кандидатов составляет не более 25% всех участников олимпиады, все кандидаты считаются победителями.<p class=\"left_margin\">3. Если кандидатов в победители более 25%, то рассматривается количество баллов, набранное кандидатами в победители. Если кандидаты набрали более 300 баллов, все они объявляются победителями. Если балл, набранный кандидатами, не превышает 300 баллов, победителем не признаётся никто.<p class=\"left_margin\">Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая будет определять фамилию и имя лучшего участника, не ставшего победителем олимпиады. Если следующий за баллом победителей один и тот же балл набрали несколько человек или если победителей нет, а лучших участников несколько (в этом случае они же являются искомыми), то выдаётся только число искомых участников. Гарантируется, что искомые участники (участник) имеются.<p class=\"left_margin\">На вход программе сначала подаётся число участников олимпиады N<p class=\"left_margin\">(N&lt;10000).<p class=\"left_margin\">В каждой из следующих N строк находится результат одного из участников олимпиады в следующем формате:<p> </p><p>&lt;Фамилия&gt; &lt;Имя&gt; &lt;класс&gt; &lt;баллы&gt;,<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 непробельных символов; &lt;Имя&gt; — строка, состоящая не более чем из 15 непробельных символов; &lt;класс&gt; — число от 9 до 11; &lt;баллы&gt; — целое число от 0 до 600 набранных участником баллов. &lt;Фамилия&gt; и &lt;Имя&gt;, &lt;Имя&gt; и &lt;класс&gt;, а также &lt;класс&gt; и &lt;баллы&gt; разделены одним пробелом. <p class=\"left_margin\">Пример входной строки:<p class=\"left_margin\">Иванов Пётр 10 275<p class=\"left_margin\">Программа должна выводить через пробел Фамилию и Имя искомого участника или их число. Пример выходных данных:<p class=\"left_margin\">Кузнецов Иван<p class=\"left_margin\">Второй вариант выходных данных:<p class=\"left_margin\">4</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Считаем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.При каждом считывании данных сравниваем количество баллов с максимальным, если текущий результат больше максимального, то записываем его вместо максимального, если он равен максимальному, увеличиваем счётчик в переменной, предназначенной для подсчёта участников с одинаковым максимальным количеством баллов. Если таких людей меньше 25% объявляем их победителями, если их больше 25% и они набрали более 300 баллов, также объявляем их победителями, если максимальны балл меньше 300, то выводим 0, показывая, что победителей нет. Пример правильной и эффективной программы на языке Паскаль.  var n, i, j, spaces, max, next, cntWinner, cntNext, points : integer;    s, name, lastName, nameWinner, lastNameWinner, nameNext, lastNameNext : string;Beginmax := 0;cntWinner:= 0;next:=0;cntNext:=0;readLn(n);for i := 1 to n do    begin    readLn(s);    spaces := 0;    name := '';    lastName := '';    points := 0;    for j := 1 to length(s) do        if s[j] = ' ' then            inc(spaces)        else            begin            if spaces = 0 then                name:= name + s[j];            if spaces = 1 then                lastName:= lastName + s[j];            if spaces = 3 then                points:= points * 10 + ord(s[j]) - 48;            end;if points > max thenbeginnameNext:=nameWinner;lastNameNext:=lastNameWinner;next:=max;cntNext:=cntMax;nameWinner:= name;lastNameWinner:= lastName;max := points;cntWinner := 1;end;if points = max then cntWinner:=cntWinner+1;else if points > next then beginnameNext:=name;lastNameNext:=lastName;next:=points;cntNext:=1;end;else if points=next then cntNext:=cntNext+1;end;if (cntWinner * 4 > n) and (max <= 300) and (cntWinner=1) then write(nameWinner,' ',lastNameWinner);if (cntWinner * 4 > n) and (max <= 300) and (cntWinner>1) then write(cntWinner);if (cntWinner * 4 > n) and (max > 300) and (cntNext=1) then write(nameNext,' ',lastNameNext);if (cntWinner * 4 > n) and (max > 300) and (cntNext>1) then write(cntNext);if (cntWinner * 4 < n) and (cntNext = 1) then write(nameNext,' ',lastNameNext);if (cntWinner * 4 < n) and (cntNext > 1) then write(cntNext);End.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7385\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Считаем данные. Для этого будем идти по каждой строке и считать количество пройденных пробелов. Если прошли ноль пробелов, то текущий символ надо отнести к имени, если один, то к фамилии, если два, то игнорируем, т. к. класс не важен, и, если три, то относим символ к количеству баллов.<p class=\"left_margin\">При каждом считывании данных сравниваем количество баллов с максимальным, если текущий результат больше максимального, то записываем его вместо максимального, если он равен максимальному, увеличиваем счётчик в переменной, предназначенной для подсчёта участников с одинаковым максимальным количеством баллов. Если таких людей меньше 25% объявляем их победителями, если их больше 25% и они набрали более 300 баллов, также объявляем их победителями, если максимальны балл меньше 300, то выводим 0, показывая, что победителей нет.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль.<p> </p><p> </p><p>var n, i, j, spaces, max, next, cntWinner, cntNext, points : integer;<p>    s, name, lastName, nameWinner, lastNameWinner, nameNext, lastNameNext : string;<p class=\"left_margin\">Begin<p>max := 0;<p>cntWinner:= 0;<p>next:=0;<p>cntNext:=0;<p>readLn(n);<p>for i := 1 to n do<p>    begin<p>    readLn(s);<p>    spaces := 0;<p>    name := '';<p>    lastName := '';<p>    points := 0;<p>    for j := 1 to length(s) do<p>        if s[j] = ' ' then<p>            inc(spaces)<p>        else<p>            begin<p>            if spaces = 0 then<p>                name:= name + s[j];<p>            if spaces = 1 then<p>                lastName:= lastName + s[j];<p>            if spaces = 3 then<p>                points:= points * 10 + ord(s[j]) - 48;<p>            end;<p>if points &gt; max then<p>begin<p>nameNext:=nameWinner;<p>lastNameNext:=lastNameWinner;<p>next:=max;<p>cntNext:=cntMax;<p>nameWinner:= name;<p>lastNameWinner:= lastName;<p>max := points;<p>cntWinner := 1;<p>end;<p>if points = max then cntWinner:=cntWinner+1;<p>else if points &gt; next then <p>begin<p>nameNext:=name;<p>lastNameNext:=lastName;<p>next:=points;<p>cntNext:=1;<p>end;<p>else if points=next then cntNext:=cntNext+1;<p>end;<p>if (cntWinner * 4 &gt; n) and (max &lt;= 300) and (cntWinner=1) then write(nameWinner,' ',lastNameWinner);<p>if (cntWinner * 4 &gt; n) and (max &lt;= 300) and (cntWinner&gt;1) then write(cntWinner);<p>if (cntWinner * 4 &gt; n) and (max &gt; 300) and (cntNext=1) then write(nameNext,' ',lastNameNext);<p>if (cntWinner * 4 &gt; n) and (max &gt; 300) and (cntNext&gt;1) then write(cntNext);<p>if (cntWinner * 4 &lt; n) and (cntNext = 1) then write(nameNext,' ',lastNameNext);<p>if (cntWinner * 4 &lt; n) and (cntNext &gt; 1) then write(cntNext);<p class=\"left_margin\">End.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 05.05.2014. До­сроч­ная волна. Ва­ри­ант 2.",
            "task_id": "7385"
        },
        {
            "answer": "Решение.Программа верно читает входные данные, сразу запоминая только время ухода в массиве, соответствующем столикам. Подходящий столик определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания, не превосходящее времени прихода текущего посетителя. В случае удачного выбора столика фамилия посетителя и номер столика распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, желающих меньше, чем столиков). Время при считывании удобно перевести в минуты и в этом же виде хранить. Пример правильной и эффективной программы на языке Паскаль: var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {cчитана фамилия}read(c,c1); {cчитаны чаcы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и cчитаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(c,c,c1); {cчитаны чаcы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и cчитаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;endend;end.  Пример правильной и эффективной программы на языке Бейсик:  DIM p(1000) AS INTEGER  DIM s AS STRING  DIM nm AS STRING INPUT n INPUT k FOR i = 1 TO k p(i) = 0  NEXT i FOR j = 1 TO n LINE INPUT s c$ = MID$(s, 1, 1) i = 1  WHILE NOT (c$ = \" \") i = i + 1 c$ = MID$(s, i, 1)  WEND nm = MID$(s, 1, i) time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10 time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60 time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10 time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\")) time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10 time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60 time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10 time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\")) FOR i = 1 TO k IF time1 >= p(i) THEN p(i) = time2 PRINT nm, i  GOTO 10 ENDIF  NEXT i 10 NEXT j END",
            "parsed": "2019-04-29 21:14:01.228127",
            "question": "На вход программе подаются сведения о посетителях, желающих попасть в популярное кафе. В первой строке сообщается число желающих N, которое не меньше 10, но не превосходит 1000, и количество столиков, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:  <Фамилия> <время прихода> < время ухода>,  где <Фамилия> — строка, состоящая не более чем из 20 символов; <время прихода> — через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа); <время ухода> имеет тот же формат. <Фамилия> и <время прихода>, а также <время прихода> и <время ухода> разделены одним пробелом. Сведения отсортированы в порядке времени прихода. Каждому следующему посетителю выделяется свободный столик с минимальным номером. Если в момент прихода свободных столиков нет, то посетитель уходит, не дожидаясь освобождения одного из них. Требуется написать эффективную программу, которая будет выводить на экран для каждого посетителя номер столика, который ему будет предоставлен (можно сразу после ввода данных очередного посетителя). Укажите используемую версию языка программирования, например Borland Pascal 7.0.  Пример входных данных:3 10Иванов 09:45 12:00Петров 10:00 11:00Сидоров 12:00 13:12 Результат работы программы на этих входных данных:Иванов 1Петров 2Сидоров 1",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946688\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о посетителях, желающих попасть в популярное кафе. В первой строке сообщается число желающих N, которое не меньше 10, но не превосходит 1000, и количество столиков, которое не меньше 10, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат: <p> </p><p>&lt;Фамилия&gt; &lt;время прихода&gt; &lt; время ухода&gt;, <p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 символов; &lt;время прихода&gt; — через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа); &lt;время ухода&gt; имеет тот же формат. &lt;Фамилия&gt; и &lt;время прихода&gt;, а также &lt;время прихода&gt; и &lt;время ухода&gt; разделены одним пробелом. <p class=\"left_margin\">Сведения отсортированы в порядке времени прихода. Каждому следующему посетителю выделяется свободный столик с минимальным номером. Если в момент прихода свободных столиков нет, то посетитель уходит, не дожидаясь освобождения одного из них. <p class=\"left_margin\">Требуется написать эффективную программу, которая будет выводить на экран для каждого посетителя номер столика, который ему будет предоставлен (можно сразу после ввода данных очередного посетителя). Укажите используемую версию языка программирования, например Borland Pascal 7.0. <p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3 10<p class=\"left_margin\">Иванов 09:45 12:00<p class=\"left_margin\">Петров 10:00 11:00<p class=\"left_margin\">Сидоров 12:00 13:12<p> </p><p class=\"left_margin\">Результат работы программы на этих входных данных:<p class=\"left_margin\">Иванов 1<p class=\"left_margin\">Петров 2<p class=\"left_margin\">Сидоров 1</p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа верно читает входные данные, сразу запоминая только время ухода в массиве, соответствующем столикам. Подходящий столик определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания, не превосходящее времени прихода текущего посетителя. В случае удачного выбора столика фамилия посетителя и номер столика распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, желающих меньше, чем столиков). Время при считывании удобно перевести в минуты и в этом же виде хранить. Пример правильной и эффективной программы на языке Паскаль: var p:array[1..1000] of integer;c,c1:char;i,j,N,K:integer;name:string;time1,time2:integer;beginreadln(N,K);for i:=1 to K dop[i]:=0;for i:=1 to N dobeginname:='';repeatread(c);name:=name+cuntil c=' '; {cчитана фамилия}read(c,c1); {cчитаны чаcы первого времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));read(c,c,c1); {пропущено двоеточие, и cчитаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');read(c,c,c1); {cчитаны чаcы второго времени}time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и cчитаны минуты}time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');for j:=1 to K doif p[j]<=time1 thenbeginp[j]:=time2;writeln(name,' ',j);break;endend;end.  Пример правильной и эффективной программы на языке Бейсик:  DIM p(1000) AS INTEGER  DIM s AS STRING  DIM nm AS STRING INPUT n INPUT k FOR i = 1 TO k p(i) = 0  NEXT i FOR j = 1 TO n LINE INPUT s c$ = MID$(s, 1, 1) i = 1  WHILE NOT (c$ = \" \") i = i + 1 c$ = MID$(s, i, 1)  WEND nm = MID$(s, 1, i) time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10 time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60 time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10 time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\")) time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10 time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60 time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10 time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\")) FOR i = 1 TO k IF time1 >= p(i) THEN p(i) = time2 PRINT nm, i  GOTO 10 ENDIF  NEXT i 10 NEXT j END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7420\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа верно читает входные данные, сразу запоминая только время ухода в массиве, соответствующем столикам. Подходящий столик определяется путём последовательного просмотра элементов этого массива до первого свободного или такого, в котором записано время окончания, не превосходящее времени прихода текущего посетителя. В случае удачного выбора столика фамилия посетителя и номер столика распечатываются. Баллы начисляются только за программу, которая решает задачу хотя бы для частного случая (например, желающих меньше, чем столиков). Время при считывании удобно перевести в минуты и в этом же виде хранить.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p> </p><p>var p:array[1..1000] of integer;<p>c,c1:char;<p>i,j,N,K:integer;<p>name:string;<p>time1,time2:integer;<p>begin<p>readln(N,K);<p>for i:=1 to K do<p>p[i]:=0;<p>for i:=1 to N do<p>begin<p>name:='';<p>repeat<p>read(c);<p>name:=name+c<p>until c=' '; {cчитана фамилия}<p>read(c,c1); {cчитаны чаcы первого времени}<p>time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>read(c,c,c1); {пропущено двоеточие, и cчитаны минуты}<p>time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>read(c,c,c1); {cчитаны чаcы второго времени}<p>time2:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>readln(c,c,c1); {пропущено двоеточие, и cчитаны минуты}<p>time2:=time2+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>for j:=1 to K do<p>if p[j]&lt;=time1 then<p>begin<p>p[j]:=time2;<p>writeln(name,' ',j);<p>break;<p>end<p>end;<p>end.<p> </p><p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Бейсик:<p> </p><p> DIM p(1000) AS INTEGER <p> DIM s AS STRING <p> DIM nm AS STRING<p> INPUT n<p> INPUT k<p> FOR i = 1 TO k<p> p(i) = 0 <p> NEXT i<p> FOR j = 1 TO n<p> LINE INPUT s<p> c$ = MID$(s, 1, 1)<p> i = 1 <p> WHILE NOT (c$ = \" \")<p> i = i + 1<p> c$ = MID$(s, i, 1) <p> WEND<p> nm = MID$(s, 1, i)<p> time1 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10<p> time1 = time1 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60<p> time1 = time1 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10<p> time1 = time1 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))<p> time2 = (ASC(MID$(s, i + 7, 1)) - ASC(\"0\")) * 60 * 10<p> time2 = time2 + (ASC(MID$(s, i + 8, 1)) - ASC(\"0\")) * 60<p> time2 = time2 + (ASC(MID$(s, i + 10, 1)) - ASC(\"0\")) * 10<p> time2 = time2 + (ASC(MID$(s, i + 11, 1)) - ASC(\"0\"))<p> FOR i = 1 TO k<p> IF time1 &gt;= p(i) THEN<p> p(i) = time2<p> PRINT nm, i <p> GOTO 10<p> ENDIF <p> NEXT i<p> 10 NEXT j<p> END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 08.05.2014. До­сроч­ная волна, ре­зерв­ный день. Ва­ри­ант 201.",
            "task_id": "7420"
        },
        {
            "answer": "Решение.Программа верно читает входные данные, сразу запоминая только фамилии и значения времени окончания брони в массиве тех, у которых она должна закончиться в ближайшие 3 часа. Время при считывании удобно перевести в минуты и в этом виде хранить и сравнивать. Затем полученный массив значений времени сортируется по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы массива с фамилиями (возможно использование одного массива записей, состоящих из двух полей). Печатаются элементы массива фамилий в полученном в результате сортировки порядке. Пример правильной и эффективной программы на языке Паскаль: type pp=recordname:string[20];time:integer;end;varp:array[1..1000]of pp;q:pp;c,c1:char;i,j,N,time1:integer;beginread(c,c1); {считаны часы текущего времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');readln(N);j:=1;for i:=1 to N dobeginp[j].name:='';repeatread(c);p[j].name:=p[j].name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы}p[j].time:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}p[j].time:=p[j].time+(ord(c)-ord('0'))*10+ord(c1)-ord('0');if (p[j].time>=time1)and(p[j].time<=time1+180)thenj:=j+1; {данные занесены в массив}end;N:=j-1;for i:=1 to N-1 do {сортируем данные}for j:=1 to N-i doif p[j].time>p[j+1].time thenbeginq:=p[j];p[j]:=p[j+1];p[j+1]:=q;end;for i:=1 to n dowriteln(p[i].name);end. Пример правильной и эффективной программы на языке Бейсик:  DIM t(1000) AS INTEGER DIM m(1000) AS STRING * 20 DIM s AS STRING   DIM nm AS STRING LINE INPUT s time1 = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 60 * 10 time1 = time1 + (ASC(MID$(s, 2, 1)) - ASC(\"0\")) * 60 time1 = time1 + (ASC(MID$(s, 4, 1)) - ASC(\"0\")) * 10 time1 = time1 + (ASC(MID$(s, 5, 1)) - ASC(\"0\")) INPUT N k = 0 FOR j = 1 TO N LINE INPUT s c$ = MID$(s, 1, 1) i = 1  WHILE NOT (c$ = \" \") i = i + 1 c$ = MID$(s, i, 1)  WEND nm = MID$(s, 1, i) time2 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10 time2 = time2 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60 time2 = time2 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10 time2 = time2 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\")) IF time2 >= time1 AND time2 <= time1 + 180 THEN k = k + 1 t(k) = time2  m(k) = nm ENDIF NEXT j FOR i = 1 TO k - 1 FOR j = 1 TO k - i IF t(j) > t(j + 1) THEN time2 = t(j): nm = m(j) t(j) = t(j + 1): m(j) = m(j + 1) t(j + 1) = time2: m(j + 1) = nm ENDIF NEXT j  NEXT i FOR i = 1 TO k PRINT m(i) NEXT i END",
            "parsed": "2019-04-29 21:14:01.623107",
            "question": "На вход программе подаются сведения о пассажирах, забронировавших по Интернету авиабилеты (только тех, у кого время бронирования ещё не истекло). В первой строке задано текущее время: через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа). Во второй строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат: <Фамилия> <время окончания брони>, где <Фамилия> — строка, состоящая не более чем из 20 непробельных символов; <время окончания брони> — через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа). <Фамилия> и <время окончания брони> разделены одним пробелом. Сведения отсортированы в порядке времени, когда производилось бронирование. Все значения времени относятся к текущим суткам. Требуется написать эффективную программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая в хронологическом порядке (т.е. в порядке возрастания значения времени окончания брони) выведет фамилии пассажиров, у которых в ближайшие 3 часа закончится бронь.  Пример входных данных:10:003Иванов 13:00Петров 10:00Сидоров 13:12 Результат работы программы на этих входных данных:ПетровИванов",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947196\" width=\"100%\"><p class=\"left_margin\">На вход программе подаются сведения о пассажирах, забронировавших по Интернету авиабилеты (только тех, у кого время бронирования ещё не истекло). В первой строке задано текущее время: через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа). Во второй строке сообщается число пассажиров N, которое не меньше 3, но не превосходит 1000. Каждая из следующих N строк имеет следующий формат:<p> </p><p>&lt;Фамилия&gt; &lt;время окончания брони&gt;,<p> </p><p>где &lt;Фамилия&gt; — строка, состоящая не более чем из 20 непробельных символов; &lt;время окончания брони&gt; — через двоеточие два целых числа, соответствующие часам (от 00 до 23 — ровно 2 символа) и минутам (от 00 до 59 — ровно 2 символа). &lt;Фамилия&gt; и &lt;время окончания брони&gt; разделены одним пробелом. Сведения отсортированы в порядке времени, когда производилось бронирование. Все значения времени относятся к текущим суткам. <p class=\"left_margin\">Требуется написать эффективную программу (укажите используемую версию языка программирования, например Borland Pascal 7.0), которая в хронологическом порядке (т.е. в порядке возрастания значения времени окончания брони) выведет фамилии пассажиров, у которых в ближайшие 3 часа закончится бронь. <p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">10:00<p class=\"left_margin\">3<p class=\"left_margin\">Иванов 13:00<p class=\"left_margin\">Петров 10:00<p class=\"left_margin\">Сидоров 13:12<p> </p><p class=\"left_margin\">Результат работы программы на этих входных данных:<p class=\"left_margin\">Петров<p class=\"left_margin\">Иванов</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Программа верно читает входные данные, сразу запоминая только фамилии и значения времени окончания брони в массиве тех, у которых она должна закончиться в ближайшие 3 часа. Время при считывании удобно перевести в минуты и в этом виде хранить и сравнивать. Затем полученный массив значений времени сортируется по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы массива с фамилиями (возможно использование одного массива записей, состоящих из двух полей). Печатаются элементы массива фамилий в полученном в результате сортировки порядке. Пример правильной и эффективной программы на языке Паскаль: type pp=recordname:string[20];time:integer;end;varp:array[1..1000]of pp;q:pp;c,c1:char;i,j,N,time1:integer;beginread(c,c1); {считаны часы текущего времени}time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');readln(N);j:=1;for i:=1 to N dobeginp[j].name:='';repeatread(c);p[j].name:=p[j].name+cuntil c=' '; {считана фамилия}read(c,c1); {считаны часы}p[j].time:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));readln(c,c,c1); {пропущено двоеточие, и считаны минуты}p[j].time:=p[j].time+(ord(c)-ord('0'))*10+ord(c1)-ord('0');if (p[j].time>=time1)and(p[j].time<=time1+180)thenj:=j+1; {данные занесены в массив}end;N:=j-1;for i:=1 to N-1 do {сортируем данные}for j:=1 to N-i doif p[j].time>p[j+1].time thenbeginq:=p[j];p[j]:=p[j+1];p[j+1]:=q;end;for i:=1 to n dowriteln(p[i].name);end. Пример правильной и эффективной программы на языке Бейсик:  DIM t(1000) AS INTEGER DIM m(1000) AS STRING * 20 DIM s AS STRING   DIM nm AS STRING LINE INPUT s time1 = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 60 * 10 time1 = time1 + (ASC(MID$(s, 2, 1)) - ASC(\"0\")) * 60 time1 = time1 + (ASC(MID$(s, 4, 1)) - ASC(\"0\")) * 10 time1 = time1 + (ASC(MID$(s, 5, 1)) - ASC(\"0\")) INPUT N k = 0 FOR j = 1 TO N LINE INPUT s c$ = MID$(s, 1, 1) i = 1  WHILE NOT (c$ = \" \") i = i + 1 c$ = MID$(s, i, 1)  WEND nm = MID$(s, 1, i) time2 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10 time2 = time2 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60 time2 = time2 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10 time2 = time2 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\")) IF time2 >= time1 AND time2 <= time1 + 180 THEN k = k + 1 t(k) = time2  m(k) = nm ENDIF NEXT j FOR i = 1 TO k - 1 FOR j = 1 TO k - i IF t(j) > t(j + 1) THEN time2 = t(j): nm = m(j) t(j) = t(j + 1): m(j) = m(j + 1) t(j + 1) = time2: m(j + 1) = nm ENDIF NEXT j  NEXT i FOR i = 1 TO k PRINT m(i) NEXT i END",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7424\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Программа верно читает входные данные, сразу запоминая только фамилии и значения времени окончания брони в массиве тех, у которых она должна закончиться в ближайшие 3 часа. Время при считывании удобно перевести в минуты и в этом виде хранить и сравнивать. Затем полученный массив значений времени сортируется по неубыванию любым алгоритмом сортировки, параллельно переставляются и элементы массива с фамилиями (возможно использование одного массива записей, состоящих из двух полей). Печатаются элементы массива фамилий в полученном в результате сортировки порядке.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль:<p> </p><p>type pp=record<p>name:string[20];<p>time:integer;<p>end;<p>var<p>p:array[1..1000]of pp;<p>q:pp;<p>c,c1:char;<p>i,j,N,time1:integer;<p>begin<p>read(c,c1); {считаны часы текущего времени}<p>time1:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>readln(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>time1:=time1+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>readln(N);<p>j:=1;<p>for i:=1 to N do<p>begin<p>p[j].name:='';<p>repeat<p>read(c);<p>p[j].name:=p[j].name+c<p>until c=' '; {считана фамилия}<p>read(c,c1); {считаны часы}<p>p[j].time:=60*((ord(c)-ord('0'))*10+ ord(c1)-ord('0'));<p>readln(c,c,c1); {пропущено двоеточие, и считаны минуты}<p>p[j].time:=p[j].time+(ord(c)-ord('0'))*10+ord(c1)-ord('0');<p>if (p[j].time&gt;=time1)and(p[j].time&lt;=time1+180)then<p>j:=j+1; {данные занесены в массив}<p>end;<p class=\"left_margin\">N:=j-1;<p>for i:=1 to N-1 do {сортируем данные}<p>for j:=1 to N-i do<p>if p[j].time&gt;p[j+1].time then<p>begin<p>q:=p[j];<p>p[j]:=p[j+1];<p>p[j+1]:=q;<p>end;<p>for i:=1 to n do<p>writeln(p[i].name);<p>end.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Бейсик:<p> </p><p> DIM t(1000) AS INTEGER<p> DIM m(1000) AS STRING * 20<p> DIM s AS STRING  <p> DIM nm AS STRING<p> LINE INPUT s<p> time1 = (ASC(MID$(s, 1, 1)) - ASC(\"0\")) * 60 * 10<p> time1 = time1 + (ASC(MID$(s, 2, 1)) - ASC(\"0\")) * 60<p> time1 = time1 + (ASC(MID$(s, 4, 1)) - ASC(\"0\")) * 10<p> time1 = time1 + (ASC(MID$(s, 5, 1)) - ASC(\"0\"))<p> INPUT N<p> k = 0<p> FOR j = 1 TO N<p> LINE INPUT s<p> c$ = MID$(s, 1, 1)<p> i = 1 <p> WHILE NOT (c$ = \" \")<p> i = i + 1<p> c$ = MID$(s, i, 1) <p> WEND<p> nm = MID$(s, 1, i)<p> time2 = (ASC(MID$(s, i + 1, 1)) - ASC(\"0\")) * 60 * 10<p> time2 = time2 + (ASC(MID$(s, i + 2, 1)) - ASC(\"0\")) * 60<p> time2 = time2 + (ASC(MID$(s, i + 4, 1)) - ASC(\"0\")) * 10<p> time2 = time2 + (ASC(MID$(s, i + 5, 1)) - ASC(\"0\"))<p> IF time2 &gt;= time1 AND time2 &lt;= time1 + 180 THEN<p> k = k + 1<p> t(k) = time2 <p> m(k) = nm<p> ENDIF<p> NEXT j<p> FOR i = 1 TO k - 1<p> FOR j = 1 TO k - i<p> IF t(j) &gt; t(j + 1) THEN<p> time2 = t(j): nm = m(j)<p> t(j) = t(j + 1): m(j) = m(j + 1)<p> t(j + 1) = time2: m(j + 1) = nm<p> ENDIF<p> NEXT j <p> NEXT i<p> FOR i = 1 TO k<p> PRINT m(i)<p> NEXT i<p> END</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: ЕГЭ по ин­фор­ма­ти­ке 08.05.2014. До­сроч­ная волна, ре­зерв­ный день. Ва­ри­ант 202.",
            "task_id": "7424"
        },
        {
            "answer": "Решение.Будем по очереди обрабатывать строчки. Для этого будем посимвольно «пропускать» названия компаний и улиц, так как они не нужны. После чего считывать вид и цену. Для каждого вида у нас будет ячейка в массиве min и ячейка в массиве cnt, которые показывают, какой на данный момент минимум и сколько их соответственно. Если новая цена меньше предыдущей, то запомним её и поставим cnt равным единице. Если новая цена равна минимальной, то просто увеличим cnt на единицу. Изначально все min проинициализируем  1000, большим значением, которого точно не будет. Приведём код на языке Pascal:var n, i, ind, cost : integer;\tbuf : char;\tmin, cnt : array[1..3] of integer;beginfor i := 1 to 3 do\tbegin\tmin[i] := 1000;\tcnt[i] := 0;\tend;readLn(n);for i := 1 to n do\tbegin\twhile buf <> ' ' do  \t\tread(buf);\tread(buf);\twhile buf <> ' ' do  \t\tread(buf);\tread(buf);\tif buf = 'Б' then  \t\tind := 1;\tif buf = 'К' then  \t\tind := 2;\tif buf = 'Ж' then  \t\tind := 3;\treadLn(cost);\tif cost = min[ind] then  \t\tinc(cnt[ind]);\tif cost < min[ind] then  \t\tbegin  \t\tmin[ind] := cost;  \t\tcnt[ind] := 1;  \t\tend;\tend;writeLn(cnt[1], ' ', cnt[2], ' ', cnt[3]);end.",
            "parsed": "2019-04-29 21:14:02.033482",
            "question": "В цветочных лавках продают три вида роз (белые, красные и желтые). В городе N была проведена оценка цены роз. Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида роз, сколько лавок продают их дешевле всего. На вход программе в первой строке подается число данных N о стоимости роз. В каждой из последующих N строк находится информация в следующем формате:  <Компания><Улица><Вид><Цена> где <Компания> — строка, состоящая не более, чем из 20 символов без пробелов, <Улица> — строка, состоящая не более, чем из 20 символов без пробелов, <Вид> — символ Б, К или Ж, <Цена> — целое число в диапазоне от 100 до 500, обозначающее стоимость одной розы. <Компания> и <Улица>, <Улица> и <Вид>, а также <Вид> и <Цена> разделены ровно одним пробелом.  Пример входной строки: ТоргЦвет Садовая Ж 225  Программа должна выводить через пробел 3 числа – количество лавок, продающих дешевле всего белые, красные и желтые розы соответственно. Если роза какого-то вида нигде не продается, то следует вывести 0.  Пример выходных данных: 7 5 0",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947192\" width=\"100%\"><p class=\"left_margin\">В цветочных лавках продают три вида роз (белые, красные и желтые). В городе N была проведена оценка цены роз. Напишите эффективную по времени работы и по используемой памяти программу (укажите используемую версию языка программирования, например, Borland Pascal 7.0), которая будет определять для каждого вида роз, сколько лавок продают их дешевле всего. <p class=\"left_margin\">На вход программе в первой строке подается число данных N о стоимости роз. В каждой из последующих N строк находится информация в следующем формате: <p> </p><p>&lt;Компания&gt;&lt;Улица&gt;&lt;Вид&gt;&lt;Цена&gt;<p> </p><p>где &lt;Компания&gt; — строка, состоящая не более, чем из 20 символов без пробелов, &lt;Улица&gt; — строка, состоящая не более, чем из 20 символов без пробелов, &lt;Вид&gt; — символ Б, К или Ж, &lt;Цена&gt; — целое число в диапазоне от 100 до 500, обозначающее стоимость одной розы. <p>&lt;Компания&gt; и &lt;Улица&gt;, &lt;Улица&gt; и &lt;Вид&gt;, а также &lt;Вид&gt; и &lt;Цена&gt; разделены ровно одним пробелом. <p> </p><p class=\"left_margin\">Пример входной строки: <p class=\"left_margin\">ТоргЦвет Садовая Ж 225 <p> </p><p class=\"left_margin\">Программа должна выводить через пробел 3 числа – количество лавок, продающих дешевле всего белые, красные и желтые розы соответственно. Если роза какого-то вида нигде не продается, то следует вывести 0. <p> </p><p class=\"left_margin\">Пример выходных данных: <p class=\"left_margin\">7 5 0</p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Будем по очереди обрабатывать строчки. Для этого будем посимвольно «пропускать» названия компаний и улиц, так как они не нужны. После чего считывать вид и цену. Для каждого вида у нас будет ячейка в массиве min и ячейка в массиве cnt, которые показывают, какой на данный момент минимум и сколько их соответственно. Если новая цена меньше предыдущей, то запомним её и поставим cnt равным единице. Если новая цена равна минимальной, то просто увеличим cnt на единицу. Изначально все min проинициализируем  1000, большим значением, которого точно не будет. Приведём код на языке Pascal:var n, i, ind, cost : integer;\tbuf : char;\tmin, cnt : array[1..3] of integer;beginfor i := 1 to 3 do\tbegin\tmin[i] := 1000;\tcnt[i] := 0;\tend;readLn(n);for i := 1 to n do\tbegin\twhile buf <> ' ' do  \t\tread(buf);\tread(buf);\twhile buf <> ' ' do  \t\tread(buf);\tread(buf);\tif buf = 'Б' then  \t\tind := 1;\tif buf = 'К' then  \t\tind := 2;\tif buf = 'Ж' then  \t\tind := 3;\treadLn(cost);\tif cost = min[ind] then  \t\tinc(cnt[ind]);\tif cost < min[ind] then  \t\tbegin  \t\tmin[ind] := cost;  \t\tcnt[ind] := 1;  \t\tend;\tend;writeLn(cnt[1], ' ', cnt[2], ' ', cnt[3]);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7428\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Будем по очереди обрабатывать строчки. Для этого будем посимвольно «пропускать» названия компаний и улиц, так как они не нужны. После чего считывать вид и цену. Для каждого вида у нас будет ячейка в массиве min и ячейка в массиве cnt, которые показывают, какой на данный момент минимум и сколько их соответственно. Если новая цена меньше предыдущей, то запомним её и поставим cnt равным единице. Если новая цена равна минимальной, то просто увеличим cnt на единицу. Изначально все min проинициализируем  1000, большим значением, которого точно не будет. <p class=\"left_margin\">Приведём код на языке Pascal:<p>var n, i, ind, cost : integer;<p class=\"left_margin\">\tbuf : char;<p class=\"left_margin\">\tmin, cnt : array[1..3] of integer;<p>begin<p>for i := 1 to 3 do<p>\tbegin<p>\tmin[i] := 1000;<p>\tcnt[i] := 0;<p>\tend;<p>readLn(n);<p>for i := 1 to n do<p class=\"left_margin\">\tbegin<p class=\"left_margin\">\twhile buf &lt;&gt; ' ' do<p class=\"left_margin\">  \t\tread(buf);<p class=\"left_margin\">\tread(buf);<p class=\"left_margin\">\twhile buf &lt;&gt; ' ' do<p class=\"left_margin\">  \t\tread(buf);<p class=\"left_margin\">\tread(buf);<p class=\"left_margin\">\tif buf = 'Б' then<p class=\"left_margin\">  \t\tind := 1;<p class=\"left_margin\">\tif buf = 'К' then<p class=\"left_margin\">  \t\tind := 2;<p class=\"left_margin\">\tif buf = 'Ж' then<p class=\"left_margin\">  \t\tind := 3;<p class=\"left_margin\">\treadLn(cost);<p class=\"left_margin\">\tif cost = min[ind] then<p class=\"left_margin\">  \t\tinc(cnt[ind]);<p class=\"left_margin\">\tif cost &lt; min[ind] then<p class=\"left_margin\">  \t\tbegin<p class=\"left_margin\">  \t\tmin[ind] := cost;<p class=\"left_margin\">  \t\tcnt[ind] := 1;<p class=\"left_margin\">  \t\tend;<p class=\"left_margin\">\tend;<p>writeLn(cnt[1], ' ', cnt[2], ' ', cnt[3]);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: РЕШУ ЕГЭ — Пред­эк­за­ме­на­ци­он­ная ра­бо­та 2014 по информатике.",
            "task_id": "7428"
        },
        {
            "answer": "Решение.Для построения программы, эффективной по времени, можно определить для каждого элемента входных данных минимальное значение от начала данных до этого элемента включительно. Затем нужно умножать каждый элемент,начиная с седьмого, на значение этого минимума, взятого на шесть элементов раньше, и выбрать наименьшее из этих произведений. Предложенный алгоритм реализован в следующей программе на алгоритмическом языке  Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.алгначцел s = 6 | требуемое расстояние между показаниямицел Nввод Nвещ а | очередное показание приборавещтаб мини[0:s - 1] | текущие минимумы| последних 6 элементовцел iввод мини[1]нц для i от 2 до sввод амини[mod(i, s)] := min(а, мини[i - 1])кцвещ м | минимальное значение произведениям := 1.0 * 1000 * 1000 + 1нц для i от s + 1 до Nввод ам := min(м, а * мини[mod(i, s)])мини[mod(i, s)] := min(а, мини[mod(i - 1, s)])кцвывод мкон Пример 2. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.алгначцел s = 6 | требуемое расстояние между показаниямицел Nввод Nвещтаб а[0:s - 1] | k-е введенное число| записываем в ячейку а[mod(k, 6)]вещ а_ | очередное показание приборацел i| Пролог. Ввод первых шести чиселнц для i от 1 до sввод а_а[mod(i, s)] := а_кц| Ввод остальных значений,| поиск минимального произведениявещ мини = 1001 | минимальное введенное число| (не считая 6 последних)вещ м | минимальное значение произведениям := 1.0 * 1000 * 1000 + 1нц для i от s + 1 до Nввод а_мини := min(мини, а[mod(i, s)])м := min(м, а_ * мини)а[mod(i, s)] := а_кцвывод мкон Далее приведены аналогичные программы на языках Python и Паскаль. В решении на языке Python используется «зацикленный» список prev_min из s = 6 элементов, в котором хранятся последовательные минимумы считанных чисел. Если программа получает на вход последовательность чисел a[0], a[1], … , a[N-1], то сначала заполняются элементы списка prev_min: a[2]), … , prev_min[s - 1] = min(a[0], a[1], … , a[s - 1]). При этом допустимых пар элементов (расстояние между которыми не меньше s) нет, поэтому значение переменной result, в которой хранится ответ, не обновляется. Далее считывается значение элемента последовательности a[s], рассматривается его произведение на prev_min[0] = a[0], при необходимости (если полученное произведение меньше значения result) обновляется значение result. После этого в элемент списка prev_min[0] записывается минимум из считанного числа a[s] и prev_min[s - 1], тем самым prev_min[0] становится равным min(a[0], a[1], … , a[s]). Далее, на каждом шаге в переменную next_num считывается очередной элемент последовательности a[i], он перемножается с prev_min[i % s], в котором в тот момент хранится min(a[0], a[1], … , a[i - s]), при необходимости обновляется переменная result, и далее в результате выполнения присваивания prev_min[i % s] = min(prev_min[(i - 1) % s], next_num) значение prev_min[i % s] становится равно min(a[0], a[1], … , a[i]). Это значение prev_min[i % s] будет затем использовано через s шагов выполнения внешнего цикла, т.е. когда будет считан элемент a[i + s]. При этом все элементы считанной последовательности не сохраняются в списке.  Пример 3. Пример правильной программы на языке Python. Программа эффективна и по времени, и по памятиs = 6result = 1000 * 1000N = int(input())prev_min = [0] * sprev_min[0] = float(input())for i in range(1, s):prev_min[i] = min(float(input()), prev_min[i - 1])for i in range(s, N):next_num = float(input())result = min(result, next_num * prev_min[i % s])prev_min[i % s] = min(prev_min[(i - 1) % s], next_num)print(result) Пример 4. Пример правильной программы на языке Паскаль.Программа эффективна и по времени, и по памятиВ программе на языке Паскаль, в отличие от программ предыдущих программ, на обработку очередного числа тратится время, пропорциональное величине задержки (в данной задаче – 6). Это решение менее эффективно, чем решения, приведенные выше. Однако по условию задачи оно также оценивается в 4 балла, так как время обработки очередного числа не зависит от числа введенных чисел.program c4;const s = 6; {требуемое расстояние между показаниями}varN: integer;a: array[0..s - 1] of real; {хранение показаний прибора}{k-е введенное число записываем в ячейку a[k mod 6]}a_: real; {ввод очередного показания}mn: real; {минимальное введенное число}{не считая 6 последних}m: real; {минимальное значение произведения}i: integer;beginreadln(N);{ Пролог. Ввод первых шести чисел}for i:=1 to s dobeginreadln(a_);a[i mod s] := a_end;{Ввод остальных значений, поиск минимального произведения}mn := 1001; m := 1000 * 1000+1;for i := s + 1 to N dobeginreadln(a_);if a[i mod s] < mn then mn := a[i mod s];if a_ * mn < m then m := a_ * mn;a[i mod s] := a_end;writeln(m)end. Пример 4. Решение задачи А на языке Паскаль.var  a: array[1..10000] of real; {исходные данные}  N: integer; {количество показаний прибора в серии}  min: real; {минимальное произведение}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i]);  min := 1000*1000+1;  for i := 1 to N-6 do    for j := i+6 to N do      if (a[i]*a[j] < min) then min := a[i]*a[j];  writeln(min);end.",
            "parsed": "2019-04-29 21:13:14.728519",
            "question": "На спутнике «Фотон» установлен прибор, предназначенный для измерения энергии космических лучей. Каждую минуту прибор передаёт по каналу связи неотрицательное вещественное число — количество энергии, полученной за последнюю минуту, измеренное в условных единицах. Временем, в течение которого происходит передача, можно пренебречь. Необходимо найти в заданной серии показаний прибора минимальное произведение двух показаний, между моментами передачи которых прошло не менее 6 минут. Количество энергии, получаемое прибором за минуту, не превышает 1000 условных единиц. Общее количество показаний прибора в серии не превышает 10 000. Напишите на любом языке программирования программу для решения поставленной задачи.  Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. Перед программой укажите версию языка программирования. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б. Перед программой укажите версию языка и кратко опишите использованный алгоритм. В первой строке задаётся число N — общее количество показаний прибора. Гарантируется, что N > 6. В каждой из следующих N строк задаётся одно неотрицательное вещественное число — очередное показание прибора.  Пример входных данных:111245.35.5425232120101226 Программа должна вывести одно число — описанное в условии произведение.Пример выходных данных для приведённого выше примера входных данных:48",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body947148\" width=\"100%\"><p class=\"left_margin\">На спутнике «Фотон» установлен прибор, предназначенный для измерения энергии космических лучей. Каждую минуту прибор передаёт по каналу связи неотрицательное вещественное число — количество энергии, полученной за последнюю минуту, измеренное в условных единицах. Временем, в течение которого происходит передача, можно пренебречь. Необходимо найти в заданной серии показаний прибора минимальное произведение двух показаний, между моментами передачи которых прошло не менее 6 минут. Количество энергии, получаемое прибором за минуту, не превышает 1000 условных единиц. Общее количество показаний прибора в серии не превышает 10 000. Напишите на любом языке программирования программу для решения поставленной задачи. <p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе</p></p></i>. Перед программой укажите версию языка программирования.<p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p class=\"left_margin\">Перед программой укажите версию языка и кратко опишите использованный алгоритм. В первой строке задаётся число <i>N</i> — общее количество показаний прибора. Гарантируется, что <i>N</i> &gt; 6. В каждой из следующих <i>N</i> строк задаётся одно неотрицательное вещественное число — очередное показание прибора. <p> </p><p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">11<p class=\"left_margin\">12<p class=\"left_margin\">45.3<p class=\"left_margin\">5.5<p class=\"left_margin\">4<p class=\"left_margin\">25<p class=\"left_margin\">23<p class=\"left_margin\">21<p class=\"left_margin\">20<p class=\"left_margin\">10<p class=\"left_margin\">12<p class=\"left_margin\">26<p> </p><p class=\"left_margin\">Программа должна вывести одно число — описанное в условии произведение.<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">48</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Для построения программы, эффективной по времени, можно определить для каждого элемента входных данных минимальное значение от начала данных до этого элемента включительно. Затем нужно умножать каждый элемент,начиная с седьмого, на значение этого минимума, взятого на шесть элементов раньше, и выбрать наименьшее из этих произведений. Предложенный алгоритм реализован в следующей программе на алгоритмическом языке  Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.алгначцел s = 6 | требуемое расстояние между показаниямицел Nввод Nвещ а | очередное показание приборавещтаб мини[0:s - 1] | текущие минимумы| последних 6 элементовцел iввод мини[1]нц для i от 2 до sввод амини[mod(i, s)] := min(а, мини[i - 1])кцвещ м | минимальное значение произведениям := 1.0 * 1000 * 1000 + 1нц для i от s + 1 до Nввод ам := min(м, а * мини[mod(i, s)])мини[mod(i, s)] := min(а, мини[mod(i - 1, s)])кцвывод мкон Пример 2. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.алгначцел s = 6 | требуемое расстояние между показаниямицел Nввод Nвещтаб а[0:s - 1] | k-е введенное число| записываем в ячейку а[mod(k, 6)]вещ а_ | очередное показание приборацел i| Пролог. Ввод первых шести чиселнц для i от 1 до sввод а_а[mod(i, s)] := а_кц| Ввод остальных значений,| поиск минимального произведениявещ мини = 1001 | минимальное введенное число| (не считая 6 последних)вещ м | минимальное значение произведениям := 1.0 * 1000 * 1000 + 1нц для i от s + 1 до Nввод а_мини := min(мини, а[mod(i, s)])м := min(м, а_ * мини)а[mod(i, s)] := а_кцвывод мкон Далее приведены аналогичные программы на языках Python и Паскаль. В решении на языке Python используется «зацикленный» список prev_min из s = 6 элементов, в котором хранятся последовательные минимумы считанных чисел. Если программа получает на вход последовательность чисел a[0], a[1], … , a[N-1], то сначала заполняются элементы списка prev_min: a[2]), … , prev_min[s - 1] = min(a[0], a[1], … , a[s - 1]). При этом допустимых пар элементов (расстояние между которыми не меньше s) нет, поэтому значение переменной result, в которой хранится ответ, не обновляется. Далее считывается значение элемента последовательности a[s], рассматривается его произведение на prev_min[0] = a[0], при необходимости (если полученное произведение меньше значения result) обновляется значение result. После этого в элемент списка prev_min[0] записывается минимум из считанного числа a[s] и prev_min[s - 1], тем самым prev_min[0] становится равным min(a[0], a[1], … , a[s]). Далее, на каждом шаге в переменную next_num считывается очередной элемент последовательности a[i], он перемножается с prev_min[i % s], в котором в тот момент хранится min(a[0], a[1], … , a[i - s]), при необходимости обновляется переменная result, и далее в результате выполнения присваивания prev_min[i % s] = min(prev_min[(i - 1) % s], next_num) значение prev_min[i % s] становится равно min(a[0], a[1], … , a[i]). Это значение prev_min[i % s] будет затем использовано через s шагов выполнения внешнего цикла, т.е. когда будет считан элемент a[i + s]. При этом все элементы считанной последовательности не сохраняются в списке.  Пример 3. Пример правильной программы на языке Python. Программа эффективна и по времени, и по памятиs = 6result = 1000 * 1000N = int(input())prev_min = [0] * sprev_min[0] = float(input())for i in range(1, s):prev_min[i] = min(float(input()), prev_min[i - 1])for i in range(s, N):next_num = float(input())result = min(result, next_num * prev_min[i % s])prev_min[i % s] = min(prev_min[(i - 1) % s], next_num)print(result) Пример 4. Пример правильной программы на языке Паскаль.Программа эффективна и по времени, и по памятиВ программе на языке Паскаль, в отличие от программ предыдущих программ, на обработку очередного числа тратится время, пропорциональное величине задержки (в данной задаче – 6). Это решение менее эффективно, чем решения, приведенные выше. Однако по условию задачи оно также оценивается в 4 балла, так как время обработки очередного числа не зависит от числа введенных чисел.program c4;const s = 6; {требуемое расстояние между показаниями}varN: integer;a: array[0..s - 1] of real; {хранение показаний прибора}{k-е введенное число записываем в ячейку a[k mod 6]}a_: real; {ввод очередного показания}mn: real; {минимальное введенное число}{не считая 6 последних}m: real; {минимальное значение произведения}i: integer;beginreadln(N);{ Пролог. Ввод первых шести чисел}for i:=1 to s dobeginreadln(a_);a[i mod s] := a_end;{Ввод остальных значений, поиск минимального произведения}mn := 1001; m := 1000 * 1000+1;for i := s + 1 to N dobeginreadln(a_);if a[i mod s] < mn then mn := a[i mod s];if a_ * mn < m then m := a_ * mn;a[i mod s] := a_end;writeln(m)end. Пример 4. Решение задачи А на языке Паскаль.var  a: array[1..10000] of real; {исходные данные}  N: integer; {количество показаний прибора в серии}  min: real; {минимальное произведение}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i]);  min := 1000*1000+1;  for i := 1 to N-6 do    for j := i+6 to N do      if (a[i]*a[j] < min) then min := a[i]*a[j];  writeln(min);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7472\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Для построения программы, эффективной по времени, можно определить для каждого элемента входных данных минимальное значение от начала данных до этого элемента включительно. Затем нужно умножать каждый элемент,<p>начиная с седьмого, на значение этого минимума, взятого на шесть элементов раньше, и выбрать наименьшее из этих произведений. Предложенный алгоритм реализован в следующей программе на алгоритмическом языке<p> </p><p> </p><p class=\"left_margin\">Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.<p>алг<p>нач<p>цел s = 6 | требуемое расстояние между показаниями<p>цел N<p>ввод N<p>вещ а | очередное показание прибора<p>вещтаб мини[0:s - 1] | текущие минимумы<p>| последних 6 элементов<p>цел i<p>ввод мини[1]<p>нц для i от 2 до s<p>ввод а<p>мини[mod(i, s)] := min(а, мини[i - 1])<p>кц<p>вещ м | минимальное значение произведения<p>м := 1.0 * 1000 * 1000 + 1<p>нц для i от s + 1 до N<p>ввод а<p>м := min(м, а * мини[mod(i, s)])<p>мини[mod(i, s)] := min(а, мини[mod(i - 1, s)])<p>кц<p>вывод м<p>кон<p> </p><p class=\"left_margin\">Пример 2. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.<p>алг<p>нач<p>цел s = 6 | требуемое расстояние между показаниями<p>цел N<p>ввод N<p>вещтаб а[0:s - 1] | k-е введенное число<p>| записываем в ячейку а[mod(k, 6)]<p>вещ а_ | очередное показание прибора<p>цел i<p>| Пролог. Ввод первых шести чисел<p>нц для i от 1 до s<p>ввод а_<p>а[mod(i, s)] := а_<p>кц<p>| Ввод остальных значений,<p>| поиск минимального произведения<p>вещ мини = 1001 | минимальное введенное число<p>| (не считая 6 последних)<p>вещ м | минимальное значение произведения<p>м := 1.0 * 1000 * 1000 + 1<p>нц для i от s + 1 до N<p>ввод а_<p>мини := min(мини, а[mod(i, s)])<p>м := min(м, а_ * мини)<p>а[mod(i, s)] := а_<p>кц<p>вывод м<p>кон<p> </p><p class=\"left_margin\">Далее приведены аналогичные программы на языках Python и Паскаль. В решении на языке Python используется «зацикленный» список prev_min из s = 6 элементов, в котором хранятся последовательные минимумы считанных чисел. Если программа получает на вход последовательность чисел a[0], a[1], … , a[N-1], то сначала заполняются элементы списка prev_min: a[2]), … , prev_min[s - 1] = min(a[0], a[1], … , a[s - 1]). При этом допустимых пар элементов (расстояние между которыми не меньше s) нет, поэтому значение переменной result, в которой хранится ответ, не обновляется. Далее считывается значение элемента последовательности a[s], рассматривается его произведение на prev_min[0] = a[0], при необходимости (если полученное произведение меньше значения result) обновляется значение result. После этого в элемент списка prev_min[0] записывается минимум из считанного числа a[s] и prev_min[s - 1], тем самым prev_min[0] становится равным min(a[0], a[1], … , a[s]). Далее, на каждом шаге в переменную next_num считывается очередной элемент последовательности a[i], он перемножается с prev_min[i % s], в котором в тот момент хранится min(a[0], a[1], … , a[i - s]), при необходимости обновляется переменная result, и далее в результате выполнения присваивания prev_min[i % s] = min(prev_min[(i - 1) % s], next_num) значение prev_min[i % s] становится равно min(a[0], a[1], … , a[i]). Это значение prev_min[i % s] будет затем использовано через s шагов выполнения внешнего цикла, т.е. когда будет считан элемент a[i + s]. При этом все элементы считанной последовательности не сохраняются в списке.<p> </p><p> </p><p class=\"left_margin\">Пример 3. Пример правильной программы на языке Python. Программа эффективна и по времени, и по памяти<p>s = 6<p>result = 1000 * 1000<p class=\"left_margin\">N = int(input())<p>prev_min = [0] * s<p>prev_min[0] = float(input())<p>for i in range(1, s):<p>prev_min[i] = min(float(input()), prev_min[i - 1])<p>for i in range(s, N):<p>next_num = float(input())<p>result = min(result, next_num * prev_min[i % s])<p>prev_min[i % s] = min(prev_min[(i - 1) % s], next_num)<p>print(result)<p> </p><p class=\"left_margin\">Пример 4. Пример правильной программы на языке Паскаль.<p class=\"left_margin\">Программа эффективна и по времени, и по памяти<p class=\"left_margin\">В программе на языке Паскаль, в отличие от программ предыдущих программ, на обработку очередного числа тратится время, пропорциональное величине задержки (в данной задаче – 6). Это решение менее эффективно, чем решения, приведенные выше. Однако по условию задачи оно также оценивается в 4 балла, так как время обработки очередного числа не зависит от числа введенных чисел.<p>program c4;<p>const s = 6; {требуемое расстояние между показаниями}<p>var<p class=\"left_margin\">N: integer;<p>a: array[0..s - 1] of real; {хранение показаний прибора}<p>{k-е введенное число записываем в ячейку a[k mod 6]}<p>a_: real; {ввод очередного показания}<p>mn: real; {минимальное введенное число}<p>{не считая 6 последних}<p>m: real; {минимальное значение произведения}<p>i: integer;<p>begin<p>readln(N);<p>{ Пролог. Ввод первых шести чисел}<p>for i:=1 to s do<p>begin<p>readln(a_);<p>a[i mod s] := a_<p>end;<p>{Ввод остальных значений, поиск минимального произведения}<p>mn := 1001; m := 1000 * 1000+1;<p>for i := s + 1 to N do<p>begin<p>readln(a_);<p>if a[i mod s] &lt; mn then mn := a[i mod s];<p>if a_ * mn &lt; m then m := a_ * mn;<p>a[i mod s] := a_<p>end;<p>writeln(m)<p>end.<p> </p><p><b>Пример 4. Решение задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of real; {исходные данные}<p>  N: integer; {количество показаний прибора в серии}<p>  min: real; {минимальное произведение}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  for i := 1 to N do read(a[i]);<p>  min := 1000*1000+1;<p>  for i := 1 to N-6 do<p>    for j := i+6 to N do<p>      if (a[i]*a[j] &lt; min) then min := a[i]*a[j];<p>  writeln(min);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Де­мон­стра­ци­он­ная версия ЕГЭ—2015 по информатике.",
            "task_id": "7472"
        },
        {
            "answer": "Решение.Сумма двух чисел нечетна, если одно из них — чётное, а другое — нечетное. Программа, вычисляющая контрольное значение, читает все входные данные один раз, не запоминая их в массиве. Для прочитанного фрагмента входной последовательности программа хранит значения двух величин: М0 – самое большое чётное число; M1 – самое большое нечётное число. После того как все данные прочитаны, искомое контрольное значение вычисляется как сумма M0 + M1. Ниже приведены реализующие этот алгоритм программы на языке Паскаль, а также на алгоритмическом языке. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль.var R,M0,M1,res,i,N,dat: longint;begin M0 := 0; M1 := 0;readln(N);for i := 1 to N dobeginreadln(dat);if (dat mod 2 = 0) and (dat > M0) thenM0 := dat;if (dat mod 2 <> 0) and (dat > M1) thenM1 := dat;end;if (M0>0) and (M1>0) thenres := M0+M1else res := -1;readln(R);if res > 0 thenwriteln('Вычисленное контрольное значение: ',res);if (R > 0) and (R = res)then writeln('Контроль пройден')else writeln('Контроль не пройден');end.Пример правильной и эффективной программы на Алгоритмическом языке. ввод xесли mod(x,2) = 0 и x > m0то m0 := xвсеесли mod(x,2) <> 0 и x > m1то m1 := xвсекцесли m0 > 0 и m1 > 0 тоres := m0+m1иначеres := -1всеввод Rесли res>0то вывод нс, 'Вычисленное контрольное значение: ',resвсеесли R>0 и R=resто вывод нс, \"Контроль пройден\"иначе вывод нс, \"Контроль не пройден\"всекон Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество показаний прибора в серии}  R: integer; {принимаемое контрольное значение}  max: integer; {минимальное произведение}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i]);  max := -1;  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]+a[j] > max) and ((a[i]+a[j]) mod 2 <> 0) then max := a[i]+a[j];  readln(R);  writeln('Вычисленное контрольное значение: ', max);  if R <> max then writeln('Контроль не пройден')  else writeln('Контроль пройден');end.",
            "parsed": "2019-04-29 21:13:09.701902",
            "question": "По каналу связи передаются положительные целые числа, не превышающие 1000, – результаты измерений, полученных в ходе эксперимента (количество измерений известно заранее). После окончания эксперимента передаётся контрольное значение – наибольшее число R, удовлетворяющее следующим условиям: 1) R — сумма двух различных переданных элементов последовательности («различные» означает, что нельзя просто удваивать переданные числа, суммы различных, но равных по величине элементов допускаются);2) R — нечётное число.  Если чисел, соответствующих приведённым условиям, нет, считается, что R = –1. В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены. Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Перед программой укажите версию языка программирования. Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Обязательно укажите, что программа является решением задания Б.Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество элементов последовательности.   Напишите эффективную, в том числе по используемой памяти, программу (укажите используемую версию языка программирования, например, Free Pascal 2.6.4), которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме: Вычисленное контрольное значение: …Контроль пройден (или Контроль не пройден) Если удовлетворяющее условию контрольное значение определить невозможно (то есть R = –1), то выводится только фраза «Контроль не пройден».Перед текстом программы кратко опишите используемый Вами алгоритм решения.На вход программе в первой строке подаётся количество чисел N. В каждой из последующих N строк записано одно натуральное число, не превышающее 1000. В последней строке записано контрольное значение. Пример входных данных: 6100833451990145 Пример выходных данных для приведённого выше примера входных данных:Вычисленное контрольное значение: 145Контроль пройден",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946424\" width=\"100%\"><p class=\"left_margin\">По каналу связи передаются положительные целые числа, не превышающие 1000, – результаты измерений, полученных в ходе эксперимента (количество измерений известно заранее). После окончания эксперимента передаётся контрольное значение – наибольшее число R, удовлетворяющее следующим условиям:<p> </p><p class=\"left_margin\">1) R — сумма двух различных переданных элементов последовательности («различные» означает, что нельзя просто удваивать переданные числа, суммы различных, но равных по величине элементов допускаются);<p class=\"left_margin\">2) R — нечётное число. <p> </p><p class=\"left_margin\">Если чисел, соответствующих приведённым условиям, нет, считается, что R = –1. В результате помех при передаче как сами числа, так и контрольное значение могут быть искажены.<p> </p><p class=\"left_margin\">Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.<p> <p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p class=\"left_margin\">Перед программой укажите версию языка программирования. <b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> </p><p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество элементов последовательности.<p> </p><p> </p><p> </p><p class=\"left_margin\">Напишите эффективную, в том числе по используемой памяти, программу (укажите используемую версию языка программирования, например, Free Pascal 2.6.4), которая будет проверять правильность контрольного значения. Программа должна напечатать отчёт по следующей форме:<p> </p><p class=\"left_margin\">Вычисленное контрольное значение: …<p class=\"left_margin\">Контроль пройден (или Контроль не пройден)<p> </p><p class=\"left_margin\">Если удовлетворяющее условию контрольное значение определить невозможно (то есть R = –1), то выводится только фраза «Контроль не пройден».<p class=\"left_margin\">Перед текстом программы кратко опишите используемый Вами алгоритм решения.<p class=\"left_margin\">На вход программе в первой строке подаётся количество чисел <i>N</i>. В каждой из последующих <i>N</i> строк записано одно натуральное число, не превышающее 1000. В последней строке записано контрольное значение.<p> </p><p class=\"left_margin\">Пример входных данных:<p> </p><p class=\"left_margin\">6<p class=\"left_margin\">100<p class=\"left_margin\">8<p class=\"left_margin\">33<p class=\"left_margin\">45<p class=\"left_margin\">19<p class=\"left_margin\">90<p class=\"left_margin\">145<p> </p><p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">Вычисленное контрольное значение: 145<p class=\"left_margin\">Контроль пройден</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Сумма двух чисел нечетна, если одно из них — чётное, а другое — нечетное. Программа, вычисляющая контрольное значение, читает все входные данные один раз, не запоминая их в массиве. Для прочитанного фрагмента входной последовательности программа хранит значения двух величин: М0 – самое большое чётное число; M1 – самое большое нечётное число. После того как все данные прочитаны, искомое контрольное значение вычисляется как сумма M0 + M1. Ниже приведены реализующие этот алгоритм программы на языке Паскаль, а также на алгоритмическом языке. Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскаль.var R,M0,M1,res,i,N,dat: longint;begin M0 := 0; M1 := 0;readln(N);for i := 1 to N dobeginreadln(dat);if (dat mod 2 = 0) and (dat > M0) thenM0 := dat;if (dat mod 2 <> 0) and (dat > M1) thenM1 := dat;end;if (M0>0) and (M1>0) thenres := M0+M1else res := -1;readln(R);if res > 0 thenwriteln('Вычисленное контрольное значение: ',res);if (R > 0) and (R = res)then writeln('Контроль пройден')else writeln('Контроль не пройден');end.Пример правильной и эффективной программы на Алгоритмическом языке. ввод xесли mod(x,2) = 0 и x > m0то m0 := xвсеесли mod(x,2) <> 0 и x > m1то m1 := xвсекцесли m0 > 0 и m1 > 0 тоres := m0+m1иначеres := -1всеввод Rесли res>0то вывод нс, 'Вычисленное контрольное значение: ',resвсеесли R>0 и R=resто вывод нс, \"Контроль пройден\"иначе вывод нс, \"Контроль не пройден\"всекон Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество показаний прибора в серии}  R: integer; {принимаемое контрольное значение}  max: integer; {минимальное произведение}  i, j: integer;begin  readln(N);  for i := 1 to N do read(a[i]);  max := -1;  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]+a[j] > max) and ((a[i]+a[j]) mod 2 <> 0) then max := a[i]+a[j];  readln(R);  writeln('Вычисленное контрольное значение: ', max);  if R <> max then writeln('Контроль не пройден')  else writeln('Контроль пройден');end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7684\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Сумма двух чисел нечетна, если одно из них — чётное, а другое — нечетное. Программа, вычисляющая контрольное значение, читает все входные данные один раз, не запоминая их в массиве. Для прочитанного фрагмента входной последовательности программа хранит значения двух величин: М0 – самое большое чётное число; M1 – самое большое нечётное число. После того как все данные прочитаны, искомое контрольное значение вычисляется как сумма M0 + M1. Ниже приведены реализующие этот алгоритм программы на языке Паскаль, а также на алгоритмическом языке. Допускаются решения, записанные на других языках программирования.<p> </p><p><b>Пример правильной и эффективной программы на языке Паскаль.</b><p><div class=\"source_code lang_pascal\"><p>var R,M0,M1,res,i,N,dat: longint;<p>begin<p> M0 := 0;<p> M1 := 0;<p>readln(N);<p>for i := 1 to N do<p>begin<p>readln(dat);<p>if (dat mod 2 = 0) and (dat &gt; M0) then<p class=\"left_margin\">M0 := dat;<p>if (dat mod 2 &lt;&gt; 0) and (dat &gt; M1) then<p class=\"left_margin\">M1 := dat;<p>end;<p>if (M0&gt;0) and (M1&gt;0) then<p>res := M0+M1<p>else res := -1;<p>readln(R);<p>if res &gt; 0 then<p>writeln('Вычисленное контрольное значение: ',res);<p>if (R &gt; 0) and (R = res)<p>then writeln('Контроль пройден')<p>else writeln('Контроль не пройден');<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p><b>Пример правильной и эффективной программы на Алгоритмическом языке.</b><p> </p><p>ввод x<p>если mod(x,2) = 0 и x &gt; m0<p>то m0 := x<p>все<p>если mod(x,2) &lt;&gt; 0 и x &gt; m1<p>то m1 := x<p>все<p>кц<p>если m0 &gt; 0 и m1 &gt; 0 то<p>res := m0+m1<p>иначе<p>res := -1<p>все<p>ввод R<p>если res&gt;0<p>то вывод нс, 'Вычисленное контрольное значение: ',res<p>все<p>если R&gt;0 и R=res<p>то вывод нс, \"Контроль пройден\"<p>иначе вывод нс, \"Контроль не пройден\"<p>все<p>кон<p> </p><p><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество показаний прибора в серии}<p>  R: integer; {принимаемое контрольное значение}<p>  max: integer; {минимальное произведение}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  for i := 1 to N do read(a[i]);<p>  max := -1;<p>  for i := 1 to N-1 do<p>    for j := i+1 to N do<p>      if (a[i]+a[j] &gt; max) and ((a[i]+a[j]) mod 2 &lt;&gt; 0) then max := a[i]+a[j];<p>  readln(R);<p>  writeln('Вычисленное контрольное значение: ', max);<p>  if R &lt;&gt; max then writeln('Контроль не пройден')<p>  else writeln('Контроль пройден');<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "7684"
        },
        {
            "answer": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 9, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. Максимальное произведение из всех этих пар будет получено, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-8. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, каждое вновь введенное значение умножать на максимум, имевшийся на 8 элементов ранее, и выбрать максимальное из всех таких произведений. Поскольку каждое текущее максимальное значение используется после ввода ещё 8 элементов и после этого становится ненужным, достаточно хранить только 8 последних максимумов. Для этого можно использовать буферный массив из 8 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 8;varN: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {максимальное введенное число}{(не считая 8 последних)}m: longint; { максимальное значение произведения}i: integer;beginreadln(N);{Ввод первых d чисел}for i:=1 to d dobeginreadln(x);a[i mod d] := xend;{ Ввод остальных элементов, поиск максимальногопроизведения}mx := 0; m := 0;for i := d + 1 to N dobeginreadln(x);if a[i mod d] > mx then mx := a[i mod d];if x * mx > m then m := x * mx;a[i mod d] := xend;writeln(m)end.  Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов.  Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:const d = 8;varN: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {максимальное введенное число}{не считая d последних}m:longint; {максимальное значение произведения}i: integer;beginreadln(N);{Ввод всех элементов последовательности}for i:=1 to N do readln(a[i]);mn := 0;m := 0;for i := d + 1 to N dobeginif a[i-d] > mn then mn := a[i-d];if a[i] * mn > m then m := a[i] * mnend;writeln(m)end. Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:Const d = 8;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: longint; {максимальное значение произведения}i, j: integer;beginreadln(N);{Ввод значений элементов}for i:=1 to N do readln(a[i]);m := 0;for i := 1 to N-d do beginfor j := i+d to N do beginif a[i] * a[j] > m then m := a[i] * a[j];end;end;writeln(m)end.",
            "parsed": "2019-04-29 21:13:10.122688",
            "question": "Для заданной последовательности неотрицательных целых чисел необходимо найти максимальное произведение двух её элементов, номера которых различаются не менее чем на 8. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000.Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов. Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.  А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования. Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла.  Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта. Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б.Максимальная оценка за правильную программу, эффективную по времени и по памяти — 4 балла. Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.  Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество элементов последовательности. Гарантируется, что N > 8. В каждой из следующих N строк задаётся одно неотрицательное целое число – очередной элемент последовательности. Пример входных данных:101004555245352510101026Программа должна вывести одно число — описанное в условии произведение. Пример выходных данных для приведённого выше примера входных данных: 2600.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946336\" width=\"100%\"><p class=\"left_margin\">Для заданной последовательности неотрицательных целых чисел необходимо найти максимальное произведение двух её элементов, номера которых различаются не менее чем на 8. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000.<p class=\"left_margin\">Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов. Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. <p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования. <b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла. <p> </p><p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p> </p><p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта. Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и по памяти — 4 балла. Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. <p> </p><p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество элементов последовательности. Гарантируется, что N &gt; 8. В каждой из следующих N строк задаётся одно неотрицательное целое число – очередной элемент последовательности. <p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">10<p class=\"left_margin\">100<p class=\"left_margin\">45<p class=\"left_margin\">55<p class=\"left_margin\">245<p class=\"left_margin\">35<p class=\"left_margin\">25<p class=\"left_margin\">10<p class=\"left_margin\">10<p class=\"left_margin\">10<p class=\"left_margin\">26<p class=\"left_margin\">Программа должна вывести одно число — описанное в условии произведение. Пример выходных данных для приведённого выше примера входных данных: 2600.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 9, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. Максимальное произведение из всех этих пар будет получено, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-8. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, каждое вновь введенное значение умножать на максимум, имевшийся на 8 элементов ранее, и выбрать максимальное из всех таких произведений. Поскольку каждое текущее максимальное значение используется после ввода ещё 8 элементов и после этого становится ненужным, достаточно хранить только 8 последних максимумов. Для этого можно использовать буферный массив из 8 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 8;varN: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {максимальное введенное число}{(не считая 8 последних)}m: longint; { максимальное значение произведения}i: integer;beginreadln(N);{Ввод первых d чисел}for i:=1 to d dobeginreadln(x);a[i mod d] := xend;{ Ввод остальных элементов, поиск максимальногопроизведения}mx := 0; m := 0;for i := d + 1 to N dobeginreadln(x);if a[i mod d] > mx then mx := a[i mod d];if x * mx > m then m := x * mx;a[i mod d] := xend;writeln(m)end.  Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов.  Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:const d = 8;varN: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {максимальное введенное число}{не считая d последних}m:longint; {максимальное значение произведения}i: integer;beginreadln(N);{Ввод всех элементов последовательности}for i:=1 to N do readln(a[i]);mn := 0;m := 0;for i := d + 1 to N dobeginif a[i-d] > mn then mn := a[i-d];if a[i] * mn > m then m := a[i] * mnend;writeln(m)end. Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:Const d = 8;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: longint; {максимальное значение произведения}i, j: integer;beginreadln(N);{Ввод значений элементов}for i:=1 to N do readln(a[i]);m := 0;for i := 1 to N-d do beginfor j := i+d to N do beginif a[i] * a[j] > m then m := a[i] * a[j];end;end;writeln(m)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7772\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 9, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. <p class=\"left_margin\">Максимальное произведение из всех этих пар будет получено, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-8. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, каждое вновь введенное значение умножать на максимум, имевшийся на 8 элементов ранее, и выбрать максимальное из всех таких произведений. Поскольку каждое текущее максимальное значение используется после ввода ещё 8 элементов и после этого становится ненужным, достаточно хранить только 8 последних максимумов. Для этого можно использовать буферный массив из 8 элементов и циклически заполнять его по мере ввода данных.<p class=\"left_margin\">Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\">Программа 1. Пример правильной и эффективной программы на языке Паскаль:<p><div class=\"source_code lang_pascal\"><p>program N_27;<p>const d = 8;<p>var<p class=\"left_margin\">N: integer;<p>a: array[0..d-1] of integer; {буфер}<p>{k-е введенное число записываем в ячейку a[k mod d]}<p>x: integer;<p>mx: integer; {максимальное введенное число}<p>{(не считая 8 последних)}<p>m: longint; { максимальное значение произведения}<p>i: integer;<p>begin<p>readln(N);<p>{Ввод первых d чисел}<p>for i:=1 to d do<p>begin<p>readln(x);<p>a[i mod d] := x<p>end;<p>{ Ввод остальных элементов, поиск максимального<p>произведения}<p>mx := 0; m := 0;<p>for i := d + 1 to N do<p>begin<p>readln(x);<p>if a[i mod d] &gt; mx then mx := a[i mod d];<p>if x * mx &gt; m then m := x * mx;<p>a[i mod d] := x<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p> </p><p class=\"left_margin\">Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов. <p> </p><p class=\"left_margin\">Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:<p><div class=\"source_code lang_pascal\"><p>const d = 8;<p>var<p class=\"left_margin\">N: integer;<p>a: array[1..10000] of integer; {хранение всех<p>элементов последовательности}<p>mn:integer; {максимальное введенное число}<p>{не считая d последних}<p>m:longint; {максимальное значение произведения}<p>i: integer;<p>begin<p>readln(N);{Ввод всех элементов последовательности}<p>for i:=1 to N do readln(a[i]);<p>mn := 0;<p>m := 0;<p>for i := d + 1 to N do<p>begin<p>if a[i-d] &gt; mn then mn := a[i-d];<p>if a[i] * mn &gt; m then m := a[i] * mn<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\">Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:<p><div class=\"source_code lang_pascal\"><p class=\"left_margin\">Const d = 8;<p>var<p class=\"left_margin\">N: integer;<p>a: array[1..10000] of integer;<p>{хранение всех элементов}<p>m: longint; {максимальное значение произведения}<p>i, j: integer;<p>begin<p>readln(N);<p>{Ввод значений элементов}<p>for i:=1 to N do readln(a[i]);<p>m := 0;<p>for i := 1 to N-d do begin<p>for j := i+d to N do begin<p>if a[i] * a[j] &gt; m then m := a[i] * a[j];<p>end;<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "7772"
        },
        {
            "answer": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 5, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-4. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, имевшимся на 4 элемента ранее, и выбрать минимальную из всех таких сумм.Поскольку каждое текущее минимальное значение используется после ввода еще 4 элементов и после этого становится ненужным, достаточно хранить только 4 последних минимума. Для этого можно использовать буферный массив из 4 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 4;varN: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {минимальное введенное число}{(не считая 4 последних)}m: integer; { минимальное значение суммы}i: integer;beginreadln(N);{Ввод первых d чисел}for i:=1 to d dobeginreadln(x);a[i mod d] := xend;{ Ввод остальных элементов, поиск минимальной суммы}mx := 1001; m := 2001;for i := d + 1 to N dobeginreadln(x);if a[i mod d] < mx then mx := a[i mod d];if x + mx < m then m := x + mx;a[i mod d] := xend;writeln(m)end. Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов.  Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:const d = 4;varN: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {минимальное введенное число}{не считая d последних}m:integer; {минимальное значение суммы}i: integer;beginreadln(N);{Ввод всех элементов последовательности}for i:=1 to N do readln(a[i]);mn := 1001;m := 2001;for i := d + 1 to N dobeginif a[i-d] < mn then mn := a[i-d];if a[i] + mn < m then m := a[i] + mnend;writeln(m)end. Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:Const d = 4;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: integer; {минимальное значение суммы}i, j: integer;beginreadln(N);{Ввод значений элементов}for i:=1 to N do readln(a[i]);m := 2001;for i := 1 to N-d do beginfor j := i+d to N do beginif a[i] + a[j] < m then m := a[i] + a[j];end;end;writeln(m)end.",
            "parsed": "2019-04-29 21:13:10.680488",
            "question": "Для заданной последовательности неотрицательных целых чисел необходимо найти минимальную сумму двух её элементов, номера которых различаются не менее чем на 4. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000.  Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов. Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.Обязательно укажите, что программа является решением задания А. Максимальная оценка за выполнение задания А — 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти — 4 балла. Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.  Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество элементов последовательности. Гарантируется, что N > 4. В каждой из следующих N строк задаётся одно неотрицательное целое число — очередной элемент последовательности.Пример входных данных:7104555245352510Программа должна вывести одно число — описанную в условии сумму.Пример выходных данных для приведённого выше примера входных данных: 20",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body946315\" width=\"100%\"><p class=\"left_margin\">Для заданной последовательности неотрицательных целых чисел необходимо найти минимальную сумму двух её элементов, номера которых различаются не менее чем на 4. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000. <p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов. Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.</i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования.<p><b>Обязательно</b> укажите, что программа является решением <b>задания А</b>. Максимальная оценка за выполнение задания А — 2 балла. <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. Максимальная оценка за правильную программу, эффективную по времени и по памяти — 4 балла. Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, — 3 балла. Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. <p> </p><p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N — общее количество элементов последовательности. Гарантируется, что N &gt; 4. В каждой из следующих N строк задаётся одно неотрицательное целое число — очередной элемент последовательности.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">7<p class=\"left_margin\">10<p class=\"left_margin\">45<p class=\"left_margin\">55<p class=\"left_margin\">245<p class=\"left_margin\">35<p class=\"left_margin\">25<p class=\"left_margin\">10<p class=\"left_margin\">Программа должна вывести одно число — описанную в условии сумму.<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных: 20</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 5, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-4. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, имевшимся на 4 элемента ранее, и выбрать минимальную из всех таких сумм.Поскольку каждое текущее минимальное значение используется после ввода еще 4 элементов и после этого становится ненужным, достаточно хранить только 4 последних минимума. Для этого можно использовать буферный массив из 4 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 4;varN: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {минимальное введенное число}{(не считая 4 последних)}m: integer; { минимальное значение суммы}i: integer;beginreadln(N);{Ввод первых d чисел}for i:=1 to d dobeginreadln(x);a[i mod d] := xend;{ Ввод остальных элементов, поиск минимальной суммы}mx := 1001; m := 2001;for i := d + 1 to N dobeginreadln(x);if a[i mod d] < mx then mx := a[i mod d];if x + mx < m then m := x + mx;a[i mod d] := xend;writeln(m)end. Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов.  Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:const d = 4;varN: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {минимальное введенное число}{не считая d последних}m:integer; {минимальное значение суммы}i: integer;beginreadln(N);{Ввод всех элементов последовательности}for i:=1 to N do readln(a[i]);mn := 1001;m := 2001;for i := d + 1 to N dobeginif a[i-d] < mn then mn := a[i-d];if a[i] + mn < m then m := a[i] + mnend;writeln(m)end. Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:Const d = 4;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: integer; {минимальное значение суммы}i, j: integer;beginreadln(N);{Ввод значений элементов}for i:=1 to N do readln(a[i]);m := 2001;for i := 1 to N-d do beginfor j := i+d to N do beginif a[i] + a[j] < m then m := a[i] + a[j];end;end;writeln(m)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol7799\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 5, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым. Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-4. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, имевшимся на 4 элемента ранее, и выбрать минимальную из всех таких сумм.<p class=\"left_margin\">Поскольку каждое текущее минимальное значение используется после ввода еще 4 элементов и после этого становится ненужным, достаточно хранить только 4 последних минимума. Для этого можно использовать буферный массив из 4 элементов и циклически заполнять его по мере ввода данных.<p class=\"left_margin\">Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти. Ниже приводится пример такой программы<p> </p><p class=\"left_margin\">Программа 1. Пример правильной и эффективной программы на языке Паскаль:<p><div class=\"source_code lang_pascal\"><p>program N_27;<p>const d = 4;<p>var<p class=\"left_margin\">N: integer;<p>a: array[0..d-1] of integer; {буфер}<p>{k-е введенное число записываем в ячейку a[k mod d]}<p>x: integer;<p>mx: integer; {минимальное введенное число}<p>{(не считая 4 последних)}<p>m: integer; { минимальное значение суммы}<p>i: integer;<p>begin<p>readln(N);<p>{Ввод первых d чисел}<p>for i:=1 to d do<p>begin<p>readln(x);<p>a[i mod d] := x<p>end;<p>{ Ввод остальных элементов, поиск минимальной суммы}<p>mx := 1001; m := 2001;<p>for i := d + 1 to N do<p>begin<p>readln(x);<p>if a[i mod d] &lt; mx then mx := a[i mod d];<p>if x + mx &lt; m then m := x + mx;<p>a[i mod d] := x<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\">Работа с буферным массивом может быть организована и без использования операции mod, например, циклическим перезаписыванием элементов со сдвигом. Этот способ также является эффективным. Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие максимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобная (и аналогичные по сути) программы оцениваются не выше 3 баллов. <p> </p><p class=\"left_margin\">Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:<p><div class=\"source_code lang_pascal\"><p>const d = 4;<p>var<p class=\"left_margin\">N: integer;<p>a: array[1..10000] of integer; {хранение всех<p>элементов последовательности}<p>mn:integer; {минимальное введенное число}<p>{не считая d последних}<p>m:integer; {минимальное значение суммы}<p>i: integer;<p>begin<p>readln(N);{Ввод всех элементов последовательности}<p>for i:=1 to N do readln(a[i]);<p>mn := 1001;<p>m := 2001;<p>for i := d + 1 to N do<p>begin<p>if a[i-d] &lt; mn then mn := a[i-d];<p>if a[i] + mn &lt; m then m := a[i] + mn<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p> </p><p class=\"left_margin\">Возможно также переборное решение, в котором находятся произведения всех допустимых пар и из них выбирается максимальное. Ниже приведён пример подобного решения. Это (и аналогичные ему) решение не эффективно ни по времени, ни по памяти. Оно является решением задачи А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:<p><div class=\"source_code lang_pascal\"><p class=\"left_margin\">Const d = 4;<p>var<p class=\"left_margin\">N: integer;<p>a: array[1..10000] of integer;<p>{хранение всех элементов}<p>m: integer; {минимальное значение суммы}<p>i, j: integer;<p>begin<p>readln(N);<p>{Ввод значений элементов}<p>for i:=1 to N do readln(a[i]);<p>m := 2001;<p>for i := 1 to N-d do begin<p>for j := i+d to N do begin<p>if a[i] + a[j] &lt; m then m := a[i] + a[j];<p>end;<p>end;<p>writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "7799"
        },
        {
            "answer": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 11, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.Максимальная сумма квадратов элементов этих пар будет получена, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-10. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, квадрат каждого вновь введенного значения суммировать с квадратом максимума, найденным на 10 элементов ранее, и выбрать максимальную из всех таких сумм.Поскольку каждое текущее максимальное значение используется после ввода ещё 10 элементов и после этого становится ненужным, достаточно хранить только 10 последних максимумов. Для этого можно использовать буферный массив из 10 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль: pprogram N_27;const d = 10;var N: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {максимальное введенное число}{(не считая 10 последних)}m: integer; {максимальное значение суммы квадратов}i: integer;begin    readln(N);{Ввод первых d чисел}    for i:=0 to d-1 do    begin        readln(x);        a[i mod d] := x    end;{ Ввод остальных элементов, поиск максимальной суммыквадратов}    mx := 0; m := 0;    for i := d to N-1 do    begin        readln(x);        if abs(a[i mod d]) > abs(mx) then mx := abs(a[i mod d]);        if x*x + mx*mx > m then m := x*x + mx*mx;        a[i mod d] := abs(x)    end;    writeln(m)end. Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти: const d = 10;var N: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {максимальное введенное число}{не считая d последних}m:integer; {максимальное значение суммы квадратов}i: integer;begin    readln(N);{Ввод всех элементов последовательности}    for i:=1 to N do readln(a[i]);    mn := 0;    m := 0;    for i := d + 1 to N do    begin        if a[i-d] > mn then mn := a[i-d];        if a[i]*a[i]+mn*mn > m then m := a[i]*a[i]+mn*mn    end;    writeln(m)end. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти: Const d = 10;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: integer; {максимальное значение суммы квадратов}i, j: integer;begin    readln(N);{Ввод значений элементов}    for i:=1 to N do readln(a[i]);    m := 0;    for i := 1 to N-d do begin        for j := i+d to N do begin            if a[i]*a[i]+a[j]*a[j]>m then                m := a[i]*a[i]+a[j]*a[j];        end;    end;    writeln(m)end.",
            "parsed": "2019-04-29 21:13:11.118585",
            "question": "Для заданной последовательности целых чисел необходимо найти максимальную сумму квадратов двух её элементов, номера которых различаются не менее чем на 10. Значение каждого элемента последовательности не превышает 100. Количество элементов последовательности не превышает 10000. Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.       А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Перед программой укажите версию языка программирования. Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла.       Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта. Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б.Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body937759\" width=\"100%\"><p class=\"left_margin\">Для заданной последовательности целых чисел необходимо найти максимальную сумму квадратов двух её элементов, номера которых различаются не менее чем на 10. Значение каждого элемента последовательности не превышает 100. Количество элементов последовательности не превышает 10000.<p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как <b>максимальная</b> из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p>      <b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p class=\"left_margin\">Перед программой укажите версию языка программирования. <b>Обязательно</b> укажите, что программа является решением задания А.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> </p><p>      <b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.<p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта. Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.</p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 11, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.Максимальная сумма квадратов элементов этих пар будет получена, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-10. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, квадрат каждого вновь введенного значения суммировать с квадратом максимума, найденным на 10 элементов ранее, и выбрать максимальную из всех таких сумм.Поскольку каждое текущее максимальное значение используется после ввода ещё 10 элементов и после этого становится ненужным, достаточно хранить только 10 последних максимумов. Для этого можно использовать буферный массив из 10 элементов и циклически заполнять его по мере ввода данных.Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль: pprogram N_27;const d = 10;var N: integer;a: array[0..d-1] of integer; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: integer;mx: integer; {максимальное введенное число}{(не считая 10 последних)}m: integer; {максимальное значение суммы квадратов}i: integer;begin    readln(N);{Ввод первых d чисел}    for i:=0 to d-1 do    begin        readln(x);        a[i mod d] := x    end;{ Ввод остальных элементов, поиск максимальной суммыквадратов}    mx := 0; m := 0;    for i := d to N-1 do    begin        readln(x);        if abs(a[i mod d]) > abs(mx) then mx := abs(a[i mod d]);        if x*x + mx*mx > m then m := x*x + mx*mx;        a[i mod d] := abs(x)    end;    writeln(m)end. Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти: const d = 10;var N: integer;a: array[1..10000] of integer; {хранение всехэлементов последовательности}mn:integer; {максимальное введенное число}{не считая d последних}m:integer; {максимальное значение суммы квадратов}i: integer;begin    readln(N);{Ввод всех элементов последовательности}    for i:=1 to N do readln(a[i]);    mn := 0;    m := 0;    for i := d + 1 to N do    begin        if a[i-d] > mn then mn := a[i-d];        if a[i]*a[i]+mn*mn > m then m := a[i]*a[i]+mn*mn    end;    writeln(m)end. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти: Const d = 10;varN: integer;a: array[1..10000] of integer;{хранение всех элементов}m: integer; {максимальное значение суммы квадратов}i, j: integer;begin    readln(N);{Ввод значений элементов}    for i:=1 to N do readln(a[i]);    m := 0;    for i := 1 to N-d do begin        for j := i+d to N do begin            if a[i]*a[i]+a[j]*a[j]>m then                m := a[i]*a[i]+a[j]*a[j];        end;    end;    writeln(m)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol8675\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 11, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.<p class=\"left_margin\">Максимальная сумма квадратов элементов этих пар будет получена, если первым в паре будет взят максимальный элемент среди всех, от первого и до элемента с номером k-10. Для получения эффективного по времени решения нужно по мере ввода данных помнить максимальное текущее значение, квадрат каждого вновь введенного значения суммировать с квадратом максимума, найденным на 10 элементов ранее, и выбрать максимальную из всех таких сумм.<p class=\"left_margin\">Поскольку каждое текущее максимальное значение используется после ввода ещё 10 элементов и после этого становится ненужным, достаточно хранить только 10 последних максимумов. Для этого можно использовать буферный массив из 10 элементов и циклически заполнять его по мере ввода данных.<p class=\"left_margin\">Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.<p class=\"left_margin\">Ниже приводится пример такой программы<p> </p><p class=\"left_margin\">Программа 1. Пример правильной и эффективной программы на языке Паскаль:<p> </p><p><tt><div class=\"source_code lang_pascal\">p<p>program N_27;<p>const d = 10;<p>var<p> N: integer;<p>a: array[0..d-1] of integer; {буфер}<p>{k-е введенное число записываем в ячейку a[k mod d]}<p>x: integer;<p>mx: integer; {максимальное введенное число}<p>{(не считая 10 последних)}<p>m: integer; {максимальное значение суммы квадратов}<p>i: integer;<p>begin<p>    readln(N);<p>{Ввод первых d чисел}<p>    for i:=0 to d-1 do<p>    begin<p>        readln(x);<p>        a[i mod d] := x<p>    end;<p>{ Ввод остальных элементов, поиск максимальной суммы<p>квадратов}<p>    mx := 0; m := 0;<p>    for i := d to N-1 do<p>    begin<p>        readln(x);<p>        if abs(a[i mod d]) &gt; abs(mx) then mx := abs(a[i mod d]);<p>        if x*x + mx*mx &gt; m then m := x*x + mx*mx;<p>        a[i mod d] := abs(x)<p>    end;<p>    writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt><p> </p><p class=\"left_margin\">Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:<p> </p><p><tt><div class=\"source_code lang_pascal\"><p>const d = 10;<p>var<p> N: integer;<p>a: array[1..10000] of integer; {хранение всех<p>элементов последовательности}<p>mn:integer; {максимальное введенное число}<p>{не считая d последних}<p>m:integer; {максимальное значение суммы квадратов}<p>i: integer;<p>begin<p>    readln(N);{Ввод всех элементов последовательности}<p>    for i:=1 to N do readln(a[i]);<p>    mn := 0;<p>    m := 0;<p>    for i := d + 1 to N do<p>    begin<p>        if a[i-d] &gt; mn then mn := a[i-d];<p>        if a[i]*a[i]+mn*mn &gt; m then m := a[i]*a[i]+mn*mn<p>    end;<p>    writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt><p> </p><p class=\"left_margin\">Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:<p> </p><p><tt><div class=\"source_code lang_pascal\"><p class=\"left_margin\">Const d = 10;<p>var<p class=\"left_margin\">N: integer;<p>a: array[1..10000] of integer;<p>{хранение всех элементов}<p>m: integer; {максимальное значение суммы квадратов}<p>i, j: integer;<p>begin<p>    readln(N);<p>{Ввод значений элементов}<p>    for i:=1 to N do readln(a[i]);<p>    m := 0;<p>    for i := 1 to N-d do begin<p>        for j := i+d to N do begin<p>            if a[i]*a[i]+a[j]*a[j]&gt;m then<p>                m := a[i]*a[i]+a[j]*a[j];<p>        end;<p>    end;<p>    writeln(m)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "8675"
        },
        {
            "answer": "Решение.Заметим, что минимальное среднее арифметическое пар элементов равно половине минимальной суммы пар элементов. Поэтому задача сводится к нахождению минимальной суммы элементов на расстоянии, не меньшем 9, которая при печати ответа делится на 2.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 10, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-9. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, найденным на 9 элемента ранее, и выбрать минимальную из всех таких сумм. Поскольку каждое текущее минимальное значение используется после ввода ещё 9 элементов и после этого становится ненужным, достаточно хранить только 9 последних минимумов. Для этого можно использовать буферный массив из 9 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 9;var N: integer;a: array[0..d-1] of real; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: real;mx: real; {минимальное введенное число}{(не считая 9 последних)}m: real; { минимальное значение суммы}i: integer;begin    readln(N);    {Ввод первых d чисел}    for i:=1 to d do    begin        readln(x);        a[i mod d] := x    end;    { Ввод остальных элементов, поиск минимальной суммы}    mx := 1001.0; m := 2001.0;    for i := d + 1 to N do    begin        readln(x);        if a[i mod d] < mx then mx := a[i mod d];        if x + mx < m then m := x + mx;        a[i mod d] := x    end;    writeln(m/2.0)end. Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти: const d = 9;var N: integer;a: array[1..10000] of real; {хранение всех элементовпоследовательности}mn:real; {минимальное введенное число}{не считая d последних}m:real; {минимальное значение суммы}i: integer;begin    readln(N);{Ввод всех элементов последовательности}    for i:=1 to N do readln(a[i]);    mn := 1001.0;    m := 2001.0;    for i := d + 1 to N do    begin        if a[i-d] < mn then mn := a[i-d];        if a[i] + mn < m then m := a[i] + mn    end;    writeln(m/2.0)end. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти: Const d = 9;var N: integer;a: array[1..10000] of real;{хранение всех элементов}m: real; {минимальное значение суммы}i, j: integer;begin    readln(N);    {Ввод значений элементов}    for i:=1 to N do readln(a[i]);    m := 2001.0;    for i := 1 to N-d do begin        for j := i+d to N do begin            if a[i] + a[j] < m then m := a[i] + a[j];        end;    end;    writeln(m/2.0)end.",
            "parsed": "2019-04-29 21:13:11.548745",
            "question": "Для заданной последовательности вещественных чисел необходимо найти минимальное среднее арифметическое двух её элементов, номера которых различаются не менее чем на 9. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000. Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Перед программой укажите версию языка программирования. Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Обязательно укажите, что программа является решением задания Б.Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество элементов последовательности.Гарантируется, что N > 9. В каждой из следующих N строк задаётся одно неотрицательное целое число – очередной элемент последовательности. Пример входных данных:1081045     -5525352514169Программа должна вывести одно число – описанное в условии среднее арифметическое.Пример выходных данных для приведённого выше примера входных данных:8.5",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body937255\" width=\"100%\"><p class=\"left_margin\">Для заданной последовательности вещественных чисел необходимо найти минимальное среднее арифметическое двух её элементов, номера которых различаются не менее чем на 9. Значение каждого элемента последовательности не превышает 1000. Количество элементов последовательности не превышает 10000.<p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как <b>максимальная</b> из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p class=\"left_margin\">Перед программой укажите версию языка программирования. <b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> </p><p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла.<p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла.<p class=\"left_margin\">Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ.<p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество элементов последовательности.<p class=\"left_margin\">Гарантируется, что N &gt; 9. В каждой из следующих N строк задаётся одно неотрицательное целое число – очередной элемент последовательности.<p> </p><p><i>Пример входных данных:</i><p class=\"left_margin\">10<p class=\"left_margin\">8<p class=\"left_margin\">10<p class=\"left_margin\">45<p>     -55<p class=\"left_margin\">25<p class=\"left_margin\">35<p class=\"left_margin\">25<p class=\"left_margin\">14<p class=\"left_margin\">16<p class=\"left_margin\">9<p class=\"left_margin\">Программа должна вывести одно число – описанное в условии среднее арифметическое.<p><i>Пример выходных данных для приведённого выше примера входных данных:</i><p class=\"left_margin\">8.5</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Заметим, что минимальное среднее арифметическое пар элементов равно половине минимальной суммы пар элементов. Поэтому задача сводится к нахождению минимальной суммы элементов на расстоянии, не меньшем 9, которая при печати ответа делится на 2.Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 10, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-9. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, найденным на 9 элемента ранее, и выбрать минимальную из всех таких сумм. Поскольку каждое текущее минимальное значение используется после ввода ещё 9 элементов и после этого становится ненужным, достаточно хранить только 9 последних минимумов. Для этого можно использовать буферный массив из 9 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.Ниже приводится пример такой программы Программа 1. Пример правильной и эффективной программы на языке Паскаль:program N_27;const d = 9;var N: integer;a: array[0..d-1] of real; {буфер}{k-е введенное число записываем в ячейку a[k mod d]}x: real;mx: real; {минимальное введенное число}{(не считая 9 последних)}m: real; { минимальное значение суммы}i: integer;begin    readln(N);    {Ввод первых d чисел}    for i:=1 to d do    begin        readln(x);        a[i mod d] := x    end;    { Ввод остальных элементов, поиск минимальной суммы}    mx := 1001.0; m := 2001.0;    for i := d + 1 to N do    begin        readln(x);        if a[i mod d] < mx then mx := a[i mod d];        if x + mx < m then m := x + mx;        a[i mod d] := x    end;    writeln(m/2.0)end. Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти: const d = 9;var N: integer;a: array[1..10000] of real; {хранение всех элементовпоследовательности}mn:real; {минимальное введенное число}{не считая d последних}m:real; {минимальное значение суммы}i: integer;begin    readln(N);{Ввод всех элементов последовательности}    for i:=1 to N do readln(a[i]);    mn := 1001.0;    m := 2001.0;    for i := d + 1 to N do    begin        if a[i-d] < mn then mn := a[i-d];        if a[i] + mn < m then m := a[i] + mn    end;    writeln(m/2.0)end. Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти: Const d = 9;var N: integer;a: array[1..10000] of real;{хранение всех элементов}m: real; {минимальное значение суммы}i, j: integer;begin    readln(N);    {Ввод значений элементов}    for i:=1 to N do readln(a[i]);    m := 2001.0;    for i := 1 to N-d do begin        for j := i+d to N do begin            if a[i] + a[j] < m then m := a[i] + a[j];        end;    end;    writeln(m/2.0)end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol9179\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Заметим, что минимальное среднее арифметическое пар элементов равно половине минимальной суммы пар элементов. Поэтому задача сводится к нахождению минимальной суммы элементов на расстоянии, не меньшем 9, которая при печати ответа делится на 2.<p class=\"left_margin\">Задание Б (решение для задания А приведено ниже, см. программу 3). Для каждого элемента с номером k (нумерацию начинаем с 1), начиная с k = 10, рассмотрим все допустимые по условиям задачи пары, в которых данный элемент является вторым.<p class=\"left_margin\">Минимальная сумма из всех этих пар будет получена, если первым в паре будет взят минимальный элемент среди всех, от первого и до элемента с номером k-9. Для получения эффективного по времени решения нужно по мере ввода данных помнить минимальное текущее значение, каждое вновь введенное значение складывать с минимумом, найденным на 9 элемента ранее, и выбрать минимальную из всех таких сумм. Поскольку каждое текущее минимальное значение используется после ввода ещё 9 элементов и после этого становится ненужным, достаточно хранить только 9 последних минимумов. Для этого можно использовать буферный массив из 9 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введенных элементов, поэтому такое решение будет эффективным не только по времени, но и по памяти.<p class=\"left_margin\">Ниже приводится пример такой программы<p> </p><p class=\"left_margin\">Программа 1. Пример правильной и эффективной программы на языке Паскаль:<p><tt><div class=\"source_code lang_pascal\">program N_27;<p>const d = 9;<p>var<p> N: integer;<p>a: array[0..d-1] of real; {буфер}<p>{k-е введенное число записываем в ячейку a[k mod d]}<p>x: real;<p>mx: real; {минимальное введенное число}<p>{(не считая 9 последних)}<p>m: real; { минимальное значение суммы}<p>i: integer;<p>begin<p>    readln(N);<p>    {Ввод первых d чисел}<p>    for i:=1 to d do<p>    begin<p>        readln(x);<p>        a[i mod d] := x<p>    end;<p>    { Ввод остальных элементов, поиск минимальной суммы}<p>    mx := 1001.0; m := 2001.0;<p>    for i := d + 1 to N do<p>    begin<p>        readln(x);<p>        if a[i mod d] &lt; mx then mx := a[i mod d];<p>        if x + mx &lt; m then m := x + mx;<p>        a[i mod d] := x<p>    end;<p>    writeln(m/2.0)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt><p> </p><p class=\"left_margin\">Программа 2. Пример правильной программы на языке Паскаль, эффективной по времени, но неэффективной по памяти:<p> </p><p><tt><div class=\"source_code lang_pascal\"><p>const d = 9;<p>var<p> N: integer;<p>a: array[1..10000] of real; {хранение всех элементов<p>последовательности}<p>mn:real; {минимальное введенное число}<p>{не считая d последних}<p>m:real; {минимальное значение суммы}<p>i: integer;<p>begin<p>    readln(N);{Ввод всех элементов последовательности}<p>    for i:=1 to N do readln(a[i]);<p>    mn := 1001.0;<p>    m := 2001.0;<p>    for i := d + 1 to N do<p>    begin<p>        if a[i-d] &lt; mn then mn := a[i-d];<p>        if a[i] + mn &lt; m then m := a[i] + mn<p>    end;<p>    writeln(m/2.0)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt><p> </p><p class=\"left_margin\">Программа 3. Пример правильной программы на языке Паскаль, не эффективной ни по времени, ни по памяти:<p> </p><p><tt><div class=\"source_code lang_pascal\"><p class=\"left_margin\">Const d = 9;<p>var<p> N: integer;<p>a: array[1..10000] of real;<p>{хранение всех элементов}<p>m: real; {минимальное значение суммы}<p>i, j: integer;<p>begin<p>    readln(N);<p>    {Ввод значений элементов}<p>    for i:=1 to N do readln(a[i]);<p>    m := 2001.0;<p>    for i := 1 to N-d do begin<p>        for j := i+d to N do begin<p>            if a[i] + a[j] &lt; m then m := a[i] + a[j];<p>        end;<p>    end;<p>    writeln(m/2.0)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p></p></tt><p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "9179"
        },
        {
            "answer": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 4). Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. Для каждого показания с номером k, начиная с k = 7, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 6. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 6 элементов ранее, и выбрать минимальное из всех таких произведений.Поскольку каждое текущее минимальное показание используется после ввода ещё 6 элементов и после этого становится ненужным, достаточно хранить только 6 последних минимумов. Для этого можно использовать массив из 6 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введённых показаний, поэтому такое решение будет эффективным не только по времени, но и по памяти. Чтобы хранить абсолютный и чётный минимумы, нужно использовать два таких массива. Ниже приводится пример такой программы, написанной на алгоритмическом языке. Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти. алг нач    цел s = 6 | требуемое расстояние между показаниями    цел amax = 1001 | больше максимально возможного показания    цел N    ввод N    цел a | очередное показание прибора    целтаб мини[0:s-1] | текущие минимумы последних s элементов    целтаб миничет[0:s-1] | чётные минимумы последних s элементов    цел i    | вводим первые s показаний, фиксируем минимумы    цел ма; ма := amax | минимальное показание    цел мчет; мчет := amax | минимальное чётное показание    нц для i от 1 до s        ввод а        ма := imin(ма, a)        если mod(a,2) = 0 то мчет := imin(мчет,a) все        мини[mod(i, s)] := ма        миничет[mod(i, s)] := мчет    кц    цел мп = amax*amax | минимальное значение произведения    цел п    нц для i от s+1 до N        ввод а        если mod(a,2)=0            то п := a * мини[mod(i, s)]            иначе если мчет < amax                то п := a * миничет[mod(i, s)]                иначе п := amax*amax;            все        все        мп := imin(мп, п)        ма := imin(ма, a)        если mod(a,2) = 0 то мчет := imin(мчет,a) все        мини[mod(i, s)] := ма        миничет[mod(i, s)] := мчет    кц    если мп = amax*amax то мп:=-1 все    вывод мп кон Возможны и другие реализации. Например, вместо циклического заполнения массива можно каждый раз сдвигать его элементы. В приведённом ниже примере хранятся и сдвигаются не минимумы, а исходные значения. Это требует чуть меньше памяти (достаточно одного массива вместо двух), но по времени решение со сдвигами менее эффективно, чем с циклическим заполнением. Однако время работы остаётся пропорциональным N, поэтому максимальная оценка за такое решение тоже составляет 4 балла. Программа 2. Пример правильной программы на языке Паскаль.Программа использует сдвиги, но эффективна по времени и по памяти const s = 6; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N: integer;    a: array[1..s] of integer; {хранение s показаний прибора}    a_: integer; {ввод очередного показания}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения}    p: longint;    i, j: integer; begin    readln(N);    {Ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {Ввод остальных значений, поиск минимального произведения}    ma := amax; me := amax;    mp :=amax*amax;    for i := s + 1 to N do begin        readln(a_);        if a[1] < ma then ma := a[1];        if (a[1] mod 2 = 0) and (a[1] < me) then me := a[1];        if a_ mod 2 = 0 then p := a_ * ma        else if me < amax then p := a_ * me        else p := amax* amax;        if (p < mp) then mp := p;        {сдвигаем элементы вспомогательного массива влево}        for j := 1 to s - 1 do            a[j] := a[j + 1];        a[s] := a_    end;    if mp = amax*amax then mp:=-1;    writeln(mp) end.Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие минимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобные (и аналогичные по сути) программы оцениваются не выше 3 баллов. Программа 3. Пример правильной программы на языке Паскаль. Программа эффективна по времени, но неэффективна по памяти const s = 6; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N, p, i: integer;    a: array[1..10000] of integer; {все показания прибора}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения} begin    readln(N);    {Ввод всех показаний прибора}    for i:=1 to N do readln(a[i]);    ma := amax;    me := amax;    mp := amax*amax;    for i := s + 1 to N do    begin        if a[i-s] < ma then ma := a[i-s];        if (a[i-s] mod 2 = 0) and (a[i-s] < me) then            me := a[i-s];        if a[i] mod 2 = 0 then p := a[i] * ma        else if me < amax then p := a[i] * me        else p := amax * amax;        if (p < mp) then mp := p    end;    if mp = amax*amax then mp := -1;    writeln(mp) end.Возможно также переборное решение, в котором находятся произведения всех возможных пар и из них выбирается минимальное. Ниже (см. программу 4) приведён пример подобного решения. Это (и аналогичные ему) решение неэффективно ни по времени, ни по памяти. Оно является решением задания А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 4. Пример правильной программы на языке Паскаль. Программа неэффективна ни по времени, ни по памяти const s = 6; {требуемое расстояние между показаниями} var    N: integer;    a: array[1..10000] of integer; {все показания прибора}    mp: integer; {минимальное значение произведения}    i, j: integer; begin    readln(N);    {Ввод значений прибора}    for i:=1 to N do        readln(a[i]);    mp := 1000 * 1000 + 1;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] < mp)                then mp := a[i]*a[j]        end;    end;    if mp = 1000 * 1000 + 1 then mp := -1;    writeln(mp) end.",
            "parsed": "2019-04-29 21:13:11.990505",
            "question": "В физической лаборатории проводится долговременный эксперимент по изучению гравитационного поля Земли. По каналу связи каждую минуту в лабораторию передаётся положительное целое число – текущее показание прибора «Сигма 2015». Количество передаваемых чисел в серии известно и не превышает 10 000. Все числа не превышают 1000. Временем, в течение которого происходит передача, можно пренебречь. Необходимо вычислить «бета-значение» серии показаний прибора – минимальное чётное произведение двух показаний, между моментами передачи которых прошло не менее 6 минут. Если получить такое произведение не удаётся, ответ считается равным –1. Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание – 0 баллов. Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования. Обязательноукажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). Программа считается эффективной по времени, если время работыпрограммы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.Обязательно укажите, что программа является решением задания Б. Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла. Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла. Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество показаний прибора. Гарантируется, что N > 6. В каждой из следующих N строк задаётся одно положительное целое число – очередное показание прибора. Пример входных данных:1112455317232120191817Программа должна вывести одно число – описанное в условии произведение либо –1, если получить такое произведение не удаётся.Пример выходных данных для приведённого выше примера входных данных:54",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body936542\" width=\"100%\"><p class=\"left_margin\">В физической лаборатории проводится долговременный эксперимент по изучению гравитационного поля Земли. По каналу связи каждую минуту в лабораторию передаётся положительное целое число – текущее показание прибора «Сигма 2015». Количество передаваемых чисел в серии известно и не превышает 10 000. Все числа не превышают 1000. Временем, в течение которого происходит передача, можно пренебречь. <p class=\"left_margin\">Необходимо вычислить «бета-значение» серии показаний прибора – минимальное чётное произведение двух показаний, между моментами передачи которых прошло не менее 6 минут. Если получить такое произведение не удаётся, ответ считается равным –1. <p><i><p class=\"left_margin\">Вам предлагается два задания, связанных с этой задачей: задание А и задание Б. Вы можете решать оба задания или одно из них по своему выбору. Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание – 0 баллов. Задание Б является усложнённым вариантом задания А, оно содержит дополнительные требования к программе.</p></i><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов. Перед программой укажите версию языка программирования. <p><b>Обязательно</b>укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла. <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик). <p class=\"left_margin\">Программа считается эффективной по времени, если время работы<p>программы пропорционально количеству полученных показаний прибора N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз. <p class=\"left_margin\">Программа считается эффективной по памяти, если размер памяти, использованной в программе для хранения данных, не зависит от числа N и не превышает 1 килобайта.<p class=\"left_margin\">Перед программой укажите версию языка программирования и кратко опишите использованный алгоритм.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени и по памяти, – 4 балла. <p class=\"left_margin\">Максимальная оценка за правильную программу, эффективную по времени, но неэффективную по памяти, – 3 балла. Напоминаем! Не забудьте указать, к какому заданию относится каждая из представленных Вами программ. <p class=\"left_margin\">Входные данные представлены следующим образом. В первой строке задаётся число N – общее количество показаний прибора. Гарантируется, что N &gt; 6. В каждой из следующих N строк задаётся одно положительное целое число – очередное показание прибора. <p><i>Пример входных данных:<p class=\"left_margin\">11<p class=\"left_margin\">12<p class=\"left_margin\">45<p class=\"left_margin\">5<p class=\"left_margin\">3<p class=\"left_margin\">17<p class=\"left_margin\">23<p class=\"left_margin\">21<p class=\"left_margin\">20<p class=\"left_margin\">19<p class=\"left_margin\">18<p class=\"left_margin\">17</p></p></p></p></p></p></p></p></p></p></p></p></i><p class=\"left_margin\">Программа должна вывести одно число – описанное в условии произведение либо –1, если получить такое произведение не удаётся.<p><i>Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">54</p></i></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Задание Б (решение для задания А приведено ниже, см. программу 4). Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. Для каждого показания с номером k, начиная с k = 7, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 6. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 6 элементов ранее, и выбрать минимальное из всех таких произведений.Поскольку каждое текущее минимальное показание используется после ввода ещё 6 элементов и после этого становится ненужным, достаточно хранить только 6 последних минимумов. Для этого можно использовать массив из 6 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введённых показаний, поэтому такое решение будет эффективным не только по времени, но и по памяти. Чтобы хранить абсолютный и чётный минимумы, нужно использовать два таких массива. Ниже приводится пример такой программы, написанной на алгоритмическом языке. Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти. алг нач    цел s = 6 | требуемое расстояние между показаниями    цел amax = 1001 | больше максимально возможного показания    цел N    ввод N    цел a | очередное показание прибора    целтаб мини[0:s-1] | текущие минимумы последних s элементов    целтаб миничет[0:s-1] | чётные минимумы последних s элементов    цел i    | вводим первые s показаний, фиксируем минимумы    цел ма; ма := amax | минимальное показание    цел мчет; мчет := amax | минимальное чётное показание    нц для i от 1 до s        ввод а        ма := imin(ма, a)        если mod(a,2) = 0 то мчет := imin(мчет,a) все        мини[mod(i, s)] := ма        миничет[mod(i, s)] := мчет    кц    цел мп = amax*amax | минимальное значение произведения    цел п    нц для i от s+1 до N        ввод а        если mod(a,2)=0            то п := a * мини[mod(i, s)]            иначе если мчет < amax                то п := a * миничет[mod(i, s)]                иначе п := amax*amax;            все        все        мп := imin(мп, п)        ма := imin(ма, a)        если mod(a,2) = 0 то мчет := imin(мчет,a) все        мини[mod(i, s)] := ма        миничет[mod(i, s)] := мчет    кц    если мп = amax*amax то мп:=-1 все    вывод мп кон Возможны и другие реализации. Например, вместо циклического заполнения массива можно каждый раз сдвигать его элементы. В приведённом ниже примере хранятся и сдвигаются не минимумы, а исходные значения. Это требует чуть меньше памяти (достаточно одного массива вместо двух), но по времени решение со сдвигами менее эффективно, чем с циклическим заполнением. Однако время работы остаётся пропорциональным N, поэтому максимальная оценка за такое решение тоже составляет 4 балла. Программа 2. Пример правильной программы на языке Паскаль.Программа использует сдвиги, но эффективна по времени и по памяти const s = 6; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N: integer;    a: array[1..s] of integer; {хранение s показаний прибора}    a_: integer; {ввод очередного показания}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения}    p: longint;    i, j: integer; begin    readln(N);    {Ввод первых s чисел}    for i:=1 to s do readln(a[i]);    {Ввод остальных значений, поиск минимального произведения}    ma := amax; me := amax;    mp :=amax*amax;    for i := s + 1 to N do begin        readln(a_);        if a[1] < ma then ma := a[1];        if (a[1] mod 2 = 0) and (a[1] < me) then me := a[1];        if a_ mod 2 = 0 then p := a_ * ma        else if me < amax then p := a_ * me        else p := amax* amax;        if (p < mp) then mp := p;        {сдвигаем элементы вспомогательного массива влево}        for j := 1 to s - 1 do            a[j] := a[j + 1];        a[s] := a_    end;    if mp = amax*amax then mp:=-1;    writeln(mp) end.Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие минимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобные (и аналогичные по сути) программы оцениваются не выше 3 баллов. Программа 3. Пример правильной программы на языке Паскаль. Программа эффективна по времени, но неэффективна по памяти const s = 6; {требуемое расстояние между показаниями}        amax = 1001; {больше максимально возможного показания} var    N, p, i: integer;    a: array[1..10000] of integer; {все показания прибора}    ma: integer; {минимальное число без s последних}    me: integer; {минимальное чётное число без s последних}    mp: integer; {минимальное значение произведения} begin    readln(N);    {Ввод всех показаний прибора}    for i:=1 to N do readln(a[i]);    ma := amax;    me := amax;    mp := amax*amax;    for i := s + 1 to N do    begin        if a[i-s] < ma then ma := a[i-s];        if (a[i-s] mod 2 = 0) and (a[i-s] < me) then            me := a[i-s];        if a[i] mod 2 = 0 then p := a[i] * ma        else if me < amax then p := a[i] * me        else p := amax * amax;        if (p < mp) then mp := p    end;    if mp = amax*amax then mp := -1;    writeln(mp) end.Возможно также переборное решение, в котором находятся произведения всех возможных пар и из них выбирается минимальное. Ниже (см. программу 4) приведён пример подобного решения. Это (и аналогичные ему) решение неэффективно ни по времени, ни по памяти. Оно является решением задания А, но не является решением задания Б. Оценка за такое решение – 2 балла. Программа 4. Пример правильной программы на языке Паскаль. Программа неэффективна ни по времени, ни по памяти const s = 6; {требуемое расстояние между показаниями} var    N: integer;    a: array[1..10000] of integer; {все показания прибора}    mp: integer; {минимальное значение произведения}    i, j: integer; begin    readln(N);    {Ввод значений прибора}    for i:=1 to N do        readln(a[i]);    mp := 1000 * 1000 + 1;    for i := 1 to N-s do begin        for j := i+s to N do begin            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] < mp)                then mp := a[i]*a[j]        end;    end;    if mp = 1000 * 1000 + 1 then mp := -1;    writeln(mp) end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol9378\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Задание Б (решение для задания А приведено ниже, см. программу 4). Чтобы произведение было чётным, хотя бы один сомножитель должен быть чётным, поэтому при поиске подходящих произведений чётные показания прибора можно рассматривать в паре с любыми другими, а нечётные – только с чётными. <p class=\"left_margin\">Для каждого показания с номером k, начиная с k = 7, рассмотрим все допустимые по условиям задачи пары, в которых данное показание получено вторым. Минимальное произведение из всех этих пар будет получено, если первым в паре будет взято минимальное подходящее показание среди всех, полученных от начала приёма и до показания с номером k – 6. Если очередное показание чётное, минимальное среди предыдущих может быть любым, если нечётное – только чётным. <p class=\"left_margin\">Для получения эффективного по времени решения нужно по мере ввода данных помнить абсолютное минимальное и минимальное чётное показание на каждый момент времени, каждое вновь полученное показание умножать на соответствующий ему минимум, имевшийся на 6 элементов ранее, и выбрать минимальное из всех таких произведений.<p class=\"left_margin\">Поскольку каждое текущее минимальное показание используется после ввода ещё 6 элементов и после этого становится ненужным, достаточно хранить только 6 последних минимумов. Для этого можно использовать массив из 6 элементов и циклически заполнять его по мере ввода данных. Размер этого массива не зависит от общего количества введённых показаний, поэтому такое решение будет эффективным не только по времени, но и по памяти. Чтобы хранить абсолютный и чётный минимумы, нужно использовать два таких массива. Ниже приводится пример такой программы, написанной на алгоритмическом языке.<p> </p><p class=\"left_margin\">Пример 1. Пример правильной программы на алгоритмическом языке. Программа эффективна и по времени, и по памяти.<p> алг<p> нач<p>    цел s = 6 | требуемое расстояние между показаниями<p>    цел amax = 1001 | больше максимально возможного показания<p>    цел N<p>    ввод N<p>    цел a | очередное показание прибора<p>    целтаб мини[0:s-1] | текущие минимумы последних s элементов<p>    целтаб миничет[0:s-1] | чётные минимумы последних s элементов<p>    цел i<p>    | вводим первые s показаний, фиксируем минимумы<p>    цел ма; ма := amax | минимальное показание<p>    цел мчет; мчет := amax | минимальное чётное показание<p>    нц для i от 1 до s<p>        ввод а<p>        ма := imin(ма, a)<p>        если mod(a,2) = 0 то мчет := imin(мчет,a) все<p>        мини[mod(i, s)] := ма<p>        миничет[mod(i, s)] := мчет<p>    кц<p>    цел мп = amax*amax | минимальное значение произведения<p>    цел п<p>    нц для i от s+1 до N<p>        ввод а<p>        если mod(a,2)=0<p>            то п := a * мини[mod(i, s)]<p>            иначе если мчет &lt; amax<p>                то п := a * миничет[mod(i, s)]<p>                иначе п := amax*amax;<p>            все<p>        все<p>        мп := imin(мп, п)<p>        ма := imin(ма, a)<p>        если mod(a,2) = 0 то мчет := imin(мчет,a) все<p>        мини[mod(i, s)] := ма<p>        миничет[mod(i, s)] := мчет<p>    кц<p>    если мп = amax*amax то мп:=-1 все<p>    вывод мп<p> кон<p> </p><p class=\"left_margin\">Возможны и другие реализации. Например, вместо циклического заполнения массива можно каждый раз сдвигать его элементы. В приведённом ниже примере хранятся и сдвигаются не минимумы, а исходные значения. Это требует чуть меньше памяти (достаточно одного массива вместо двух), но по времени решение со сдвигами менее эффективно, чем с циклическим заполнением. Однако время работы остаётся пропорциональным N, поэтому максимальная оценка за такое решение тоже составляет 4 балла.<p> </p><p class=\"left_margin\">Программа 2. Пример правильной программы на языке Паскаль.<p class=\"left_margin\">Программа использует сдвиги, но эффективна по времени и по памяти<p><div class=\"source_code lang_pascal\"><p> const s = 6; {требуемое расстояние между показаниями}<p>        amax = 1001; {больше максимально возможного показания}<p> var<p>    N: integer;<p>    a: array[1..s] of integer; {хранение s показаний прибора}<p>    a_: integer; {ввод очередного показания}<p>    ma: integer; {минимальное число без s последних}<p>    me: integer; {минимальное чётное число без s последних}<p>    mp: integer; {минимальное значение произведения}<p>    p: longint;<p>    i, j: integer;<p> begin<p>    readln(N);<p>    {Ввод первых s чисел}<p>    for i:=1 to s do readln(a[i]);<p>    {Ввод остальных значений, поиск минимального произведения}<p>    ma := amax; me := amax;<p>    mp :=amax*amax;<p>    for i := s + 1 to N do begin<p>        readln(a_);<p>        if a[1] &lt; ma then ma := a[1];<p>        if (a[1] mod 2 = 0) and (a[1] &lt; me) then me := a[1];<p>        if a_ mod 2 = 0 then p := a_ * ma<p>        else if me &lt; amax then p := a_ * me<p>        else p := amax* amax;<p>        if (p &lt; mp) then mp := p;<p>        {сдвигаем элементы вспомогательного массива влево}<p>        for j := 1 to s - 1 do<p>            a[j] := a[j + 1];<p>        a[s] := a_<p>    end;<p>    if mp = amax*amax then mp:=-1;<p>    writeln(mp)<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p class=\"left_margin\">Если вместо небольшого массива фиксированного размера (циклического или со сдвигами) хранятся все исходные данные (или все текущие минимумы), программа сохраняет эффективность по времени, но становится неэффективной по памяти, так как требуемая память растёт пропорционально N. Ниже приводится пример такой программы на языке Паскаль. Подобные (и аналогичные по сути) программы оцениваются не выше 3 баллов.<p> </p><p class=\"left_margin\">Программа 3. Пример правильной программы на языке Паскаль. Программа эффективна по времени, но неэффективна по памяти<p><div class=\"source_code lang_pascal\"><p> const s = 6; {требуемое расстояние между показаниями}<p>        amax = 1001; {больше максимально возможного показания}<p> var<p>    N, p, i: integer;<p>    a: array[1..10000] of integer; {все показания прибора}<p>    ma: integer; {минимальное число без s последних}<p>    me: integer; {минимальное чётное число без s последних}<p>    mp: integer; {минимальное значение произведения}<p> begin<p>    readln(N);<p>    {Ввод всех показаний прибора}<p>    for i:=1 to N do readln(a[i]);<p>    ma := amax;<p>    me := amax;<p>    mp := amax*amax;<p>    for i := s + 1 to N do<p>    begin<p>        if a[i-s] &lt; ma then ma := a[i-s];<p>        if (a[i-s] mod 2 = 0) and (a[i-s] &lt; me) then<p>            me := a[i-s];<p>        if a[i] mod 2 = 0 then p := a[i] * ma<p>        else if me &lt; amax then p := a[i] * me<p>        else p := amax * amax;<p>        if (p &lt; mp) then mp := p<p>    end;<p>    if mp = amax*amax then mp := -1;<p>    writeln(mp)<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div><p class=\"left_margin\">Возможно также переборное решение, в котором находятся произведения всех возможных пар и из них выбирается минимальное. Ниже (см. программу 4) приведён пример подобного решения. Это (и аналогичные ему) решение неэффективно ни по времени, ни по памяти. Оно является решением задания А, но не является решением задания Б. Оценка за такое решение – 2 балла.<p> </p><p class=\"left_margin\">Программа 4. Пример правильной программы на языке Паскаль. Программа неэффективна ни по времени, ни по памяти<p><div class=\"source_code lang_pascal\"><p> const s = 6; {требуемое расстояние между показаниями}<p> var<p>    N: integer;<p>    a: array[1..10000] of integer; {все показания прибора}<p>    mp: integer; {минимальное значение произведения}<p>    i, j: integer;<p> begin<p>    readln(N);<p>    {Ввод значений прибора}<p>    for i:=1 to N do<p>        readln(a[i]);<p>    mp := 1000 * 1000 + 1;<p>    for i := 1 to N-s do begin<p>        for j := i+s to N do begin<p>            if (a[i]*a[j] mod 2 = 0) and (a[i]*a[j] &lt; mp)<p>                then mp := a[i]*a[j]<p>        end;<p>    end;<p>    if mp = 1000 * 1000 + 1 then mp := -1;<p>    writeln(mp)<p> end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "Источник: Де­мон­стра­ци­он­ная вер­сия ЕГЭ—2016 по информатике.",
            "task_id": "9378"
        },
        {
            "answer": "Решение.Произведение двух чисел делится на 14, если:— один из сомножителей делится на 14 (второй может быть любым) либо— ни один из сомножителей не делится на 14, но один из сомножителей делится на 7, а другой – на 2.Поэтому программа, вычисляющая число X, может работать так.Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырёх величин:М7 – самое большое число, кратное 7, но не кратное 2;M2 – самое большое число, кратное 2, но не кратное 7;M14 – самое большое число, кратное 14;МAX – самое большое число среди всех элементов последовательности, отличное от М14 (если число М14 встретилось более одного раза и оно же является максимальным, то MAX = M14).После того как все данные прочитаны, искомое число X вычисляется как максимум из произведений М14*MAX и М7*М2.Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы.Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскальvar M7,M2,M14,MAX,dat,res,i,N: longint;begin  M7 := 0;  M2 := 0;  M14 := 0;  MAX := 0;  readln(N);  for i := 1 to N do  begin    readln(dat);    if ((dat mod 7) = 0) and ((dat mod 2) > 0) and (dat > M7) then      M7 := dat;    if ((dat mod 2) = 0) and ((dat mod 7) > 0) and (dat > M2) then      M2 := dat;    if (dat mod 14 = 0) and (dat > M14) then    begin      if M14 > MAX then MAX := M14;      M14 := dat    end    else    if dat > MAX then      MAX := dat;  end;  if (M7*M2 < M14*MAX) then    res := M14*MAX  else    res := M7*M2;  writeln(res);  end. Пример правильной и эффективной программы на языке Бейсик: M14 = 0 M7 = 0 M2 = 0 MAX = 0 INPUT N FOR I = 1 TO N  INPUT DAT  IF DAT MOD 7 = 0 AND DAT > M7 THEN    M7 = DAT    ELSE      IF DAT MOD 2 = 0 AND DAT > M2 THEN      M2 = DAT      END IF    END IF  IF DAT MOD 14 = 0 AND DAT > M14 THEN    IF M14 > MAX THEN      MAX = M14    END IF  M14 = DAT  ELSE    IF DAT > MAX THEN      MAX = DAT    END IF  END IF NEXT I IF M2 * M7 < M14 * MAX THEN  RES = M14 * MAXELSE  RES = M2 * M7 END IF PRINT RES END Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];  writeln(max);end.",
            "parsed": "2019-04-29 21:13:12.415341",
            "question": "Последовательность натуральных чисел характеризуется числом Х — наибольшим числом, кратным 14 и являющимся произведением двух элементов последовательности с различными номерами.  Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе. А. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.Перед программой укажите версию языка программирования. Обязательно укажите, что программа является решением задания А.Максимальная оценка за выполнение задания А – 2 балла. Б. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.Обязательно укажите, что программа является решением задания Б. Перед текстом программы кратко опишите используемый Вами алгоритм решения.На вход программе в первой строке подаётся количество чисел N. В каждой из последующих N строк записано одно натуральное число, не превышающее 1000.Пример входных данных:540100072855Пример выходных данных для приведённого выше примера входных данных:28000",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body936720\" width=\"100%\"><p class=\"left_margin\">Последовательность натуральных чисел характеризуется числом Х — наибольшим числом, кратным 14 и являющимся произведением двух элементов последовательности с различными номерами.<p> </p><p> </p><p><i>Вам предлагаются два задания, связанные с этой задачей: задание А и задание Б. Вы можете решать оба задания А и Б или одно из них по своему выбору.<p class=\"left_margin\">Итоговая оценка выставляется как максимальная из оценок за задания А и Б. Если решение одного из заданий не представлено, то считается, что оценка за это задание составляет 0 баллов.<p class=\"left_margin\">Задание Б является усложненным вариантом задания А, оно содержит дополнительные требования к программе.</p></p></i><p> </p><p><b>А</b>. Напишите на любом языке программирования программу для решения поставленной задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены все возможные пары элементов.<p class=\"left_margin\">Перед программой укажите версию языка программирования. <b>Обязательно</b> укажите, что программа является решением <b>задания А</b>.<p class=\"left_margin\">Максимальная оценка за выполнение задания А – 2 балла.<p> <p><b>Б</b>. Напишите программу для решения поставленной задачи, которая будет эффективна как по времени, так и по памяти (или хотя бы по одной из этих характеристик).<p class=\"left_margin\">Программа считается эффективной по времени, если время работы программы пропорционально количеству элементов последовательности N, т.е. при увеличении N в k раз время работы программы должно увеличиваться не более чем в k раз.<p><b>Обязательно</b> укажите, что программа является решением <b>задания Б</b>.<p> </p><p class=\"left_margin\">Перед текстом программы кратко опишите используемый Вами алгоритм решения.<p class=\"left_margin\">На вход программе в первой строке подаётся количество чисел N. В каждой из последующих N строк записано одно натуральное число, не превышающее 1000.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">5<p class=\"left_margin\">40<p class=\"left_margin\">1000<p class=\"left_margin\">7<p class=\"left_margin\">28<p class=\"left_margin\">55<p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">28000</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Произведение двух чисел делится на 14, если:— один из сомножителей делится на 14 (второй может быть любым) либо— ни один из сомножителей не делится на 14, но один из сомножителей делится на 7, а другой – на 2.Поэтому программа, вычисляющая число X, может работать так.Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырёх величин:М7 – самое большое число, кратное 7, но не кратное 2;M2 – самое большое число, кратное 2, но не кратное 7;M14 – самое большое число, кратное 14;МAX – самое большое число среди всех элементов последовательности, отличное от М14 (если число М14 встретилось более одного раза и оно же является максимальным, то MAX = M14).После того как все данные прочитаны, искомое число X вычисляется как максимум из произведений М14*MAX и М7*М2.Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы.Допускаются решения, записанные на других языках программирования. Пример правильной и эффективной программы на языке Паскальvar M7,M2,M14,MAX,dat,res,i,N: longint;begin  M7 := 0;  M2 := 0;  M14 := 0;  MAX := 0;  readln(N);  for i := 1 to N do  begin    readln(dat);    if ((dat mod 7) = 0) and ((dat mod 2) > 0) and (dat > M7) then      M7 := dat;    if ((dat mod 2) = 0) and ((dat mod 7) > 0) and (dat > M2) then      M2 := dat;    if (dat mod 14 = 0) and (dat > M14) then    begin      if M14 > MAX then MAX := M14;      M14 := dat    end    else    if dat > MAX then      MAX := dat;  end;  if (M7*M2 < M14*MAX) then    res := M14*MAX  else    res := M7*M2;  writeln(res);  end. Пример правильной и эффективной программы на языке Бейсик: M14 = 0 M7 = 0 M2 = 0 MAX = 0 INPUT N FOR I = 1 TO N  INPUT DAT  IF DAT MOD 7 = 0 AND DAT > M7 THEN    M7 = DAT    ELSE      IF DAT MOD 2 = 0 AND DAT > M2 THEN      M2 = DAT      END IF    END IF  IF DAT MOD 14 = 0 AND DAT > M14 THEN    IF M14 > MAX THEN      MAX = M14    END IF  M14 = DAT  ELSE    IF DAT > MAX THEN      MAX = DAT    END IF  END IF NEXT I IF M2 * M7 < M14 * MAX THEN  RES = M14 * MAXELSE  RES = M2 * M7 END IF PRINT RES END Пример решения задачи А на языке Паскаль.var  a: array[1..10000] of integer; {исходные данные}  N: integer; {количество элементов последовательности}  max: integer; {вычисляемое контрольное значение}  i, j: integer;begin  readln(N);  max := 0;  for i := 1 to N do read(a[i]);  for i := 1 to N-1 do    for j := i+1 to N do      if (a[i]*a[j] > max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];  writeln(max);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol9708\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Произведение двух чисел делится на 14, если:<p class=\"left_margin\">— один из сомножителей делится на 14 (второй может быть любым) либо<p class=\"left_margin\">— ни один из сомножителей не делится на 14, но один из сомножителей делится на 7, а другой – на 2.<p class=\"left_margin\">Поэтому программа, вычисляющая число X, может работать так.<p class=\"left_margin\">Программа читает все входные данные один раз, не запоминая все данные в массиве. Программа для прочитанного фрагмента входной последовательности хранит значения четырёх величин:<p class=\"left_margin\">М7 – самое большое число, кратное 7, но не кратное 2;<p class=\"left_margin\">M2 – самое большое число, кратное 2, но не кратное 7;<p class=\"left_margin\">M14 – самое большое число, кратное 14;<p class=\"left_margin\">МAX – самое большое число среди всех элементов последовательности, отличное от М14 (если число М14 встретилось более одного раза и оно же является максимальным, то MAX = M14).<p class=\"left_margin\">После того как все данные прочитаны, искомое число X вычисляется как максимум из произведений М14*MAX и М7*М2.<p class=\"left_margin\">Ниже приведён пример программы на языке Паскаль, которая реализует описанный алгоритм.<p class=\"left_margin\">Кроме того, приведён пример программы на языке Бейсик, которая правильно решает задачу, но использует алгоритм, немного отличающийся от описанного выше. Возможны и другие правильные алгоритмы.<p class=\"left_margin\">Допускаются решения, записанные на других языках программирования.<p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Паскаль<p><tt><p>var M7,M2,M14,MAX,dat,res,i,N: longint;<p>begin<p>  M7 := 0;<p>  M2 := 0;<p>  M14 := 0;<p>  MAX := 0;<p>  readln(N);<p>  for i := 1 to N do<p>  begin<p>    readln(dat);<p>    if ((dat mod 7) = 0) and ((dat mod 2) &gt; 0) and (dat &gt; M7) then<p>      M7 := dat;<p>    if ((dat mod 2) = 0) and ((dat mod 7) &gt; 0) and (dat &gt; M2) then<p>      M2 := dat;<p>    if (dat mod 14 = 0) and (dat &gt; M14) then<p>    begin<p>      if M14 &gt; MAX then MAX := M14;<p>      M14 := dat<p>    end<p>    else<p>    if dat &gt; MAX then<p>      MAX := dat;<p>  end;<p>  if (M7*M2 &lt; M14*MAX) then<p>    res := M14*MAX<p>  else<p>    res := M7*M2;<p>  writeln(res);<p>  end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p class=\"left_margin\">Пример правильной и эффективной программы на языке Бейсик:<p><tt><p> M14 = 0<p> M7 = 0<p> M2 = 0<p> MAX = 0<p> INPUT N<p> FOR I = 1 TO N<p>  INPUT DAT<p>  IF DAT MOD 7 = 0 AND DAT &gt; M7 THEN<p>    M7 = DAT<p>    ELSE<p>      IF DAT MOD 2 = 0 AND DAT &gt; M2 THEN<p>      M2 = DAT<p>      END IF<p>    END IF<p>  IF DAT MOD 14 = 0 AND DAT &gt; M14 THEN<p>    IF M14 &gt; MAX THEN<p>      MAX = M14<p>    END IF<p>  M14 = DAT<p>  ELSE<p>    IF DAT &gt; MAX THEN<p>      MAX = DAT<p>    END IF<p>  END IF<p> NEXT I<p> IF M2 * M7 &lt; M14 * MAX THEN<p>  RES = M14 * MAX<p class=\"left_margin\">ELSE<p>  RES = M2 * M7<p> END IF<p> PRINT RES<p> END<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p><b>Пример решения задачи А на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  a: array[1..10000] of integer; {исходные данные}<p>  N: integer; {количество элементов последовательности}<p>  max: integer; {вычисляемое контрольное значение}<p>  i, j: integer;<p>begin<p>  readln(N);<p>  max := 0;<p>  for i := 1 to N do read(a[i]);<p>  for i := 1 to N-1 do<p>    for j := i+1 to N do<p>      if (a[i]*a[j] &gt; max) and (a[i]*a[j] mod 14 = 0) then max := a[i] * a[j];<p>  writeln(max);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "source": "",
            "task_id": "9708"
        },
        {
            "answer": "Решение.Очевидно, что вершины невырожденного треугольника должны лежать на разных осях, их координаты должны иметь вид (x, 0) и (0, y). Площадь такого треугольника равна |x| · |y| / 2. Эта площадь будет максимальной при максимальных значениях |x| и |y|.Пример правильной программы на Паскале:program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    xmax, ymax: integer;    s: real; {площадь}    i: integer;begin  readln(N);  xmax:=0; ymax:=0;  for i:=1 to N do begin    readln(x,y);    if (x=0) and (abs(y)>ymax) then ymax:=abs(y);    if (y=0) and (abs(x)>xmax) then xmax:=abs(x);  end;  s:=xmax*ymax/2;  if (s=0) then    writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  maxs: real; {максимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  maxs := 0;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = 0) and (points[i, 2] <> 0) then a := abs(points[i, 2]);      if (points[j, 1] <> 0) and (points[j, 2] = 0) then b := abs(points[j, 1]);      if (a*b>maxs) and (a * b <> 0) then maxs := a*b/2;    end;  if maxs = 0 then writeln('Треугольник не существует')  else writeln(maxs);end.",
            "parsed": "2019-04-29 21:13:18.048178",
            "question": "На плоскости задано множество точек с целочисленными координатами. Необходимо найти максимально возможную площадь невырожденного (то есть, имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на осях координат и при этом принадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение. Напишите эффективную, в том числе по используемой памяти, программу для решения этой задачи. Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.Входные данныеВ первой строке задаётся N – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа – координаты очередной точки.Пример входных данных:36 00 89 7Выходные данныеЕсли искомый треугольник существует, программа должна напечатать одно число: максимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». Пример выходных данных для приведённого выше примера входных данных:24",
            "questionRaw": "<div align=\"justify\" class=\"pbody\" id=\"body936141\" width=\"100%\"><p class=\"left_margin\">На плоскости задано множество точек с целочисленными координатами. Необходимо найти максимально возможную площадь невырожденного (то есть, имеющего ненулевую площадь) треугольника, одна вершина которого расположена в начале координат, а две другие лежат на осях координат и при этом принадлежат заданному множеству. Если такого треугольника не существует, необходимо вывести соответствующее сообщение. <p class=\"left_margin\">Напишите эффективную, в том числе по используемой памяти, программу для решения этой задачи. Перед текстом программы кратко опишите алгоритм решения и укажите язык программирования и его версию.<p class=\"left_margin\">Входные данные<p class=\"left_margin\">В первой строке задаётся <i>N</i> – количество точек в заданном множестве. Каждая из следующих строк содержит два целых числа – координаты очередной точки.<p class=\"left_margin\">Пример входных данных:<p class=\"left_margin\">3<p class=\"left_margin\">6 0<p class=\"left_margin\">0 8<p class=\"left_margin\">9 7<p class=\"left_margin\">Выходные данные<p class=\"left_margin\">Если искомый треугольник существует, программа должна напечатать одно число: максимально возможную площадь треугольника, удовлетворяющего условиям. Если искомый треугольник не существует, программа должна напечатать сообщение: «Треугольник не существует». <p class=\"left_margin\">Пример выходных данных для приведённого выше примера входных данных:<p class=\"left_margin\">24</p></p></p></p></p></p></p></p></p></p></p></p></p></div>",
            "reference": "27 ",
            "solution": "Решение.Очевидно, что вершины невырожденного треугольника должны лежать на разных осях, их координаты должны иметь вид (x, 0) и (0, y). Площадь такого треугольника равна |x| · |y| / 2. Эта площадь будет максимальной при максимальных значениях |x| и |y|.Пример правильной программы на Паскале:program P27;  var    N: integer; {количество точек}    x,y: integer; {координаты очередной точки}    xmax, ymax: integer;    s: real; {площадь}    i: integer;begin  readln(N);  xmax:=0; ymax:=0;  for i:=1 to N do begin    readln(x,y);    if (x=0) and (abs(y)>ymax) then ymax:=abs(y);    if (y=0) and (abs(x)>xmax) then xmax:=abs(x);  end;  s:=xmax*ymax/2;  if (s=0) then    writeln('Треугольник не существует')  else writeln(s)end. Пример правильной, но неэффективной на языке Паскаль.var  points: array[1..10000, 1..2] of integer; {исходные данные}  N: integer; {количество точек}  maxs: real; {максимальная площадь}  a, b: integer;  i, j: integer;begin  readln(N);  maxs := 0;  a := 0; b := 0;  for i := 1 to N do read(points[i, 1], points[i, 2]);  for i := 1 to N do    for j := 1 to N do begin      if (points[i, 1] = 0) and (points[i, 2] <> 0) then a := abs(points[i, 2]);      if (points[j, 1] <> 0) and (points[j, 2] = 0) then b := abs(points[j, 1]);      if (a*b>maxs) and (a * b <> 0) then maxs := a*b/2;    end;  if maxs = 0 then writeln('Треугольник не существует')  else writeln(maxs);end.",
            "solutionRaw": "<div align=\"justify\" class=\"pbody\" id=\"sol9777\" style=\"\" width=\"100%\"><p class=\"left_margin\"></p><b>Решение<!--rule_info-->.</b><p class=\"left_margin\">Очевидно, что вершины невырожденного треугольника должны лежать на разных осях, их координаты должны иметь вид (<i>x</i>, 0) и (0, <i>y</i>). Площадь такого треугольника равна |<i>x</i>| · |<i>y</i>| / 2. Эта площадь будет максимальной при максимальных значениях |<i>x</i>| и |<i>y</i>|.<p class=\"left_margin\">Пример правильной программы на Паскале:<p><tt><p>program P27;<p>  var<p>    N: integer; {количество точек}<p>    x,y: integer; {координаты очередной точки}<p>    xmax, ymax: integer;<p>    s: real; {площадь}<p>    i: integer;<p>begin<p>  readln(N);<p>  xmax:=0; ymax:=0;<p>  for i:=1 to N do begin<p>    readln(x,y);<p>    if (x=0) and (abs(y)&gt;ymax) then ymax:=abs(y);<p>    if (y=0) and (abs(x)&gt;xmax) then xmax:=abs(x);<p>  end;<p>  s:=xmax*ymax/2;<p>  if (s=0) then<p>    writeln('Треугольник не существует')<p>  else writeln(s)<p>end.<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></tt><p> </p><p><b>Пример правильной, но неэффективной на языке Паскаль.</b><pre><div class=\"source_code lang_pascal\">var<p>  points: array[1..10000, 1..2] of integer; {исходные данные}<p>  N: integer; {количество точек}<p>  maxs: real; {максимальная площадь}<p>  a, b: integer;<p>  i, j: integer;<p>begin<p>  readln(N);<p>  maxs := 0;<p>  a := 0; b := 0;<p>  for i := 1 to N do read(points[i, 1], points[i, 2]);<p>  for i := 1 to N do<p>    for j := 1 to N do begin<p>      if (points[i, 1] = 0) and (points[i, 2] &lt;&gt; 0) then a := abs(points[i, 2]);<p>      if (points[j, 1] &lt;&gt; 0) and (points[j, 2] = 0) then b := abs(points[j, 1]);<p>      if (a*b&gt;maxs) and (a * b &lt;&gt; 0) then maxs := a*b/2;<p>    end;<p>  if maxs = 0 then writeln('Треугольник не существует')<p>  else writeln(maxs);<p>end.</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div></pre></p></p></p></p></div>",
            "source": "",
            "task_id": "9777"
        }
    ],
    "taskEGENumber": "27",
    "updated": "2019-05-06 17:29:08.687591"
}